# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeomelbaSpirit
                                 A QGIS plugin
 Based on GeoMelba software, meant to be used with the serious game CAUSERIE.
 This file contains the functions to use when the user configure the first dialog of the plugin.
 Once he clicked on the "Ok" button, some functions are going to launch depending on the parameters he chose.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-08-24
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Jules Grillot / INRAE
        email                : jules.grillot@inrae.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import processing
import tempfile

from qgis.core import QgsProject, QgsSpatialIndex, QgsVectorLayer
from PyQt5.QtCore import QVariant

# Import Homemade module
from .create_depressionless_slope_expo_vector import create_depressionless
from .create_table import create_table

tf = tempfile.TemporaryDirectory()


def create_index(layer):
    index = QgsSpatialIndex()
    features = {}
    for feature in layer.getFeatures():
        features[feature.id()] = feature
        index.addFeature(feature)
    return index, features


class WatershedCreation:

    def __init__(self, crs=None, path=None, parcel_layer=None, line_layer=None, parcel_id=None,
                 land_cover=None, line_id=None, dem_raster=None, fill_polygon=None):
        """The first part of the constructor list the variables.
         Variables are :
        - canvas of gqis
        - the line layer to modify
        - the types of line in the watershed

        The second part is the interface creation :
        - 4 buttons
        - multiple buttons depending on the number of line types
        - a table with 1 column and 3 lines to the represent the type of a line at the top, middle and bottom.
        """
        self.crs = crs
        self.path = path
        self.parcel_layer = parcel_layer
        self.line_layer = line_layer
        self.parcel_id = parcel_id
        self.land_cover = land_cover
        self.line_id = line_id
        self.dem_raster = dem_raster
        self.fill_polygon = fill_polygon

    def processing_chain(self):
        self.parcel_layer.selectAll()
        save_selection_parameters = {'INPUT': self.parcel_layer, 'OUTPUT': 'memory:' + "parcels"}
        parcels_no_crs = processing.run("native:saveselectedfeatures", save_selection_parameters)['OUTPUT']
        self.parcel_layer.removeSelection()
        projection_parameters = {'INPUT': parcels_no_crs, 'CRS': self.crs, 'OUTPUT': 'memory:' + "parcels"}
        parcel_layer = processing.run("native:assignprojection", projection_parameters)['OUTPUT']
        uh_fields = {'gm_id': [QVariant.Int, "int", 10, 0, '$id'],
                     'gm_area': [QVariant.Double, 'double', 20, 2, '$area'],
                     'x': [QVariant.Double, 'double', 20, 2, 'x(centroid($geometry))'],
                     'y': [QVariant.Double, 'double', 20, 2, 'y(centroid($geometry))']}
        if self.parcel_id:
            uh_fields['origin_id'] = [QVariant.String, 'string', 20, 0, "\"{0}\"".format(str(self.parcel_id))]
        if self.land_cover:
            uh_fields['gm_type'] = [QVariant.String, 'string', 20, 0, "{0}".format(self.land_cover)]
        else:
            uh_fields['gm_type'] = [QVariant.String, 'string', 20, 0, "0"]

        self.parcel_layer = create_table(parcel_layer, 'parcels_layer', uh_fields)
        if self.fill_polygon:
            print("fill_emptiness")
        new_line_layer = self.create_linear_from_polygon(self.parcel_layer, self.crs)
        QgsProject().instance().addMapLayer(new_line_layer)
        depressionless_dem = create_depressionless(self.dem_raster, self.crs)
        QgsProject().instance().addMapLayer(depressionless_dem)

    def create_linear_from_polygon(self, polygon, crs):
        parameters_boundary = {'INPUT': polygon, 'OUTPUT': 'memory:boundary'}
        boundary = processing.run("native:boundary", parameters_boundary)['OUTPUT']

        parameters_explode = {'INPUT': boundary, 'OUTPUT': 'memory:explode'}
        explode = processing.run("native:explodelines", parameters_explode)['OUTPUT']
        for feature in explode.getFeatures():
            if not feature.geometry().isGeosValid():
                explode.startEditing()
                explode.deleteFeature(feature.id())
                explode.commitChanges()

        parameters_delete_duplicate = {'INPUT': explode, 'OUTPUT': 'memory:delete_duplicate'}
        line_layer = processing.run("qgis:deleteduplicategeometries", parameters_delete_duplicate)['OUTPUT']

        parameters_extract_vertices = {'INPUT': line_layer, 'OUTPUT': 'memory:extract_vertices'}
        extract_vertices = processing.run("native:extractvertices", parameters_extract_vertices)['OUTPUT']

        parameters_delete_duplicate_2 = {'INPUT': extract_vertices, 'OUTPUT': 'memory:delete_duplicate'}
        point_layer = processing.run("qgis:deleteduplicategeometries", parameters_delete_duplicate_2)['OUTPUT']

        lines_index, lines_features = create_index(line_layer)

        points_to_delete = []
        for point in point_layer.getFeatures():
            neighbours = []
            line_neighbour_ids = lines_index.intersects(point.geometry().boundingBox())
            for line_id in line_neighbour_ids:
                line = lines_features[line_id]
                if point.geometry().touches(line.geometry()):
                    if point.geometry().intersection(line.geometry()).asPoint().x() != 0 and \
                            point.geometry().intersection(line.geometry()).asPoint().y() != 0 and \
                            not point.geometry().intersection(line.geometry()).isEmpty():
                        neighbours.append(line.id())
            if len(neighbours) <= 2:
                points_to_delete.append(point.id())

        point_layer.startEditing()
        point_layer.deleteFeatures(points_to_delete)
        point_layer.commitChanges()
        point_layer.triggerRepaint()

        dissolve_parameters = {'INPUT': line_layer, 'FIELD': [], 'OUTPUT': 'memory:dissolve'}
        dissolve = processing.run("native:dissolve", dissolve_parameters)['OUTPUT']

        line_path = tf.name + '/' + 'polygon_outline.shp'
        edit_parameters = {'map': dissolve, 'type': [1], 'tool': 9, 'input': '', 'move': '', 'threshold': '', 'ids': '',
                           'cats': '', 'coords': '', 'bbox': None, 'polygon': '', 'where': '', 'query': None,
                           'bgmap': point_layer, 'snap': 0, 'zbulk': '', '-r': False, '-c': False, '-n': False,
                           '-b': False, '-1': False, 'output': line_path, 'GRASS_REGION_PARAMETER': None,
                           'GRASS_SNAP_TOLERANCE_PARAMETER': -1, 'GRASS_MIN_AREA_PARAMETER': 0.0001,
                           'GRASS_OUTPUT_TYPE_PARAMETER': 0, 'GRASS_VECTOR_DSCO': '', 'GRASS_VECTOR_LCO': '',
                           'GRASS_VECTOR_EXPORT_NOCAT': False}
        processing.run("grass7:v.edit", edit_parameters)
        line_final_layer = QgsVectorLayer(line_path, 'polygon_outline', 'ogr')

        line_final_layer.startEditing()
        line_final_layer.deleteAttributes(line_final_layer.attributeList())
        line_final_layer.commitChanges()
        line_final_layer.triggerRepaint()

        line_final_layer_crs = line_final_layer.crs()
        line_final_layer_crs.createFromSrid(crs.postgisSrid())
        line_final_layer.setCrs(crs)
        return line_final_layer
