# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeomelbaSpirit
                                 A QGIS plugin
 Based on GeoMelba software, meant to be used with the serious game CAUSERIE.
 This file contains the functions to use when the user configure the dock widget.
 Buttons and widget of the dock widget are controlled with functions from this file.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-08-24
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Jules Grillot / INRAE
        email                : jules.grillot@inrae.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
# QT Modules
from PyQt5.QtCore import QObject
# Qgis Modules
from qgis.PyQt import uic
from qgis.PyQt.QtWidgets import QDockWidget
from qgis.PyQt.QtCore import pyqtSignal
# Personal modules
from .import_variable_from_table import ConfigFilesImport
from .tab.tab_management import TabManagement
from .tab.one_line_modification_tab import OneLineModificationTab
from .tab.multiple_lines_modification_tab import MultipleLinesModificationTab
from .tab.one_parcel_modification_tab import OneParcelModificationTab
from .tab.multiple_parcels_modification_tab import MultipleParcelsModificationTab
from .tab.agricultural_practices_modification_tab import PracticesModificationTab
from .tab.create_cover_tab import CoverCreationTab
from .tab.flow_calculation_tab import FlowCalculationTab
from .tab.plot_creation_tab import PlotCreationTab
from .tab.drain_modification_tab import DrainModificationTab
from .tab.interface_tools.standard_tools import StandardTools
from ..dictionnaire import original_layer_group_name, style_line, field_parcel_owner, river, data_folder, \
    watershed_prefix


FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'spirit_dockwidget_base.ui'))


class SpiritDockWidget(QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()

    def __init__(self, parent=None, iface=None, project=None, watershed_name=None, parcel_layer=None, line_layer=None,
                 style_line_layer=None, connexion_layer=None, crs=None, output_path=None,coded_studied_elements=None,studied_elements=None ):

        """The first part of the constructor list the variables and activate some function based on signal.
         Variables are :
        - qgis interface (iface)
        - qgis project
        - canvas
        - parcel layer
        - line layer (one for the legend and one with the reel layer)
        - connexion layer
        - crs
        - output path
        - an object with every config files
        - the maximum value of the owners number

        The second part of the constructor is the interface creation. An object is created for every tab, for the tools
        used in the plugin and for the flow analysis.
        """
        super(SpiritDockWidget, self).__init__(parent)
        # Variables declaration
        self.iface = iface  # qgis interface
        self.project = project  # qgis project, used for layer management
        canvas = self.iface.mapCanvas()  # canvas, used for select tool
        path = os.path.dirname(__file__) + "/"  # Path of the plugins files, to fetch styles, tables, etc...

        names = [layer.name() for layer in self.project.mapLayers().values()]
        root = self.project.layerTreeRoot()
        group = root.findGroup(original_layer_group_name)
        self.coded_studied_elements=coded_studied_elements
        self.studied_elements=studied_elements

        self.parcel_layer = parcel_layer
        # Add the parcel layer on top of the Qgis layer panel, with the legend expanded.
        root.findLayer(self.parcel_layer).setExpanded(True)
        if len(names) != 0:
            my_layer = root.findLayer(self.parcel_layer.id())
            parent = my_layer.parent()
            if parent.name() != '':
                root.insertLayer(0, self.parcel_layer)
                root.findLayer(self.parcel_layer).setExpanded(True)
                group.removeLayer(self.parcel_layer)

        self.line_layer = line_layer
        # Add a style to the memory layer of lines, so the user can have a legend on the different line types
        self.style_line_layer = style_line_layer
        self.style_line_layer.loadNamedStyle(path + data_folder + watershed_prefix + str(watershed_name) + '/' + style_line)
        self.style_line_layer.triggerRepaint()
        root.findLayer(self.style_line_layer).setExpanded(True)
        my_layer = root.findLayer(self.line_layer.id())
        parent = my_layer.parent()
        if parent.name() != '':
            root.insertLayer(0, self.style_line_layer)
            root.findLayer(self.style_line_layer).setExpanded(True)
            group.removeLayer(self.style_line_layer)
            root.insertLayer(0, self.line_layer)
            root.findLayer(self.line_layer).setExpanded(True)
            group.removeLayer(self.line_layer)
        ltv = self.iface.layerTreeView()
        index = ltv.layerTreeModel().node2index(root.findLayer(self.line_layer.id()))
        ltv.setRowHidden(index.row(), index.parent(), True)
        ltv.setCurrentIndex(ltv.layerTreeModel().node2index(root))
        # self.line_layer.setFlags(QgsMapLayer.Private)

        self.connexion_layer = connexion_layer
        self.project.addMapLayer(connexion_layer)
        root.findLayer(connexion_layer).setExpanded(False)
        root.findLayer(connexion_layer).setItemVisibilityChecked(False)
        my_layer = root.findLayer(connexion_layer.id())
        parent = my_layer.parent()
        if parent.name() != '':
            root.insertLayer(0, connexion_layer)
            root.findLayer(connexion_layer).setExpanded(False)
            root.findLayer(connexion_layer).setItemVisibilityChecked(False)
            group.removeLayer(connexion_layer)
            group.setExpanded(0)
            group.setItemVisibilityChecked(False)

        # Coordinate Reference System.
        self.crs = crs
        # When the CRS is changed, it is reset to the CRS chose by the user.
        self.project.crsChanged.connect(self.crs_change)

        # Output path.
        self.output_path = output_path

        # Get config value.
        self.config_files = ConfigFilesImport(path=path, watershed_name=watershed_name)
        self.drain = None
        self.parcel_layer.set_parameters(self.config_files.production_type, self.config_files.practices)

        # Rivers are deleted from the type list because we don't want the user to add river.
        self.config_files.line_type = {key: val for key, val in self.config_files.line_type.items() if val != river}

        # Connect the signal a layer make when a value of it attribute table change to a function which is going to
        # write changes in the CSV
        self.parcel_layer.attributeValueChanged.connect(self.write_change)
        self.line_layer.attributeValueChanged.connect(self.write_change)

        # Check if there is owner to enable or not some interface feature.
        idx = self.parcel_layer.fields().indexFromName(field_parcel_owner)  # Proprietary field index.
        self.max_owner = self.parcel_layer.maximumValue(idx)  # Get maximum number of owner.

        # Variables to manage layer visibility function
        self.signal_layer_order = 0
        self.project.layerTreeRoot().visibilityChanged.connect(self.layer_visibility_management)

        # Setup the interface
        self.setupUi(self)

        # Tab order can be modified in the tab_management.py file.
        # Creation of the tab widget
        self.tab_widget_management = TabManagement(tab_widget=self.tabWidget, project=self.project, canvas=canvas,
                                                   iface=self.iface, style_line_layer=self.style_line_layer,
                                                   line_layer=self.line_layer, parcel_layer=self.parcel_layer,
                                                   path=path, watershed_name=watershed_name, crs=self.crs)

        # Tab modification of one line
        one_line_modification = OneLineModificationTab(parent=self.tab_widget_management, canvas=canvas,
                                                       line_layer=self.line_layer,
                                                       line_type=self.config_files.line_type)
        # Tab modification of multiple line
        self.multiple_lines_modification = MultipleLinesModificationTab(parent=self.tab_widget_management,
                                                                        line_layer=self.line_layer,
                                                                        line_type=self.config_files.line_type)
        # Tab modification of one parcel
        one_parcel_modification = OneParcelModificationTab(parent=self.tab_widget_management, canvas=canvas,
                                                           parcel_layer=self.parcel_layer,
                                                           land_cover=self.config_files.land_cover)
        # Tab modification of multiple parcels
        self.multiple_parcels_modification = MultipleParcelsModificationTab(parent=self.tab_widget_management,
                                                                            parcel_layer=self.parcel_layer,
                                                                            land_cover=self.config_files.land_cover,
                                                                            max_owner=self.max_owner,
                                                                            production_type=self.config_files.production_type)
        # Tab modification of agricultural practices
        self.practices_modification = PracticesModificationTab(parent=self.tab_widget_management, canvas=canvas,
                                                          parcel_layer=self.parcel_layer,
                                                          practices=self.config_files.practices,
                                                          max_owner=self.max_owner)
        # Tab show only the parcels of one owner by creating a cover on other parcels.
        self.cover_creation = CoverCreationTab(parent=self.tab_widget_management, project=self.project,
                                               parcel_layer=self.parcel_layer, max_owner=self.max_owner)

        # Tab plot results
        #self.plot_creation = PlotCreationTab(parent=self.tab_widget_management)

        # Tab drain results
        self.drain_modification = DrainModificationTab(parent=self.tab_widget_management, path=path,
                                                       watershed_name=watershed_name,
                                                       drain_type=self.config_files.drain_type,
                                                       parcel_layer=self.parcel_layer,
                                                       line_layer=self.line_layer)

        # Creation of the widgets at the Top of the plugin, zoom on 1 parcel, zoom on all the watershed or rollback last
        # modification.
        self.standard_tools = StandardTools(parcel_layer=self.parcel_layer, iface=self.iface, path=path,
                                            project=self.project,
                                            scrollAreaWidgetContents=self.scrollAreaWidgetContents,
                                            tab_widget=self.tabWidget, tab_widget_management=self.tab_widget_management,
                                            config_files=self.config_files, drain_modif=self.drain_modification,
                                            multiple_lines_modif=self.multiple_lines_modification,
                                            multiple_parcels_modif=self.multiple_parcels_modification,
                                            practices_modification=self.practices_modification,
                                            cover_creation=self.cover_creation, drain=self.drain)

        # Seventh tab launch multiples water flow abatement calculation
        self.flow_calculation_tab = FlowCalculationTab(parent=self.tab_widget_management, canvas=canvas,
                                                       production_type=self.config_files.production_type,
                                                       practices=self.config_files.practices,
                                                       slope=self.config_files.slope,
                                                       land_cover=self.config_files.land_cover,
                                                       abatement_type=self.config_files.abatement_type,
                                                       abatement=self.config_files.abatement,
                                                       abatement_water=self.config_files.abatement_water,
                                                       abatement_mes=self.config_files.abatement_mes,
                                                       abatement_phyto=self.config_files.abatement_phyto,
                                                       production=self.config_files.production,
                                                       production_water=self.config_files.production_water,
                                                       production_mes=self.config_files.production_mes,
                                                       production_phyto=self.config_files.production_phyto,
                                                       line_type=self.config_files.line_type,
                                                       abatement_type_long=self.config_files.abatement_type_long,
                                                       abatement_type_lat=self.config_files.abatement_type_lat,
                                                       abatement_long=self.config_files.abatement_long,
                                                       abatement_long_water=self.config_files.abatement_long_water,
                                                       abatement_long_mes=self.config_files.abatement_long_mes,
                                                       abatement_long_phyto=self.config_files.abatement_long_phyto,
                                                       abatement_lat=self.config_files.abatement_lat,
                                                       abatement_lat_water=self.config_files.abatement_lat_water,
                                                       abatement_lat_mes=self.config_files.abatement_lat_mes,
                                                       abatement_lat_phyto=self.config_files.abatement_lat_phyto,
                                                       output_path=self.output_path,
                                                       connexion_layer=self.connexion_layer,
                                                       button_rollback=self.standard_tools.button_rollback,
                                                       coded_studied_elements=self.coded_studied_elements,
                                                       studied_elements=self.studied_elements)#,
                                                       #plot_creation=self.plot_creation)

        # Layer control parameters
        self.parcel_layer.selectionChanged.connect(self.check_valid)
        self.line_layer.selectionChanged.connect(self.check_valid)
        self.tab_widget_management.addLayers(self.parcel_layer)
        self.tab_widget_management.addLayers(self.line_layer)
        self.tab_widget_management.addButtons(self.multiple_parcels_modification.spinbox_owner)
        self.tab_widget_management.addButtons(self.practices_modification.spinbox_owner)
        self.tab_widget_management.addButtons(self.flow_calculation_tab.button_parcel_reception)
        self.tab_widget_management.addButtons(self.flow_calculation_tab.button_parcel_emit)
        self.tab_widget_management.addCheckboxes(self.multiple_parcels_modification.checkbox_owner)
        self.tab_widget_management.addCheckboxes(self.practices_modification.checkbox_owner)
        self.tab_widget_management.addCheckboxes(self.flow_calculation_tab.button_select_river_section)
        self.tab_widget_management.addCheckboxes(self.flow_calculation_tab.button_select_parcel)
        self.tabWidget.currentChanged.connect(self.layer_control)

        self.standard_tools.zoom_watershed()

    def layer_control(self):
        """When the tab is changed, the layers might change depending on the tab.
        """
        self.tab_widget_management.layer_order()

    def signal_stop_flow_calculation(self):
        """Get the value of the signal emitted when an analysis is done. The changes made to the layers must not be
        written if they are made during an analysis.
        """
        return self.flow_calculation_tab.return_signal()

    def check_valid(self):
        """Check if some buttons can be enabled. The buttons concerned are the one to launch analysis on selected
        features. The user needs to be on the right tab, at least 1 watershed analysis must have been made and a feature
        must be selected. Else buttons are disabled.
        """
        # Test the tab index and the count of watershed analysis.
        idx = self.tabWidget.currentIndex()
        if idx == self.tab_widget_management.tab_index_abatement and \
                self.tab_widget_management.count_watershed_analysis >= 0:
            # If a parcel is selected enabled the 2 buttons launching analysis on a parcel.
            if self.sender().selectedFeatureCount() > 0 and self.sender() == self.parcel_layer:
                self.flow_calculation_tab.button_parcel_emit.setEnabled(True)
                self.flow_calculation_tab.button_parcel_reception.setEnabled(True)
            # If a line is selected enabled the button launching analysis on a river section.
            elif self.sender().selectedFeatureCount() > 0 and self.sender() == self.line_layer:
                self.flow_calculation_tab.button_river_reception.setEnabled(True)
            # Else all buttons are disabled.
            else:
                self.flow_calculation_tab.button_parcel_emit.setEnabled(False)
                self.flow_calculation_tab.button_parcel_reception.setEnabled(False)
                self.flow_calculation_tab.button_river_reception.setEnabled(False)

    def crs_change(self):
        """Function used to reset the crs, it can change when the map viewer is open.
        """
        self.project.setCrs(self.crs)

    def write_change(self, feature_id, field_index, new_value):
        """Write the modification on the parcel layer and line layer into a CSV file. First a signal is fetch from the
        flow calculation object to check if the changes need to be written.
        """
        signal_stop_flow = self.signal_stop_flow_calculation()
        self.standard_tools.write_change(self.sender(), feature_id, field_index, new_value, signal_stop_flow)

    def layer_visibility_management(self, layerTreeNode):
        """Manage the layers visible and expanded. Only the parcel, line and connexion layer are not in a
        folder. Every analysis is stocked into a specific folder. If a folder is open, all other folders and layers are
        not visible and expanded. The folder is expanded so the user can see the legend. Only one folder can be visible.
        """
        if type(layerTreeNode) != QObject:
            # If the Node modified in the layer panel is a folder.
            if layerTreeNode.nodeType() == 0 and self.signal_layer_order == 0:
                self.signal_layer_order = 1
                # If the folder is checked every layer in the folder is open and expanded.
                if layerTreeNode.isVisible():
                    self.project.layerTreeRoot().findGroup(layerTreeNode.name()).setExpanded(1)
                    # Every other Node are closed.
                    for group in self.project.layerTreeRoot().children():
                        if group.name() != layerTreeNode.name() and group.name() != layerTreeNode.parent().name():
                            # If the Node modified in the layer panel is a folder.
                            if group.nodeType() == 0:
                                self.project.layerTreeRoot().findGroup(group.name()).setItemVisibilityChecked(False)
                                self.project.layerTreeRoot().findGroup(group.name()).setExpanded(0)
                            # If the Node modified in the layer panel is a layer.
                            else:
                                layer = group.layer()
                                self.project.layerTreeRoot().findLayer(layer.id()).setItemVisibilityChecked(
                                    False)
                                self.project.layerTreeRoot().findLayer(layer.id()).setExpanded(0)
                    for group in layerTreeNode.children():
                        if group.nodeType() == 0:
                            self.project.layerTreeRoot().findGroup(group.name()).setItemVisibilityChecked(True)
                            self.project.layerTreeRoot().findGroup(group.name()).setExpanded(1)
                        else:
                            if len(self.project.mapLayersByName(group.name())) > 0:
                                for layer in self.project.mapLayersByName(group.name()):
                                    if self.project.layerTreeRoot().findLayer(layer.id()):
                                        if self.project.layerTreeRoot().findLayer(layer.id()).parent() == layerTreeNode:
                                            self.project.layerTreeRoot().findLayer(layer.id()).setExpanded(1)
                                            self.project.layerTreeRoot().findLayer(layer.id()).setItemVisibilityChecked(
                                                True)
                else:
                    self.project.layerTreeRoot().findGroup(layerTreeNode.name()).setExpanded(0)
                self.signal_layer_order = 0
            # If the Node modified in the layer panel is a layer.
            if layerTreeNode.nodeType() == 1 and self.signal_layer_order == 0:
                self.signal_layer_order = 1
                layer = layerTreeNode.layer()
                # If the layers is opened.
                if layerTreeNode.isVisible():
                    self.project.layerTreeRoot().findLayer(layer.id()).setExpanded(1)
                    # If the layer is the style line layer, the parcel layer needs to be open and expanded. The line
                    # layer needs to be open
                    if layerTreeNode.name() == self.style_line_layer.name():
                        self.project.layerTreeRoot().findLayer(self.parcel_layer.id()).setItemVisibilityChecked(True)
                        self.project.layerTreeRoot().findLayer(self.parcel_layer.id()).setExpanded(1)
                        self.project.layerTreeRoot().findLayer(self.line_layer.id()).setItemVisibilityChecked(True)
                    # If the layer is the parcel layer, the style line layer needs to be open and expanded. The line
                    # layer needs to be open
                    elif layerTreeNode.name() == self.parcel_layer.name():
                        self.project.layerTreeRoot().findLayer(self.line_layer.id()).setItemVisibilityChecked(True)
                        self.project.layerTreeRoot().findLayer(self.style_line_layer.id()).setItemVisibilityChecked(
                            True)
                        self.project.layerTreeRoot().findLayer(self.style_line_layer.id()).setExpanded(1)

                    elif layerTreeNode.parent() != self.project.layerTreeRoot():
                        layerTreeNode.parent().setItemVisibilityCheckedRecursive(True)
                        if len(self.project.mapLayersByName(layerTreeNode.name())) > 1:
                            for layer in self.project.mapLayersByName(layerTreeNode.name()):
                                self.project.layerTreeRoot().findLayer(layer.id()).setExpanded(1)
                                self.project.layerTreeRoot().findLayer(layer.id()).setItemVisibilityChecked(True)

                    # Every other Node are closed.
                    for group in self.project.layerTreeRoot().children():
                        if group.name() != layerTreeNode.name():
                            if group.nodeType() == 0:
                                self.project.layerTreeRoot().findGroup(group.name()).setItemVisibilityChecked(
                                    False)
                                self.project.layerTreeRoot().findGroup(group.name()).setExpanded(0)
                # If the layers is closed, other layers are closed.
                else:
                    self.project.layerTreeRoot().findLayer(layer.id()).setExpanded(0)
                    if layerTreeNode.name() == self.style_line_layer.name():
                        self.project.layerTreeRoot().findLayer(self.parcel_layer.id()).setItemVisibilityChecked(False)
                        self.project.layerTreeRoot().findLayer(self.parcel_layer.id()).setExpanded(0)
                        self.project.layerTreeRoot().findLayer(self.line_layer.id()).setItemVisibilityChecked(False)
                    elif layerTreeNode.name() == self.parcel_layer.name():
                        self.project.layerTreeRoot().findLayer(self.line_layer.id()).setItemVisibilityChecked(False)
                        self.project.layerTreeRoot().findLayer(self.style_line_layer.id()).setItemVisibilityChecked(
                            False)
                        self.project.layerTreeRoot().findLayer(self.style_line_layer.id()).setExpanded(0)
                    elif layerTreeNode.parent() != self.project.layerTreeRoot():
                        layerTreeNode.parent().setItemVisibilityCheckedRecursive(False)
                        if len(self.project.mapLayersByName(layerTreeNode.name())) > 1:
                            for layer in self.project.mapLayersByName(layerTreeNode.name()):
                                self.project.layerTreeRoot().findLayer(layer.id()).setExpanded(0)
                                self.project.layerTreeRoot().findLayer(layer.id()).setItemVisibilityChecked(False)
                self.signal_layer_order = 0

    def resizeEvent(self, event):
        """Add ScrollBar to the plugin if its size changes.
        The mandatory arguments are :
        - an event on the plugin
        NB: don't change the function name
        """
        self.scrollArea.resize(event.size().width(), event.size().height() - 70)

    def closeEvent(self, event):
        """Add action when the plugin is closed.
        The mandatory arguments are :
        - an event on the plugin
        NB: don't change the function name
        """
        self.closingPlugin.emit()
        event.accept()
