# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeomelbaSpirit
                                 A QGIS plugin
 Based on GeoMelba software, meant to be used with the serious game CAUSERIE.
 This file contains the functions to use when the user configure the dock widget.
 Buttons and widget of the dock widget are controlled with functions from this file.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-08-24
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Jules Grillot / INRAE
        email                : jules.grillot@inrae.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import gc
import processing
# Import Qgis modules
from qgis.core import QgsExpression, QgsFeatureRequest, QgsVectorLayer, QgsProject
# Import personal modules
from .interface_tools.buttonpointer import ButtonPointer
from ...dictionnaire import owner_cover_layer_name, style_parcels_practices, style_parcel, field_parcel_owner, \
    style_owner_cover, agricultural_practices_layer_name, style_folder, watershed_prefix


class TabManagement:
    # Count the number of turn, the first turn is the initial state (0).
    _count_watershed_ = -1

    def __init__(self, tab_widget=None, project=None, canvas=None, iface=None, style_line_layer=None, line_layer=None,
                 parcel_layer=None, path=None, watershed_name=None, crs=None):
        """The first part of the constructor list the variables. This is the document where the order of the tab can be
        changed. Some function are also used to managed the layer order and the cover creation/removal.
        """
        self.tab_widget = tab_widget
        self._project = project
        self.canvas = canvas
        self.iface = iface
        self.style_line_layer = style_line_layer
        self.line_layer = line_layer
        self.parcel_layer = parcel_layer
        self.path = path
        self.watershed_name = watershed_name
        self.crs = crs

        self.idx = 0
        self._tab_index_one_parcel = 0
        self._tab_index_multiple_parcels = 1
        self._tab_index_agricultural_practices = 2
        self._tab_index_owner = 3
        self._tab_index_one_line = 4
        self._tab_index_multiple_lines = 5
        self._tab_index_drain = 6
        self._tab_index_abatement = 7
        self._tab_index_plot = 8

        self.layers = []
        self.buttons = []
        self.checkboxes = []
        self.tabs = []

    # Function to increment a number
    @staticmethod
    def incrementation(number):
        number = number + 1
        return number

    # Function to decrement a number
    @staticmethod
    def decrement(number):
        number = number - 1
        return number

    def new_watershed_analysis(self):
        TabManagement._count_watershed_ += 1

    @property
    def count_watershed_analysis(self) -> int:
        return self._count_watershed_

    @property
    def project(self) -> QgsProject():
        return self._project

    @property
    def tab_index_one_line(self) -> int:
        return self._tab_index_one_line

    @property
    def tab_index_multiple_lines(self) -> int:
        return self._tab_index_multiple_lines

    @property
    def tab_index_one_parcel(self) -> int:
        return self._tab_index_one_parcel

    @property
    def tab_index_multiple_parcels(self) -> int:
        return self._tab_index_multiple_parcels

    @property
    def tab_index_agricultural_practices(self) -> int:
        return self._tab_index_agricultural_practices

    @property
    def tab_index_owner(self) -> int:
        return self._tab_index_owner

    @property
    def tab_index_abatement(self) -> int:
        return self._tab_index_abatement

    @property
    def tab_index_plot(self) -> int:
        return self._tab_index_plot

    @property
    def tab_index_drain(self) -> int:
        return self._tab_index_drain

    def addLayers(self, layer):  # add spinbox to its list
        """Add a spinbox to the manager.
        The variables are :
        - the spinbox to add to the manager.
        """
        self.layers.append(layer)

    def addButtons(self, button):  # add spinbox to its list
        """Add a spinbox to the manager.
        The variables are :
        - the spinbox to add to the manager.
        """
        self.buttons.append(button)

    def addCheckboxes(self, checkbox):  # add spinbox to its list
        """Add a spinbox to the manager.
        The variables are :
        - the spinbox to add to the manager.
        """
        self.checkboxes.append(checkbox)

    # Functions to create covers based on an owner
    def create_cover(self, owner_number):
        """Create cover based on the buttons clicked by the user in the owner tab.
        The mandatory arguments are :
        - the owner number

        The function first check if a cover already exists in the project. If one exists it's deleted.
        To create the cover, all the parcels with a different owner number than the one chosen by the user are selected.
        Their geometries are duplicated into a memory layer. Then a style is applied to this layer.
        It's a basic white style allowing the geometries to be hidden and cover the parcels.
        The layer is placed on top of every other layer.
        """
        # List the layers present in the project
        names = [layer.name() for layer in self.project.mapLayers().values()]
        # If a layer with the name of the cover exist, it is deleted.
        for string in names:
            if len(string.split(owner_cover_layer_name, 1)) > 1:
                cover_layer = self.project.mapLayersByName(string)
                self.project.removeMapLayer(cover_layer[0].id())
        # Empty list which is going to contain every id of parcels that need to be cover.
        select_list = []
        # Select the parcels with a different owner from the one chosen by the user and add their id to the list.
        select_uh_owner = QgsExpression("{field_owner} != '{owner}'".format(field_owner=field_parcel_owner,
                                                                            owner=owner_number))
        for f in self.parcel_layer.getFeatures(QgsFeatureRequest(select_uh_owner)):
            select_list.append(f)
        # Create the memory layer for the cover.
        layer_name = owner_cover_layer_name + str(owner_number)
        cover_layer = QgsVectorLayer("Polygon?crs=" + str(self.crs), layer_name, "memory")
        # Add all the features to be hide to the cover layer.
        cover_layer.dataProvider().addFeatures(select_list)
        cover_layer.updateExtents()
        # Add the layer to the project.
        self.project.addMapLayers([cover_layer])
        # Load a style for the cover.
        cover_layer.loadNamedStyle(style_owner_cover)
        cover_layer.triggerRepaint()
        # The layer when added to the project is not always added to the same place depending on the where the user
        # clicked before creating the cover. The cover layer is duplicated at the top of the layer tree and then the
        # first version is deleted.
        root = self.project.layerTreeRoot()
        layer = self.project.mapLayersByName(layer_name)[0]
        layer_id = root.findLayer(self.project.mapLayersByName(layer_name)[0].id())
        parent_group = layer_id.parent()
        if parent_group.name() != '':
            my_group = self.project.layerTreeRoot().findGroup(parent_group.name())
            self.project.layerTreeRoot().insertLayer(0, layer)
            my_group.removeLayer(layer)
            self.project.layerTreeRoot().findGroup(parent_group.name()).setExpanded(0)
        else:
            order = root.customLayerOrder()
            order.insert(0, order.pop(order.index(layer)))
            root.setCustomLayerOrder(order)
        # The layer is deleted from the layer tree, if the user wants to delete it, he has to use the specific button.
        ltv = self.iface.layerTreeView()
        index = ltv.layerTreeModel().node2index(root.findLayer(layer.id()))
        ltv.setRowHidden(index.row(), index.parent(), True)
        ltv.setCurrentIndex(ltv.layerTreeModel().node2index(root))

    # Functions to delete the cover
    def delete_cover(self):
        """Delete cover linked to the signal emitted by the button.
        The function check if a cover already exists in the project. If one exists it's deleted.
        After deleting the cover, the map is automatically zoomed on the entire watershed.
        """
        # List the layers present in the project
        names = [layer.name() for layer in self.project.mapLayers().values()]
        # If a layer with the name of the cover exist, it is deleted.
        for string in names:
            if len(string.split(owner_cover_layer_name, 1)) > 1:
                cover_layer = self.project.mapLayersByName(string)
                self.project.removeMapLayer(cover_layer[0].id())
        # self.zoom_watershed()  # Function to zoom on the watershed
        self.canvas.refreshAllLayers()

    def layer_order(self):
        """Change layer style or visibility depending on the tab selected by the user.
        The owner tab is the only tab with no style modification.
        The plot and abatement tab open the abatement layers if already created.
        The practices tab change the style of the parcel layer to show the different practices on the watershed.
        Other tabs all show the parcel and line layer with the default style.
        """
        old_idx = self.idx
        self.idx = self.tab_widget.currentIndex()
        for obj in gc.get_objects():
            if isinstance(obj, ButtonPointer):
                obj.unset_map_tool()
        # Selection on layers are removed if the tab is changed.
        for layer in self.layers:
            layer.removeSelection()
        # The abatement buttons on selected features are disabled.
        for button in self.buttons:
            button.setEnabled(False)
        for checked in self.checkboxes:
            checked.setChecked(False)

        # If the tab selected is the practices, one the parcel layer change style.
        if self.idx == self.tab_index_agricultural_practices:
            for group in self.project.layerTreeRoot().children():
                if self.project.layerTreeRoot().isGroup(group):
                    self.project.layerTreeRoot().findGroup(group.name()).setItemVisibilityChecked(False)
                    self.project.layerTreeRoot().findGroup(group.name()).setExpanded(0)
                elif (group.name() == self.style_line_layer.name() or group.name() == self.line_layer.name() or
                      group.name() == self.parcel_layer.name() and group.isVisible() is False):
                    layer = self.project.mapLayersByName(group.name())[0]
                    self.project.layerTreeRoot().findLayer(layer.id()).setItemVisibilityChecked(False)
                    self.project.layerTreeRoot().findLayer(layer.id()).setExpanded(0)
            # List the layers present in the project
            names = [layer.name() for layer in self.project.mapLayers().values()]
            layer_index = 0
            for string in names:
                if len(string.split(owner_cover_layer_name, 1)) > 1:
                    layer_index = string
                if string == agricultural_practices_layer_name:
                    practices_layer = self.project.mapLayersByName(string)
                    self.project.removeMapLayer(practices_layer[0].id())
            self.parcel_layer.selectAll()
            practices_layer = processing.run("native:saveselectedfeatures",
                                             {'INPUT': self.parcel_layer,
                                              'OUTPUT': 'memory:' + agricultural_practices_layer_name})['OUTPUT']
            self.parcel_layer.removeSelection()
            crs = practices_layer.crs()
            crs.createFromId(self.crs.postgisSrid())
            practices_layer.setCrs(crs)
            self.project.addMapLayers([practices_layer])
            practices_layer.loadNamedStyle(style_parcels_practices)
            practices_layer.triggerRepaint()
            # The layer when added to the project is not always added to the same place depending on where the
            # user clicked before creating the cover. The cover layer is duplicated at the top of the layer tree and
            # then the first version is deleted.
            root = self.project.layerTreeRoot()
            layer_name = agricultural_practices_layer_name
            layer = self.project.mapLayersByName(layer_name)[0]
            layer_id = root.findLayer(self.project.mapLayersByName(layer_name)[0].id())
            parent_group = layer_id.parent()
            if parent_group.name() != '':
                my_group = self.project.layerTreeRoot().findGroup(parent_group.name())
                self.project.layerTreeRoot().insertLayer(0, layer)
                my_group.removeLayer(layer)
                self.project.layerTreeRoot().findGroup(parent_group.name()).setExpanded(0)
            else:
                order = root.customLayerOrder()
                order.insert(0, order.pop(order.index(layer)))
                root.setCustomLayerOrder(order)
            if layer_index != 0:
                if len(layer_index.split(owner_cover_layer_name, 1)) > 1:
                    owner = layer_index.split(owner_cover_layer_name, 1)[1]
                    self.delete_cover()
                    self.create_cover(owner)
        # For the all tab except owner, the parcel and line layer are shown and expanded.
        elif self.idx != self.tab_index_owner:
            # List the layers present in the project
            names = [layer.name() for layer in self.project.mapLayers().values()]
            # If a layer with the name of the cover exist, it is deleted.
            for string in names:
                if string == agricultural_practices_layer_name:
                    practices_layer = self.project.mapLayersByName(string)
                    self.project.removeMapLayer(practices_layer[0].id())
            # Else the parcel layer gets it's default style.
            self.parcel_layer.loadNamedStyle(style_folder + watershed_prefix + str(self.watershed_name) + "/" + style_parcel)
            self.parcel_layer.triggerRepaint()
            for group in self.project.layerTreeRoot().children():
                if self.project.layerTreeRoot().isGroup(group):
                    self.project.layerTreeRoot().findGroup(group.name()).setItemVisibilityChecked(False)
                    self.project.layerTreeRoot().findGroup(group.name()).setExpanded(0)
                elif (group.name() == self.style_line_layer.name() or group.name() == self.line_layer.name() or
                      group.name() == self.parcel_layer.name() and group.isVisible() is False):
                    layer = self.project.mapLayersByName(group.name())[0]
                    self.project.layerTreeRoot().findLayer(layer.id()).setItemVisibilityChecked(True)
                    self.project.layerTreeRoot().findLayer(layer.id()).setExpanded(1)

