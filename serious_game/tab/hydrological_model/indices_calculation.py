# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeomelbaSpirit
                                 A QGIS plugin
 Based on GeoMelba software, meant to be used with the serious game CAUSERIE.
 This file contains the functions to realize the different analysis.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-08-24
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Jules Grillot / INRAE
        email                : jules.grillot@inrae.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os.path
import processing
# Qgis Modules
from qgis.PyQt.QtCore import QVariant
from qgis.core import QgsVectorFileWriter, QgsProject, QgsCoordinateReferenceSystem, QgsVectorLayer, QgsField, \
    QgsFeatureRequest, QgsExpression, NULL, QgsLayerTreeLayer, QgsRuleBasedRenderer, QgsSymbol, QgsSimpleLineSymbolLayer
# QT Modules
from PyQt5.QtGui import QColor
from PyQt5.QtCore import Qt
# Personal Modules
from .coeff_abatement import parcel_inflow_production, coefficient_abatement_UH, coefficient_abatement_lateral_TE, \
    coefficient_abatement_longitudinal_TE
from ....dictionnaire import field_order, field_type_line_middle, null, field_incoming_flow, \
    field_incoming_flow_from_line, field_incoming_flow_from_parcel, field_outgoing_flow, field_outgoing_flow_long, \
    field_outgoing_flow_lat, field_flow_abatement, field_flow_abatement_rating, \
    field_incoming_flow_rating, field_outgoing_flow_long_up, field_outgoing_flow_long_down, field_history, \
    field_history_abatement, field_history_abatement_lat, field_history_abatement_long, field_history_outflow_long, \
    field_history_outflow_long_up, field_history_outflow_long_down, field_history_abatement_long_up, \
    field_history_abatement_long_down, field_flow_production_water, field_flow_production_mes, \
    field_flow_production_phyto, field_parcel_above, field_parcel_below, field_type_parcel, field_parcel_area, \
    field_parcel_slope, field_parcel_practice, field_outgoing_flow_line_to_parcel, field_line_parcel_below, \
    field_line_parcel_above, field_connexions_parcel_above, field_connexions_flow_coefficient, field_parcel_id, \
    field_type_line_top, field_connexions_parcel_below, field_type_line_bottom, field_line_slope, \
    field_line_line_above, field_line_id, river, field_line_length, field_line_slope_angle, field_line_line_below, \
    drain, field_parcel_slope_length, lines_not_river_layer_name, river_incoming_flow_layer_name, field_outlet_inflow, \
    line_abatement_layer_name, line_transfer_layer_name, parcel_abatement_layer_name, parcel_transfer_layer_name, \
    field_flow_production_relative, field_flow_production_rating, parcel_contribution_layer_name, \
    group_watershed_analysis, group_abatement_analysis, group_flow_transfer, field_parcel_rating, \
    field_feature_selected, group_outgoing_flow_parcel, group_incoming_flow_parcel, field_connexions_river_below, \
    group_incoming_flow_river, field_parcel_outflow_drain, field_parcel_active_drain, field_flow_production_area, \
    field_flow_production_area_river, field_flow_river_rate, field_parcel_drain_type, field_river_direction, \
    field_river_slope_angle_up, field_river_slope_angle_dwn, field_line_outflow_direction, field_parcel_drain_id, \
    field_flow_production, field_history_water, field_history_mes, field_history_phyto, field_history_abatement_water, \
    field_history_abatement_mes, field_history_abatement_phyto, field_history_abatement_lat_water, \
    field_history_abatement_lat_mes, field_history_abatement_lat_phyto, field_history_abatement_long_water, \
    field_history_abatement_long_mes, field_history_abatement_long_phyto, river_direction_up, river_direction_dwn, \
    river_direction_different_direction, abatement_map_line_legend_pt1, abatement_map_line_legend_pt2, \
    abatement_map_line_legend_pt3, abatement_map_line_legend_pt4, abatement_map_line_legend_pt5, \
    abatement_map_line_legend_pt6, abatement_map_line_legend_pt7, abatement_map_line_legend_pt8, \
    abatement_map_parcel_legend_pt1, abatement_map_parcel_legend_pt2, abatement_map_parcel_legend_pt3, \
    abatement_map_parcel_legend_pt4, abatement_map_parcel_legend_pt5, abatement_map_parcel_legend_pt6, \
    abatement_map_parcel_legend_pt7, abatement_map_parcel_legend_pt8, transfer_map_river_legend_pt1, \
    transfer_map_river_legend_pt2, transfer_map_river_legend_pt3, transfer_map_river_legend_pt4, \
    transfer_map_river_legend_pt5, transfer_map_river_legend_pt6, transfer_map_river_legend_pt7, \
    transfer_map_river_legend_pt8, transfer_map_line_legend_pt1, transfer_map_line_legend_pt2, \
    transfer_map_line_legend_pt3, transfer_map_line_legend_pt4, transfer_map_line_legend_pt5, \
    transfer_map_line_legend_pt6, transfer_map_line_legend_pt7, transfer_map_parcel_legend_pt1, \
    transfer_map_parcel_legend_pt2, transfer_map_parcel_legend_pt3, transfer_map_parcel_legend_pt4, \
    transfer_map_parcel_legend_pt5, transfer_map_parcel_legend_pt6, transfer_map_parcel_legend_pt7, \
    production_potential_map_parcel_legend_pt1, production_potential_map_parcel_legend_pt2, \
    production_potential_map_parcel_legend_pt3, production_potential_map_parcel_legend_pt4, \
    production_potential_map_parcel_legend_pt5, production_potential_map_parcel_legend_pt6, \
    production_potential_map_parcel_legend_pt7, production_area_map_parcel_legend_pt1, \
    production_area_map_parcel_legend_pt2, production_area_map_parcel_legend_pt3, \
    production_area_map_parcel_legend_pt4, production_area_map_parcel_legend_pt5, \
    production_area_map_parcel_legend_pt6, production_area_map_parcel_legend_pt7, \
    parcel_river_map_production_legend_pt1, parcel_river_map_production_legend_pt2, \
    parcel_river_map_production_legend_pt3, parcel_river_map_production_legend_pt4, \
    parcel_river_map_production_legend_pt5, parcel_river_map_production_legend_pt6, \
    parcel_river_map_production_legend_pt7, parcel_river_map_production_legend_pt8, \
    parcel_river_map_production_legend_pt9, parcel_river_map_production_legend_pt10, \
    parcel_river_map_production_legend_pt11, parcel_river_map_production_legend_pt12

path = os.path.dirname(__file__) + '/'


def update_flow_history(dict_1, dict_2, coeff):
    """
    Function used to update the history dictionary when 2 flows need to be added, based on variables like :
    - the history dictionary (dictionary)
    - another history dictionary, we need to add to the first one (dictionary)
    - a flow coefficient to multiply value of the second history into the first one (double)
    """
    for key in dict_2:
        # If the key already exist in the dictionary, the previous value is added to the one from the second dictionary.
        if key in dict_1:
            dict_1[key] = dict_1[key] + dict_2[key] * coeff
        # If the key doesn't exist, only the new value is added to the history dictionary.
        else:
            dict_1[key] = dict_2[key] * coeff
    return dict_1


def update_flow_history_abat(dict_1, dict_2, coeff):
    """
    Function used to update the abatement history dictionary when 2 flows need to be added, based on variables like :
    - the abatement history dictionary (dictionary)
    - another abatement history dictionary, we need to add to the first one (dictionary)
    - a flow coefficient to multiply value of the second history into the first one (double)
    """
    for key in dict_2:
        # If the key already exist in the dictionary, the previous value is added to the one from the second dictionary.
        if key in dict_1:
            dict_1[key] = dict_1[key] + (dict_2[key] - (dict_2[key] * coeff))
        # If the key doesn't exist, only the new value is added to the history dictionary.
        else:
            dict_1[key] = dict_2[key] - (dict_2[key] * coeff)
    return dict_1


def order_feature(parcel_layer, line_layer, start_order, end_order):
    """
    Function used to list all landscape element and order them, based on variables like :
    - the parcel layer (QgsVectorLayer)
    - the line layer (QgsVectorLayer)
    - a value to identify the start of the order (integer)
    - a value to identify the end of the order (integer)
    """
    flow_list = []
    # As long as the starting point is different from the end point, we order the element.
    while start_order != end_order:
        # Element can be either a line or a parcel.
        line_layer.selectByExpression(
            "{field_order} = '{order}' ".format(field_order=field_order, order=start_order))
        parcel_layer.selectByExpression(
            "{field_order} = '{order}' ".format(field_order=field_order, order=start_order))
        # If it's a line, it must have a type, else it is not kept.
        if len(line_layer.selectedFeatureIds()) == 1:
            if line_layer.selectedFeatures()[0].attributes()[line_layer.fields().indexFromName(
                    field_type_line_middle)] != null:
                flow_list.append("line_" + str(line_layer.selectedFeatureIds()[0]))
        if len(parcel_layer.selectedFeatureIds()) == 1:
            flow_list.append('parcel_' + str(parcel_layer.selectedFeatureIds()[0]))
        start_order = start_order + 1
    return flow_list


class FlowCalculation:
    """
    """

    def __init__(self, watershed_name=None, practices=None, slope=None, land_cover=None, abatement_type=None,
                 production_type=None, abatement=None, abatement_water=None, abatement_mes=None, abatement_phyto=None,
                 production=None, production_water=None, production_mes=None, production_phyto=None, line_type=None,
                 abatement_type_long=None, abatement_type_lat=None, abatement_long=None, abatement_long_water=None,
                 abatement_long_mes=None, abatement_long_phyto=None, abatement_lat=None, abatement_lat_water=None,
                 abatement_lat_mes=None, abatement_lat_phyto=None):
        """Class attributes are :
        - """
        super(FlowCalculation, self).__init__()
        self.watershed_name = watershed_name
        self.practices = practices
        self.slope = slope
        self.land_cover = land_cover
        self.abatement_type = abatement_type
        self.abatement = None
        self.abatement_water = abatement_water
        self.abatement_mes = abatement_mes
        self.abatement_phyto = abatement_phyto
        self.production_type = production_type
        self.production = None
        self.production_water = production_water
        self.production_mes = production_mes
        self.production_phyto = production_phyto
        self.line_type = line_type
        self.abatement_type_long = abatement_type_long
        self.abatement_type_lat = abatement_type_lat
        self.abatement_long = None
        self.abatement_long_water = abatement_long_water
        self.abatement_long_mes = abatement_long_mes
        self.abatement_long_phyto = abatement_long_phyto
        self.abatement_lat = None
        self.abatement_lat_water = abatement_lat_water
        self.abatement_lat_mes = abatement_lat_mes
        self.abatement_lat_phyto = abatement_lat_phyto

    def prepare_layers(self, parcel_layer, line_layer):
        line_layer.startEditing()
        line_layer.addAttribute(QgsField(field_incoming_flow, QVariant.Double, "double", 10, 2))
        line_layer.addAttribute(QgsField(field_incoming_flow_from_line, QVariant.Double, "double", 10, 2))
        line_layer.addAttribute(QgsField(field_incoming_flow_from_parcel, QVariant.Double, "double", 10, 2))
        line_layer.addAttribute(QgsField(field_outgoing_flow, QVariant.Double, "double", 10, 2))
        line_layer.addAttribute(QgsField(field_outgoing_flow_long, QVariant.Double, "double", 10, 2))
        line_layer.addAttribute(QgsField(field_outgoing_flow_lat, QVariant.Double, "double", 10, 2))
        line_layer.addAttribute(QgsField(field_outgoing_flow_line_to_parcel, QVariant.Double, "double", 10, 2))
        line_layer.addAttribute(QgsField(field_flow_abatement, QVariant.Double, "double", 10, 2))
        line_layer.addAttribute(QgsField(field_flow_abatement_rating, QVariant.Int, "int", 2))
        line_layer.addAttribute(QgsField(field_incoming_flow_rating, QVariant.Int, "int", 2))
        line_layer.addAttribute(QgsField(field_outgoing_flow_long_up, QVariant.Double, "double", 10, 5))
        line_layer.addAttribute(QgsField(field_outgoing_flow_long_down, QVariant.Double, "double", 10, 5))
        if line_layer.fields().indexFromName(field_history) != -1:
            line_layer.deleteAttribute(line_layer.fields().indexFromName(field_history))
            line_layer.deleteAttribute(line_layer.fields().indexFromName(field_history_abatement))
            line_layer.deleteAttribute(line_layer.fields().indexFromName(field_history_abatement_lat))
            line_layer.deleteAttribute(line_layer.fields().indexFromName(field_history_abatement_lat_water))
            line_layer.deleteAttribute(line_layer.fields().indexFromName(field_history_abatement_lat_mes))
            line_layer.deleteAttribute(line_layer.fields().indexFromName(field_history_abatement_lat_phyto))
            line_layer.deleteAttribute(line_layer.fields().indexFromName(field_history_abatement_long))
            line_layer.deleteAttribute(line_layer.fields().indexFromName(field_history_outflow_long))
            line_layer.deleteAttribute(line_layer.fields().indexFromName(field_history_outflow_long_up))
            line_layer.deleteAttribute(line_layer.fields().indexFromName(field_history_outflow_long_down))
            line_layer.deleteAttribute(line_layer.fields().indexFromName(field_history_abatement_long_up))
            line_layer.deleteAttribute(line_layer.fields().indexFromName(field_history_abatement_long_down))
        line_layer.addAttribute(QgsField(field_history, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_water, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_mes, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_phyto, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_abatement, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_abatement_water, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_abatement_mes, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_abatement_phyto, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_abatement_lat, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_abatement_lat_water, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_abatement_lat_mes, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_abatement_lat_phyto, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_abatement_long, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_abatement_long_water, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_abatement_long_mes, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_abatement_long_phyto, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_outflow_long, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_outflow_long_up, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_outflow_long_down, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_abatement_long_up, QVariant.String, "string", 10000))
        line_layer.addAttribute(QgsField(field_history_abatement_long_down, QVariant.String, "string", 10000))

        for f in line_layer.getFeatures():
            line_layer.changeAttributeValue(
                f.id(), line_layer.fields().indexFromName(field_incoming_flow), 0)
            line_layer.changeAttributeValue(
                f.id(), line_layer.fields().indexFromName(field_incoming_flow_from_line), 0)
            line_layer.changeAttributeValue(
                f.id(), line_layer.fields().indexFromName(field_incoming_flow_from_parcel), 0)
            line_layer.changeAttributeValue(
                f.id(), line_layer.fields().indexFromName(field_outgoing_flow), 0)
            line_layer.changeAttributeValue(
                f.id(), line_layer.fields().indexFromName(field_outgoing_flow_long), 0)
            line_layer.changeAttributeValue(
                f.id(), line_layer.fields().indexFromName(field_outgoing_flow_lat), 0)
            line_layer.changeAttributeValue(
                f.id(), line_layer.fields().indexFromName(field_flow_abatement), 0)
            line_layer.changeAttributeValue(
                f.id(), line_layer.fields().indexFromName(field_flow_abatement_rating), 99)
            line_layer.changeAttributeValue(
                f.id(), line_layer.fields().indexFromName(field_incoming_flow_rating), 99)
            line_layer.changeAttributeValue(
                f.id(), line_layer.fields().indexFromName(field_outgoing_flow_long_up), 0)
            line_layer.changeAttributeValue(
                f.id(), line_layer.fields().indexFromName(field_outgoing_flow_long_down), 0)
        line_layer.commitChanges()
        line_layer.triggerRepaint()

        parcel_layer.startEditing()
        if parcel_layer.fields().indexFromName(field_history) != -1:
            parcel_layer.deleteAttribute(parcel_layer.fields().indexFromName(field_flow_production))
            parcel_layer.deleteAttribute(parcel_layer.fields().indexFromName(field_flow_production_water))
            parcel_layer.deleteAttribute(parcel_layer.fields().indexFromName(field_flow_production_mes))
            parcel_layer.deleteAttribute(parcel_layer.fields().indexFromName(field_flow_production_phyto))
            parcel_layer.deleteAttribute(parcel_layer.fields().indexFromName(field_history))
            parcel_layer.deleteAttribute(parcel_layer.fields().indexFromName(field_history_water))
            parcel_layer.deleteAttribute(parcel_layer.fields().indexFromName(field_history_mes))
            parcel_layer.deleteAttribute(parcel_layer.fields().indexFromName(field_history_phyto))
        parcel_layer.addAttribute(QgsField(field_flow_production, QVariant.Double, "double", 5, 2))
        parcel_layer.addAttribute(QgsField(field_flow_production_water, QVariant.Double, "double", 5, 2))
        parcel_layer.addAttribute(QgsField(field_flow_production_mes, QVariant.Double, "double", 5, 2))
        parcel_layer.addAttribute(QgsField(field_flow_production_phyto, QVariant.Double, "double", 5, 2))
        parcel_layer.addAttribute(QgsField(field_incoming_flow, QVariant.Double, "double", 5, 2))
        parcel_layer.addAttribute(QgsField(field_outgoing_flow, QVariant.Double, "double", 5, 2))
        parcel_layer.addAttribute(QgsField(field_parcel_outflow_drain, QVariant.Double, "double", 5, 2))
        parcel_layer.addAttribute(QgsField(field_flow_abatement, QVariant.Double, "double", 5, 2))
        parcel_layer.addAttribute(
            QgsField(field_parcel_above, QVariant.String, "string", 100))
        parcel_layer.addAttribute(QgsField(field_parcel_below, QVariant.String, "string", 100))
        parcel_layer.addAttribute(QgsField(field_history, QVariant.String, "string", 10000))
        parcel_layer.addAttribute(QgsField(field_history_water, QVariant.String, "string", 10000))
        parcel_layer.addAttribute(QgsField(field_history_mes, QVariant.String, "string", 10000))
        parcel_layer.addAttribute(QgsField(field_history_phyto, QVariant.String, "string", 10000))
        parcel_layer.deleteAttribute(parcel_layer.fields().indexFromName(field_history_abatement))
        parcel_layer.addAttribute(QgsField(field_history_abatement, QVariant.String, "string", 10000))
        parcel_layer.addAttribute(QgsField(field_history_abatement_water, QVariant.String, "string", 10000))
        parcel_layer.addAttribute(QgsField(field_history_abatement_mes, QVariant.String, "string", 10000))
        parcel_layer.addAttribute(QgsField(field_history_abatement_phyto, QVariant.String, "string", 10000))
        parcel_layer.addAttribute(QgsField(field_flow_river_rate, QVariant.Double, "double", 10, 5))
        parcel_layer.addAttribute(QgsField(field_flow_production_area_river, QVariant.Double, "double", 10, 5))
        parcel_layer.addAttribute(QgsField(field_flow_production_area, QVariant.Double, "double", 10, 5))
        for f in parcel_layer.getFeatures():
            attrs = f.attributes()
            parcel_type = attrs[parcel_layer.fields().indexFromName(field_type_parcel)]
            area = attrs[parcel_layer.fields().indexFromName(field_parcel_area)]
            slope = attrs[parcel_layer.fields().indexFromName(field_parcel_slope)]
            label = attrs[parcel_layer.fields().indexFromName(field_parcel_practice)]
            if parcel_type in self.production_type:
                prod = parcel_inflow_production(parcel_type, label, slope, area, self.slope,
                                                self.production)
                prod_water = parcel_inflow_production(parcel_type, label, slope, area, self.slope,
                                                      self.production_water)
                prod_mes = parcel_inflow_production(parcel_type, label, slope, area, self.slope,
                                                    self.production_mes)
                prod_phyto = parcel_inflow_production(parcel_type, label, slope, area, self.slope,
                                                      self.production_phyto)
            else:
                prod = 0
                prod_water = 0
                prod_mes = 0
                prod_phyto = 0
            parcel_layer.changeAttributeValue(f.id(), parcel_layer.fields().indexFromName(
                field_incoming_flow), 0)
            parcel_layer.changeAttributeValue(f.id(), parcel_layer.fields().indexFromName(
                field_outgoing_flow), 0)
            parcel_layer.changeAttributeValue(f.id(), parcel_layer.fields().indexFromName(
                field_parcel_outflow_drain), 0)
            parcel_layer.changeAttributeValue(f.id(), parcel_layer.fields().indexFromName(field_flow_production), prod)
            parcel_layer.changeAttributeValue(f.id(), parcel_layer.fields().indexFromName(field_flow_production_water),
                                              prod_water)
            parcel_layer.changeAttributeValue(f.id(), parcel_layer.fields().indexFromName(field_flow_production_mes),
                                              prod_mes)
            parcel_layer.changeAttributeValue(f.id(), parcel_layer.fields().indexFromName(field_flow_production_phyto),
                                              prod_phyto)
        parcel_layer.commitChanges()
        parcel_layer.triggerRepaint()

    def line_analysis(self, line_layer, parcel_layer, connexion_layer, line_id, history_field,
                      history_abatement_field):
        line = line_layer.getFeature(line_id)
        attrs = line.attributes()
        line_type = attrs[line_layer.fields().indexFromName(field_type_line_middle)]
        line_length = attrs[line_layer.fields().indexFromName(field_line_length)]
        if line_layer.fields().indexFromName(field_parcel_active_drain) == -1:
            active_drain = 0
        else:
            active_drain = attrs[line_layer.fields().indexFromName(field_parcel_active_drain)]

        top_parcel_outflow, top_parcel_history, top_parcel_abat_history = self.get_inflow_from_parcel(
            line, line_type, line_layer, parcel_layer, connexion_layer, history_field, history_abatement_field)

        # The linear with river type and linear which can impact water flow lengthwise can both have inflow
        # from linear above.
        top_line_outflow, top_line_history_long, top_line_abat_history = self.get_inflow_from_line(line, line_type,
                                                                                                   line_layer)
        inflow = top_line_outflow + top_parcel_outflow
        outflow_long, outflow_lateral, total_abatement, top_parcel_history, top_line_history_long, history_abat_long, \
        top_line_abat_history_lat, top_parcel_abat_history = self.line_abatement(line, line_type, line_id,
                                                                                 line_layer, top_parcel_outflow,
                                                                                 top_line_outflow,
                                                                                 top_parcel_history,
                                                                                 top_parcel_abat_history,
                                                                                 top_line_history_long)
        line_outlet = self.get_outflow_direction(line, line_type, line_layer)
        outflow = inflow - total_abatement  # The outflow equal the inflow minus the absorbed flow.
        if line_type == drain and active_drain == 1:
            inflow, top_line_history_long, history_abat_long, drain_type = self.get_drain_values(
                line, parcel_layer, history_field, history_abatement_field)
            abatement_coefficient = coefficient_abatement_longitudinal_TE(drain, line_length,
                                                                          self.abatement_long)
            total_abatement = inflow * abatement_coefficient
            if drain_type == 3:
                outflow_lateral = inflow - total_abatement
                outflow_long = 0
                top_parcel_history = top_line_history_long
                top_line_history_long = ''
            else:
                outflow_lateral = 0
                outflow_long = inflow - total_abatement
                top_parcel_history = ''
            outflow = outflow_lateral + outflow_long
        inflow, outflow, outflow_long, outflow_long_up, outflow_long_down, outflow_lateral, top_line_outflow, \
        top_parcel_outflow, total_abatement, top_parcel_history, abatement_history, history_long_up, \
        history_long_up_abat, history_long_dwn, history_long_dwn_abat = self.river_process(line, line_type,
                                                                                           line_layer, parcel_layer,
                                                                                           connexion_layer, outflow,
                                                                                           outflow_long,
                                                                                           outflow_lateral,
                                                                                           top_line_outflow,
                                                                                           top_parcel_outflow,
                                                                                           total_abatement, inflow,
                                                                                           top_parcel_history,
                                                                                           history_field,
                                                                                           history_abatement_field)

        history_abat_long = update_flow_history(history_abat_long, top_line_abat_history, 1)
        new_attributes = {field_incoming_flow: inflow, field_incoming_flow_from_line: top_line_outflow,
                          field_incoming_flow_from_parcel: top_parcel_outflow, field_outgoing_flow: outflow,
                          field_outgoing_flow_long: outflow_long, field_outgoing_flow_lat: outflow_lateral,
                          field_flow_abatement: total_abatement, field_outgoing_flow_line_to_parcel: line_outlet,
                          field_outgoing_flow_long_up: outflow_long_up,
                          field_outgoing_flow_long_down: outflow_long_down, history_field: top_parcel_history,
                          field_history_outflow_long: top_line_history_long,
                          field_history_outflow_long_up: history_long_up,
                          field_history_outflow_long_down: history_long_dwn,
                          history_abatement_field: abatement_history, field_history_abatement_long: history_abat_long,
                          field_history_abatement_lat: top_line_abat_history_lat,
                          field_history_abatement_long_up: history_long_up_abat,
                          field_history_abatement_long_down: history_long_dwn_abat}
        self.save_attributes(line_layer, line.id(), new_attributes)

    def get_inflow_from_parcel(self, line, line_type, line_layer, parcel_layer, connexion_layer, history_field,
                               history_abatement_field):
        top_parcel_outflow = 0
        top_parcel_history = {}
        top_parcel_abat_history = {}
        if line_type != river and line_type != drain:
            attrs = line.attributes()
            uh_dwn = attrs[line_layer.fields().indexFromName(field_line_parcel_below)]
            uh_up = attrs[line_layer.fields().indexFromName(field_line_parcel_above)]
            dict_history = {}
            dict_history_abat = {}
            # From the connexion_layer we can get the coefficient of flow between the two parcels and th id of the
            # parcel above.
            select_connect_up = QgsExpression(
                "{field_line_parcel_below} = '{uh_dwn}' and {field_line_parcel_above} = '{uh_up}'".format(
                    field_line_parcel_below=field_line_parcel_below, field_line_parcel_above=field_line_parcel_above,
                    uh_dwn=uh_dwn, uh_up=uh_up))
            for connexion in connexion_layer.getFeatures(QgsFeatureRequest(select_connect_up)):
                attrs = connexion.attributes()
                uh_up = attrs[connexion_layer.fields().indexFromName(field_connexions_parcel_above)]
                flow_coefficient = attrs[connexion_layer.fields().indexFromName(field_connexions_flow_coefficient)]
                # From the parcel_layer we can get the outflow from the parcel above.
                select_uh_up = QgsExpression(" {field_parcel_id} = '{id}'".format(
                    field_parcel_id=field_parcel_id, id=uh_up))
                for parcel in parcel_layer.getFeatures(QgsFeatureRequest(select_uh_up)):
                    attrs = parcel.attributes()
                    parcel_outflow = attrs[parcel_layer.fields().indexFromName(field_outgoing_flow)]
                    type_drain = attrs[parcel_layer.fields().indexFromName(field_parcel_drain_type)]
                    active_drain = attrs[parcel_layer.fields().indexFromName(field_parcel_active_drain)]
                    if active_drain == 1 and (type_drain == 2 or type_drain == 3):
                        coef = 0.2
                    else:
                        coef = 1
                    if attrs[parcel_layer.fields().indexFromName(history_field)] != NULL:
                        flow_history = (attrs[parcel_layer.fields().indexFromName(history_field)]).split("; ")
                        if flow_history[0] != '':
                            for elem in flow_history:
                                dict_history[elem.split(": ")[0]] = float(elem.split(": ")[1])
                    if attrs[parcel_layer.fields().indexFromName(history_abatement_field)] != NULL:
                        flow_history = (attrs[parcel_layer.fields().indexFromName(history_abatement_field)]).split("; ")
                        if flow_history[0] != '':
                            for elem in flow_history:
                                dict_history_abat[elem.split(": ")[0]] = float(elem.split(": ")[1])
                    dict_history = update_flow_history({}, dict_history, coef)
                    # River linear can have multiple inflow from parcels, we need to ad them to get the total of inflow
                    # from all parcels.
                    top_parcel_outflow = top_parcel_outflow + flow_coefficient * parcel_outflow
                    top_parcel_history = update_flow_history(top_parcel_history, dict_history, flow_coefficient)
                    top_parcel_abat_history = update_flow_history(top_parcel_abat_history,
                                                                  dict_history_abat,
                                                                  flow_coefficient)
        return top_parcel_outflow, top_parcel_history, top_parcel_abat_history

    def get_inflow_from_line(self, line, line_type, line_layer):
        attrs = line.attributes()
        above_line_type = attrs[line_layer.fields().indexFromName(field_type_line_top)]
        below_line_type = attrs[line_layer.fields().indexFromName(field_type_line_bottom)]
        top_line_outflow = 0
        history_long = {}
        history_abat_line_up = {}
        if (above_line_type in self.abatement_type_long or line_type in self.abatement_type_long
            or below_line_type in self.abatement_type_long) \
                and line_type != drain and line_type != river:
            line_slope = attrs[line_layer.fields().indexFromName(field_line_slope)]
            lines_up = attrs[line_layer.fields().indexFromName(field_line_line_above)]
            list_lines_up = list(str(lines_up).split(", "))
            for te_up in list_lines_up:
                dict_history = {}
                dict_history_abat_line_up = {}
                if te_up != 'NULL':
                    outflow_long_line_up = 0
                    coefficient = 0
                    select_te_up = QgsExpression(
                        "{field_line_id} = '{id}' and {field_type_line} != 0 and {field_type_line} != {river}".format(
                            field_line_id=field_line_id, id=te_up, field_type_line=field_type_line_middle, river=river))
                    # Selection of linears above the processed linear.
                    for line_up in line_layer.getFeatures(QgsFeatureRequest(select_te_up)):
                        attrs = line_up.attributes()
                        outflow_long_line_up = attrs[line_layer.fields().indexFromName(field_outgoing_flow_long)]
                        type_line_up = attrs[line_layer.fields().indexFromName(field_type_line_middle)]
                        type_line_up_above = attrs[line_layer.fields().indexFromName(field_type_line_top)]
                        type_line_up_below = attrs[line_layer.fields().indexFromName(field_type_line_bottom)]
                        if attrs[line_layer.fields().indexFromName(field_history_outflow_long)] != NULL:
                            flow_history = (attrs[line_layer.fields().indexFromName(
                                field_history_outflow_long)]).split("; ")
                            if flow_history[0] != '':
                                for elem in flow_history:
                                    dict_history[elem.split(": ")[0]] = float(elem.split(": ")[1])
                        if attrs[line_layer.fields().indexFromName(field_history_abatement_long)] != NULL:
                            flow_history = (attrs[line_layer.fields().indexFromName(
                                field_history_abatement_long)]).split("; ")
                            if flow_history[0] != '':
                                for elem in flow_history:
                                    dict_history_abat_line_up[elem.split(": ")[0]] = float(elem.split(": ")[1])
                        lines_down = attrs[line_layer.fields().indexFromName(field_line_line_below)]
                        list_id_dwn = list(str(lines_down).split(", "))
                        if (type_line_up_above in self.abatement_type_long or type_line_up in self.abatement_type_long
                                or type_line_up_below in self.abatement_type_long):
                            total_downward_slope = 0
                            # If the linear above have multiple linears down, we need to know how much of outflow is
                            # going to wich linear.
                            if len(list_id_dwn) > 1:
                                for te_dwn in list_id_dwn:
                                    select_te_dwn = QgsExpression("{field_line_id} = '{id}' ".format(
                                        field_line_id=field_line_id, id=te_dwn))
                                    # We are creating a coefficient on the slope of each linear below.
                                    for line_down in line_layer.getFeatures(QgsFeatureRequest(
                                            select_te_dwn)):
                                        attrs = line_down.attributes()
                                        type_line_dwn = attrs[line_layer.fields().indexFromName(field_type_line_middle)]
                                        type_line_down_above = attrs[line_layer.fields().indexFromName(
                                            field_type_line_top)]
                                        type_line_down_below = attrs[line_layer.fields().indexFromName(
                                            field_type_line_bottom)]
                                        line_down_slope = attrs[line_layer.fields().indexFromName(field_line_slope)]
                                        type_list = [type_line_down_above, type_line_dwn, type_line_down_below]
                                        if any(item in type_list for item in self.abatement_type_long):
                                            total_downward_slope = total_downward_slope + line_down_slope
                                        else:
                                            total_downward_slope = total_downward_slope + 0
                                    if total_downward_slope == 0:
                                        coefficient = 0
                                    else:
                                        coefficient = line_slope / total_downward_slope
                            elif len(list_id_dwn) == 1:
                                coefficient = 1  # If there is only one linear below it gets 100% of the outflow
                        elif type_line_up == river:
                            coefficient = 0
                    top_line_outflow = top_line_outflow + outflow_long_line_up * coefficient
                    history_abat_line_up = update_flow_history(history_abat_line_up, dict_history_abat_line_up,
                                                               coefficient)
                    history_long = update_flow_history(history_long, dict_history, coefficient)
        return top_line_outflow, history_long, history_abat_line_up

    def line_abatement(self, line, line_type, line_id, line_layer, top_parcel_outflow, top_line_outflow,
                       top_parcel_history, top_parcel_abat_history, history_long):
        sortant_long = 0
        sortant_lat_up = 0
        abattement_total = 0
        history_abat_lat = {}
        history_abat_long = {}
        history_long_total = {}
        if line_type != river and line_type != drain:
            attrs = line.attributes()
            type_line_amont = attrs[line_layer.fields().indexFromName(field_type_line_top)]
            type_line = attrs[line_layer.fields().indexFromName(field_type_line_middle)]
            type_line_aval = attrs[line_layer.fields().indexFromName(field_type_line_bottom)]
            elements = [type_line_amont, type_line, type_line_aval]
            line_length = attrs[line_layer.fields().indexFromName(field_line_length)]
            slope_angle = attrs[line_layer.fields().indexFromName(field_line_slope_angle)]
            sortant_lat_up = top_parcel_outflow
            for elem in elements:
                history_long_elem = {}
                sortant_lat_up, sortant_long, abattement_total, top_parcel_history, history_long_elem, \
                history_abat_long, history_abat_lat, top_parcel_abat_history = self.element_abatement(
                    elements, sortant_long, sortant_lat_up, top_line_outflow, abattement_total,
                    top_parcel_history, history_long, history_long_elem, history_abat_long, history_abat_lat,
                    top_parcel_abat_history, line_length, slope_angle, line_id, elements.index(elem))
                history_long_total = update_flow_history(history_long_total, history_long_elem, 1)
        return sortant_long, sortant_lat_up, abattement_total, top_parcel_history, history_long_total, \
               history_abat_long, history_abat_lat, top_parcel_abat_history

    def element_abatement(self, elements, sortant_long, sortant_lat_up, top_line_outflow, abattement_total,
                          top_parcel_history, history_long, history_long_elem, history_abat_long, history_abat_lat,
                          top_parcel_abat_history, longueur_lineaire, sin_incli, line_id, index):
        element_type = elements[index]
        i = 0
        flow = 0
        sortant_lat = sortant_lat_up
        while i != index:
            if elements[i] in self.abatement_type_lat or elements[i] == null:
                flow = flow + 1
            i = i + 1
        if flow == index:
            if element_type in self.abatement_type_long:
                # Depending on the type and length of the linear we need to know how much of the inflow is absorbed by
                # the linear.
                coeff_abatt = coefficient_abatement_longitudinal_TE(element_type, longueur_lineaire,
                                                                    self.abatement_long)
                if element_type not in self.abatement_type_lat:
                    if (index == 0 and elements[1] not in self.abatement_type_long) or index == 1:
                        entrant_long = sortant_lat_up + top_line_outflow
                    else:
                        entrant_long = sortant_lat_up
                    abattement = entrant_long * coeff_abatt
                    for elem in history_long:
                        history_long_elem[elem] = history_long[elem] - (history_long[elem] * coeff_abatt)
                    history_long_elem = update_flow_history_abat(history_long_elem, top_parcel_history,
                                                                 coeff_abatt)
                    top_parcel_history = {}
                    # If the absorbed value is bigger than the inflow, we said it's equal to the inflow value.
                    if abattement > entrant_long:
                        print("Error, abatement long bigger than inflow, top line of the linear :" + str(line_id))
                        abattement = entrant_long
                    if "line_" + str(line_id) in history_abat_long:
                        history_abat_long["line_" + str(line_id)] = history_abat_long[
                                                                        "line_" + str(line_id)] + abattement
                    else:
                        history_abat_long["line_" + str(line_id)] = abattement
                    history_abat_long = update_flow_history(history_abat_long, top_parcel_abat_history, 1)
                    history_abat_long = update_flow_history(history_abat_long, history_abat_lat, 1)
                    history_abat_lat = {}
                    sortant_long = sortant_long + entrant_long - abattement
                    abattement_total = abattement_total + abattement
                    sortant_lat = 0
                # If the line also do a lateral abatement the flow needs to be shared between the longitudinal and
                # lateral outflow. A different abatement is realized depending on the way of the flow.
                else:
                    coeff_long = 1 - sin_incli
                    if (index == 0 and elements[1] not in self.abatement_type_long) or index == 1:
                        entrant_long = (coeff_long * sortant_lat_up) + top_line_outflow
                        history_long_elem = update_flow_history(history_long, top_parcel_history, coeff_long)
                        for elem in history_long_elem:
                            history_long_elem[elem] = history_long_elem[elem] - (history_long_elem[elem] * coeff_abatt)
                    else:
                        entrant_long = coeff_long * sortant_lat_up
                        history_long_elem = update_flow_history(history_long_elem, top_parcel_history, coeff_long)
                        for elem in history_long_elem:
                            history_long_elem[elem] = history_long_elem[elem] - (history_long_elem[elem] * coeff_abatt)
                    for elem in top_parcel_history:
                        top_parcel_history[elem] = top_parcel_history[elem] - (
                                top_parcel_history[elem] * coeff_long)
                    abattement = entrant_long * coeff_abatt
                    if abattement > entrant_long:
                        print("Error, abatement long bigger than inflow, bottom line of the linear :" + str(line_id))
                        abattement = entrant_long
                    if "line_" + str(line_id) in history_abat_long.keys():
                        for elem in history_abat_long:
                            if elem == "line_" + str(line_id):
                                history_abat_long[elem] = history_abat_long[elem] + abattement
                    else:
                        history_abat_long["line_" + str(line_id)] = abattement

                    sortant_long = sortant_long + entrant_long - abattement
                    abattement_total = abattement_total + abattement
                    # Depending on the type and length of the linear we need to know how much of the inflow is absorbed
                    # by the linear.
                    coeff_abatt = coefficient_abatement_lateral_TE(element_type, self.abatement_lat)
                    abattement = (sin_incli * sortant_lat_up) * coeff_abatt
                    for elem in top_parcel_history:
                        top_parcel_history[elem] = top_parcel_history[elem] - (top_parcel_history[elem] * coeff_abatt)
                    if abattement > (sin_incli * sortant_lat_up):
                        print("Error, abatement lat bigger than inflow, middle line of the linear :" + str(line_id))
                        abattement = (sin_incli * sortant_lat_up)
                    if "line_" + str(line_id) in history_abat_lat.keys():
                        for elem in history_abat_lat:
                            if elem == "line_" + str(line_id):
                                history_abat_lat[elem] = history_abat_lat[elem] + abattement
                    else:
                        history_abat_lat["line_" + str(line_id)] = abattement
                    history_abat_lat = update_flow_history(history_abat_lat, top_parcel_abat_history,
                                                           (0.80 * sin_incli))
                    for elem in top_parcel_abat_history:
                        top_parcel_abat_history[elem] = (top_parcel_abat_history[elem] * (0.80 * sin_incli)) - (
                                top_parcel_abat_history[elem] * coeff_abatt)
                    sortant_lat = (sin_incli * sortant_lat_up) - abattement
                    abattement_total = abattement_total + abattement
            elif element_type in self.abatement_type_lat:
                # Depending on the type and length of the linear we need to know how much of the inflow is absorbed by
                # the linear.
                coeff_abatt = coefficient_abatement_lateral_TE(element_type, self.abatement_lat)
                abattement = sortant_lat_up * coeff_abatt
                if abattement > (sin_incli * sortant_lat_up):
                    # If the absorbed value is bigger than the inflow, we said it's equal to the inflow value.
                    print("Error, abatement lat bigger than inflow, top line of the linear :" + str(line_id))
                    abattement = (sin_incli * sortant_lat_up)
                if "line_" + str(line_id) in history_abat_lat:
                    history_abat_lat["line_" + str(line_id)] = history_abat_lat["line_" + str(line_id)] + abattement
                else:
                    history_abat_lat["line_" + str(line_id)] = abattement
                history_abat_lat = update_flow_history(history_abat_lat, top_parcel_abat_history, 1)
                for elem in top_parcel_abat_history:
                    top_parcel_abat_history[elem] = top_parcel_abat_history[elem] - top_parcel_abat_history[
                        elem] * coeff_abatt
                sortant_lat = (sin_incli * sortant_lat_up) - abattement
                abattement_total = abattement_total + abattement
        return sortant_lat, sortant_long, abattement_total, top_parcel_history, history_long_elem, history_abat_long, \
               history_abat_lat, top_parcel_abat_history

    def get_outflow_direction(self, line, line_type, line_layer):
        if line_type != river:
            attrs = line.attributes()
            outflow_direction = attrs[line_layer.fields().indexFromName(field_line_outflow_direction)]
            te_dwn = attrs[line_layer.fields().indexFromName(field_line_line_below)]
            list_id_dwn_f = list(str(te_dwn).split(", "))
            parcelle_out_dwn = 0
            for te_dwn in list_id_dwn_f:  # We have to know where the outflow of the linear is going.
                if te_dwn == 'NULL':  # If there is no linear below, the outflow is going to the parcel below.
                    parcelle_out_dwn = 0
                else:
                    select_te_dwn = QgsExpression("{champ_identifiant_ligne} = '{id}' ".format(
                        champ_identifiant_ligne=field_line_id, id=int(te_dwn)))
                    for feat in line_layer.getFeatures(QgsFeatureRequest(select_te_dwn)):
                        attrs = feat.attributes()
                        type_line_dwn = attrs[line_layer.fields().indexFromName(field_type_line_middle)]
                        type_line_down_above = attrs[
                            line_layer.fields().indexFromName(field_type_line_top)]
                        type_line_down_below = attrs[
                            line_layer.fields().indexFromName(field_type_line_bottom)]
                        if ((((type_line_dwn not in self.abatement_type_long)
                              and (type_line_down_above not in self.abatement_type_long)
                              and (type_line_down_below not in self.abatement_type_long))
                             and type_line_dwn != river)
                                or type_line_dwn == null):
                            parcelle_out_dwn = parcelle_out_dwn + 0
                        else:
                            parcelle_out_dwn = parcelle_out_dwn + 1
            # if every linear below have no type or only have lateral impact, parcelle_out_dwn = 0 and the outflow is
            # going to the parcel below
            if parcelle_out_dwn == 0:
                parcelle_out_dwn = outflow_direction
            else:
                parcelle_out_dwn = NULL
        else:  # River linear doesn't absorbe water flow.
            parcelle_out_dwn = NULL
        return parcelle_out_dwn

    def get_drain_values(self, line, parcel_layer, history_field, history_abatement_field):
        select_drained_uh = QgsExpression("{drain_id} = '{id}'".format(drain_id=field_parcel_drain_id, id=line.id()))
        inflow_drain = 0
        history_up = {}
        history_abat_up = {}
        for uh in parcel_layer.getFeatures(QgsFeatureRequest(select_drained_uh)):
            attrs = uh.attributes()
            drain_type = attrs[parcel_layer.fields().indexFromName(field_parcel_drain_type)]
            if drain_type == 1:
                coef = 0.20
            else:
                coef = 0.80
            uh_outflow_drain = attrs[parcel_layer.fields().indexFromName(field_parcel_outflow_drain)]
            dict_history = {}
            if attrs[parcel_layer.fields().indexFromName(history_field)] != NULL:
                flow_history = (attrs[parcel_layer.fields().indexFromName(history_field)]).split("; ")
                if flow_history[0] != '':
                    for elem in flow_history:
                        dict_history[elem.split(": ")[0]] = float(elem.split(": ")[1])
            dict_history_abat = {}
            if attrs[parcel_layer.fields().indexFromName(history_abatement_field)] != NULL:
                flow_history = (attrs[parcel_layer.fields().indexFromName(history_abatement_field)]).split("; ")
                if flow_history[0] != '':
                    for elem in flow_history:
                        dict_history_abat[elem.split(": ")[0]] = float(elem.split(": ")[1])
            inflow_drain = inflow_drain + uh_outflow_drain
            history_up = update_flow_history(history_up, dict_history, coef)
            history_abat_up = update_flow_history(history_abat_up, dict_history_abat, coef)
        return inflow_drain, history_up, history_abat_up, drain_type

    def river_process(self, river_feature, line_type, line_layer, parcel_layer, connexion_layer, sortant, sortant_long,
                      sortant_lat, entrant_line, entrant_parcel, abattement_total, entrant, history, history_field,
                      history_abatement_field):
        entrant_up = 0
        entrant_dwn = 0
        history_abat = {}
        history_long_up = {}
        history_long_abat_up = {}
        history_long_dwn = {}
        history_long_abat_dwn = {}
        outflow_long_up = 0
        outflow_long_down = 0
        if line_type == river:
            attrs = river_feature.attributes()
            longueur_lineaire = attrs[line_layer.fields().indexFromName(field_line_length)]
            type_up = attrs[line_layer.fields().indexFromName(field_type_line_top)]
            type_dwn = attrs[line_layer.fields().indexFromName(field_type_line_bottom)]
            direction_river = attrs[line_layer.fields().indexFromName(field_river_direction)]
            angle_up = attrs[line_layer.fields().indexFromName(field_river_slope_angle_up)]
            angle_dwn = attrs[line_layer.fields().indexFromName(field_river_slope_angle_dwn)]
            uh_up = attrs[line_layer.fields().indexFromName(field_line_parcel_above)]
            coef_minus_up = 1
            coef_minus_dwn = 1
            if self.watershed_name == "morcille" or self.watershed_name == "emilie":
                if type_up == 800:
                    coef_minus_up = 0.5
                if type_dwn == 800:
                    coef_minus_dwn = 0.5
            history_up = {}
            history_dwn = {}
            history_abat_up = {}
            history_abat_dwn = {}
            select_connect_up = QgsExpression(
                "{field_connexions_river_below} = '{id}'".format(
                    field_connexions_river_below=field_connexions_river_below, id=river_feature.id()))
            for connexion in connexion_layer.getFeatures(QgsFeatureRequest(select_connect_up)):
                attrs = connexion.attributes()
                uh_up_connex = attrs[connexion_layer.fields().indexFromName(field_connexions_parcel_above)]
                flow_coefficient = attrs[connexion_layer.fields().indexFromName(field_connexions_flow_coefficient)]
                select_uh_up = QgsExpression(
                    "{field_parcel_id} = '{id}' ".format(field_parcel_id=field_parcel_id, id=uh_up_connex))
                for parcel in parcel_layer.getFeatures(QgsFeatureRequest(select_uh_up)):
                    attrs = parcel.attributes()
                    sortant = attrs[parcel_layer.fields().indexFromName(field_outgoing_flow)]
                    dict_history = {}
                    dict_history_abat = {}
                    if attrs[parcel_layer.fields().indexFromName(history_field)] != NULL:
                        flow_history = (attrs[parcel_layer.fields().indexFromName(history_field)]).split("; ")
                        if flow_history[0] != '':
                            for elem in flow_history:
                                dict_history[elem.split(": ")[0]] = float(elem.split(": ")[1])
                    if attrs[parcel_layer.fields().indexFromName(history_abatement_field)] != NULL:
                        flow_history_abat = (attrs[parcel_layer.fields().indexFromName(history_abatement_field)]).split(
                            "; ")
                        if flow_history_abat[0] != '':
                            for elem in flow_history_abat:
                                dict_history_abat[elem.split(": ")[0]] = float(elem.split(": ")[1])
                    if uh_up_connex == uh_up:
                        history_up = update_flow_history(history_up, dict_history, flow_coefficient)
                        history_abat_up = update_flow_history(history_abat_up, dict_history_abat, flow_coefficient)
                        entrant_up = sortant * flow_coefficient
                    else:
                        history_dwn = update_flow_history(history_dwn, dict_history, flow_coefficient)
                        history_abat_dwn = update_flow_history(history_abat_dwn, dict_history_abat, flow_coefficient)
                        entrant_dwn = sortant * flow_coefficient
            entrant = 0
            entrant_long_up = 0
            entrant_long_dwn = 0
            abattement_lat_up = 0
            abattement_lat_dwn = 0
            history = {}
            history_long_up_up = {}
            history_long_up_dwn = {}
            history_long_abat = {}
            history_long_abat_up = {}
            history_long_abat_dwn = {}
            history_lat_up = {}
            history_lat_abat_up = {}
            history_lat_dwn = {}
            history_lat_abat_dwn = {}
            history_long_abat_river_up = {}
            history_long_abat_river_dwn = {}
            list_up = []
            list_dwn = []
            river_up_dif = None
            list_id_up_f = list(str(direction_river).split(", "))
            if list_id_up_f[0] != 'NULL':
                for elem in list_id_up_f:
                    elem = list(str(elem).split(":"))
                    if elem[1] == river_direction_up:
                        list_up.append(int(elem[0]))
                    elif elem[1] == river_direction_dwn:
                        list_dwn.append(int(elem[0]))
                    elif elem[1] == river_direction_different_direction:
                        river_up_dif = int(elem[0])
                for elem in list_id_up_f:
                    te_up = list(str(elem).split(":"))
                    select_te_up = QgsExpression(
                        "{field_line_id} = '{id}' and {field_line_type} != 0".format(
                            field_line_id=field_line_id, id=int(te_up[0]), field_line_type=field_type_line_middle))
                    for line_up in line_layer.getFeatures(QgsFeatureRequest(select_te_up)):
                        history_long = {}
                        attrs = line_up.attributes()
                        type_middle = attrs[line_layer.fields().indexFromName(field_type_line_middle)]
                        # From regular linear
                        sort_long = attrs[line_layer.fields().indexFromName(field_outgoing_flow_long)]
                        long = attrs[line_layer.fields().indexFromName(field_history_outflow_long)]
                        if long != NULL and long != '' and type_middle != river:
                            flow_history = long.split("; ")
                            for elem in flow_history:
                                history_long[elem.split(": ")[0]] = float(elem.split(": ")[1])

                        abat_long = attrs[line_layer.fields().indexFromName(field_history_abatement_long)]
                        if abat_long != NULL and abat_long != '':
                            flow_history = abat_long.split("; ")
                            for elem in flow_history:
                                history_long_abat[elem.split(": ")[0]] = float(elem.split(": ")[1])
                        # From river linear
                        sort_long_up = line_up[field_outgoing_flow_long_up]
                        sort_long_dwn = line_up[field_outgoing_flow_long_down]
                        long_up = attrs[line_layer.fields().indexFromName(field_history_outflow_long_up)]
                        if long_up != NULL and long_up != '':
                            flow_history = long_up.split("; ")
                            for elem in flow_history:
                                history_long_up_up[elem.split(": ")[0]] = float(elem.split(": ")[1])

                        long_dw = attrs[line_layer.fields().indexFromName(field_history_outflow_long_down)]
                        if long_dw != NULL and long_dw != '':
                            flow_history = long_dw.split("; ")
                            for elem in flow_history:
                                history_long_up_dwn[elem.split(": ")[0]] = float(elem.split(": ")[1])

                        long_abat_river_up = attrs[line_layer.fields().indexFromName(field_history_abatement_long_up)]
                        if long_abat_river_up != NULL and long_abat_river_up != '':
                            flow_history = long_abat_river_up.split("; ")
                            for elem in flow_history:
                                history_long_abat_river_up[elem.split(": ")[0]] = float(elem.split(": ")[1])
                        long_abat_river_dwn = attrs[
                            line_layer.fields().indexFromName(field_history_abatement_long_down)]
                        if long_abat_river_dwn != NULL and long_abat_river_dwn != '':
                            flow_history = long_abat_river_dwn.split("; ")
                            for elem in flow_history:
                                history_long_abat_river_dwn[elem.split(": ")[0]] = float(elem.split(": ")[1])
                        if line_up.id() in list_up:
                            if sort_long != 0:
                                entrant_long_up = entrant_long_up + sort_long
                                history_long_up = update_flow_history(history_long_up, history_long, 1)
                                history_long_abat_up = update_flow_history(history_long_abat_up, history_long_abat, 1)
                        elif line_up.id() in list_dwn:
                            if sort_long != 0:
                                entrant_long_dwn = entrant_long_dwn + sort_long
                                history_long_dwn = update_flow_history(history_long_dwn, history_long, 1)
                                history_long_abat_dwn = update_flow_history(history_long_abat_dwn,
                                                                            history_long_abat, 1)
                        elif line_up.id() == river_up_dif:
                            entrant_long_up = entrant_long_up + sort_long_dwn
                            entrant_long_dwn = entrant_long_dwn + sort_long_up
                            history_long_up = update_flow_history(history_long_up, history_long_up_dwn, 1)
                            history_long_dwn = update_flow_history(history_long_dwn, history_long_up_up, 1)
                            history_long_abat_up = update_flow_history(history_long_abat_up,
                                                                       history_long_abat_river_dwn, 1)
                            history_long_abat_dwn = update_flow_history(history_long_abat_dwn,
                                                                        history_long_abat_river_up, 1)
                        else:
                            entrant_long_up = entrant_long_up + sort_long_up
                            entrant_long_dwn = entrant_long_dwn + sort_long_dwn
                            history_long_up = update_flow_history(history_long_up, history_long_up_up, 1)
                            history_long_dwn = update_flow_history(history_long_dwn, history_long_up_dwn, 1)
                            history_long_abat_dwn = update_flow_history(history_long_abat_dwn,
                                                                        history_long_abat_river_dwn, 1)
                            history_long_abat_up = update_flow_history(history_long_abat_up,
                                                                       history_long_abat_river_up, 1)
            if type_up in self.abatement_type_long:
                coeff_abatt = coefficient_abatement_longitudinal_TE(type_up, longueur_lineaire,
                                                                    self.abatement_long)
                coeff_abatt = coeff_abatt * coef_minus_up
                if type_up not in self.abatement_type_lat:
                    entrant_long_up = entrant_up + entrant_long_up
                    history_long_up = update_flow_history(history_long_up, history_up, 1)
                    history_long_abat_up = update_flow_history(history_long_abat_up, history_abat_up, 1)
                    for elem in history_long_up:
                        history_long_up[elem] = history_long_up[elem] - history_long_up[elem] * coeff_abatt
                    outflow_long_up = (entrant_long_up - (entrant_long_up * coeff_abatt))
                    entrant = entrant + 0
                    entrant_parcel = entrant_parcel + 0
                    sortant_lat = sortant_lat + 0
                    abattement_lat_up = 0
                else:
                    entrant_lat_up = angle_up * entrant_up
                    entrant_long_up = (entrant_up - entrant_lat_up) + entrant_long_up
                    history_long_up = update_flow_history(history_long_up, history_up, 1 - angle_up)
                    history_long_abat_up = update_flow_history(history_long_abat_up, history_abat_up, 1 - angle_up)
                    for elem in history_long_up:
                        history_long_up[elem] = history_long_up[elem] - history_long_up[elem] * coeff_abatt
                    outflow_long_up = (entrant_long_up - (entrant_long_up * coeff_abatt))
                    history_lat_up = update_flow_history(history_lat_up, history_up, angle_up)
                    history_lat_abat_up = update_flow_history(history_lat_abat_up, history_abat_up, angle_up)
                    coeff_abatt = coefficient_abatement_lateral_TE(type_up, self.abatement_lat)
                    coeff_abatt = coeff_abatt * coef_minus_up
                    abattement_lat_up = entrant_lat_up * coeff_abatt
                    history_lat_abat_up["line_" + str(river_feature.id())] = abattement_lat_up
                    for elem in history_lat_up:
                        history_lat_up[elem] = history_lat_up[elem] - history_lat_up[elem] * coeff_abatt
                    history = update_flow_history(history, history_lat_up, 1)
                    entrant = entrant + (entrant_lat_up - abattement_lat_up)
                    entrant_parcel = entrant_parcel + (entrant_lat_up - abattement_lat_up)
                    sortant_lat = sortant_lat + entrant_lat_up - abattement_lat_up
                entrant_line = entrant_line + 0
            elif type_up in self.abatement_type_lat:
                history_lat_up = update_flow_history(history_lat_up, history_up, 1)
                history_lat_abat_up = update_flow_history(history_lat_abat_up, history_abat_up, 1)
                entrant_lat_up = entrant_up
                coeff_abatt = coefficient_abatement_lateral_TE(type_up, self.abatement_lat)
                coeff_abatt = coeff_abatt * coef_minus_up
                abattement_lat_up = entrant_lat_up * coeff_abatt
                history_lat_abat_up["line_" + str(river_feature.id())] = abattement_lat_up
                for elem in history_lat_up:
                    history_lat_up[elem] = history_lat_up[elem] - history_lat_up[elem] * coeff_abatt
                history = update_flow_history(history, history_lat_up, 1)
                history = update_flow_history(history, history_long_up, 1)
                history_lat_abat_up = update_flow_history(history_lat_abat_up, history_long_abat_up, 1)
                history_long_up = {}
                sortant_lat = sortant_lat + entrant_lat_up - abattement_lat_up
                entrant = entrant + (entrant_lat_up - abattement_lat_up) + entrant_long_up
                entrant_line = entrant_line + entrant_long_up
                entrant_parcel = entrant_parcel + (entrant_lat_up - abattement_lat_up)
                outflow_long_up = 0
            elif type_up == 0:
                history = update_flow_history(history, history_up, 1)
                history = update_flow_history(history, history_long_up, 1)
                history_lat_abat_up = update_flow_history(history_lat_abat_up, history_abat_up, 1)
                history_lat_abat_up = update_flow_history(history_lat_abat_up, history_long_abat_up, 1)
                entrant = entrant + entrant_up + entrant_long_up
                entrant_line = entrant_line + entrant_long_up
                sortant_lat = sortant_lat + entrant_up
                entrant_parcel = entrant_parcel + sortant_lat
                history_long_up = {}
                history_long_abat_up = {}
                abattement_lat_up = 0
                outflow_long_up = 0

            if type_dwn in self.abatement_type_long:
                coeff_abatt = coefficient_abatement_longitudinal_TE(type_dwn, longueur_lineaire,
                                                                    self.abatement_long)
                coeff_abatt = coeff_abatt * coef_minus_dwn
                if type_dwn not in self.abatement_type_lat:
                    entrant_long_dwn = entrant_dwn + entrant_long_dwn
                    history_long_dwn = update_flow_history(history_long_dwn, history_dwn, 1)
                    history_long_abat_dwn = update_flow_history(history_long_abat_dwn, history_abat_dwn, 1)
                    for elem in history_long_dwn:
                        history_long_dwn[elem] = history_long_dwn[elem] - history_long_dwn[elem] * coeff_abatt
                    history_long_abat_dwn["line_" + str(river_feature.id())] = entrant_long_dwn * coeff_abatt
                    outflow_long_down = entrant_long_dwn - (entrant_long_dwn * coeff_abatt)
                    entrant = entrant + 0
                    entrant_parcel = entrant_parcel + 0
                    sortant_lat = sortant_lat + 0
                    abattement_lat_dwn = 0
                else:
                    entrant_lat_dwn = angle_dwn * entrant_dwn
                    entrant_long_dwn = (entrant_dwn - entrant_lat_dwn) + entrant_long_dwn
                    history_long_dwn = update_flow_history(history_long_dwn, history_dwn, 1 - angle_dwn)
                    history_long_abat_dwn = update_flow_history(history_long_abat_dwn, history_abat_dwn,
                                                                1 - angle_dwn)
                    for elem in history_long_dwn:
                        history_long_dwn[elem] = history_long_dwn[elem] - history_long_dwn[elem] * coeff_abatt
                    history_long_abat_dwn["line_" + str(river_feature.id())] = entrant_long_dwn * coeff_abatt
                    outflow_long_down = entrant_long_dwn - (entrant_long_dwn * coeff_abatt)
                    history_lat_dwn = update_flow_history(history_lat_dwn, history_dwn, angle_dwn)
                    history_lat_abat_dwn = update_flow_history(history_lat_abat_dwn, history_abat_dwn, angle_dwn)
                    coeff_abatt = coefficient_abatement_lateral_TE(type_dwn, self.abatement_lat)
                    coeff_abatt = coeff_abatt * coef_minus_dwn
                    abattement_lat_dwn = entrant_lat_dwn * coeff_abatt
                    history_lat_abat_dwn["line_" + str(river_feature.id())] = abattement_lat_dwn
                    for elem in history_lat_dwn:
                        history_lat_dwn[elem] = history_lat_dwn[elem] - history_lat_dwn[elem] * coeff_abatt
                    history = update_flow_history(history, history_lat_dwn, 1)
                    entrant = entrant + (entrant_lat_dwn - abattement_lat_dwn)
                    entrant_parcel = entrant_parcel + (entrant_lat_dwn - abattement_lat_dwn)
                    sortant_lat = sortant_lat + entrant_lat_dwn - abattement_lat_dwn
                entrant_line = entrant_line + 0
            elif type_dwn in self.abatement_type_lat:
                outflow_long_down = 0
                history_lat_dwn = update_flow_history(history_lat_dwn, history_dwn, 1)
                history_lat_abat_dwn = update_flow_history(history_lat_abat_dwn, history_abat_dwn, 1)
                entrant_lat_dwn = entrant_dwn
                coeff_abatt = coefficient_abatement_lateral_TE(type_dwn, self.abatement_lat)
                coeff_abatt = coeff_abatt * coef_minus_dwn
                abattement_lat_dwn = entrant_lat_dwn * coeff_abatt
                history_lat_abat_dwn["line_" + str(river_feature.id())] = abattement_lat_dwn
                for elem in history_lat_dwn:
                    history_lat_dwn[elem] = history_lat_dwn[elem] - history_lat_dwn[elem] * coeff_abatt
                history = update_flow_history(history, history_lat_dwn, 1)
                history = update_flow_history(history, history_long_dwn, 1)
                history_lat_abat_dwn = update_flow_history(history_lat_abat_dwn, history_long_abat_dwn, 1)
                history_long_dwn = {}
                sortant_lat = sortant_lat + entrant_lat_dwn - abattement_lat_dwn
                entrant = entrant + (entrant_lat_dwn - abattement_lat_dwn) + entrant_long_dwn
                entrant_line = entrant_line + entrant_long_dwn
                entrant_parcel = entrant_parcel + (entrant_lat_dwn - abattement_lat_dwn)
            elif type_dwn == 0:
                history = update_flow_history(history, history_dwn, 1)
                history = update_flow_history(history, history_long_dwn, 1)
                history_lat_abat_dwn = update_flow_history(history_lat_abat_dwn, history_abat_dwn, 1)
                history_lat_abat_dwn = update_flow_history(history_lat_abat_dwn, history_long_abat_dwn, 1)
                entrant = entrant + entrant_dwn + entrant_long_dwn
                entrant_line = entrant_line + entrant_long_dwn
                sortant_lat = sortant_lat + entrant_dwn
                entrant_parcel = entrant_parcel + entrant_dwn
                history_long_dwn = {}
                history_long_abat_dwn = {}
                abattement_lat_dwn = 0
                outflow_long_down = 0
            sortant = entrant
            sortant_long = outflow_long_up + outflow_long_down
            abattement_total = abattement_lat_up + abattement_lat_dwn
            history_abat = update_flow_history(history_lat_abat_dwn, history_lat_abat_up, 1)
            entrant = abattement_total + sortant_long + sortant_lat
        return entrant, sortant, sortant_long, outflow_long_up, outflow_long_down, sortant_lat, entrant_line, \
               entrant_parcel, abattement_total, history, history_abat, history_long_up, history_long_abat_up, \
               history_long_dwn, history_long_abat_dwn

    def parcel_analysis(self, line_layer, parcel_layer, connexion_layer, id_parcel, parcelle_id_selected,
                        list_id_parcelle, parcel_abat, processed_poly, history_field, history_abatement_field):
        parcel = parcel_layer.getFeature(id_parcel)
        history = {}
        attrs = parcel.attributes()
        if id_parcel in parcelle_id_selected:
            prod = attrs[parcel_layer.fields().indexFromName(field_flow_production)]
            history["parcelle_" + str(id_parcel)] = prod
        else:
            prod = 0
        sortant_total_up, history, history_abat_parcel_up = self.get_parcel_inflow_from_parcel(parcel, id_parcel,
                                                                                               line_layer,
                                                                                               parcel_layer,
                                                                                               connexion_layer,
                                                                                               history,
                                                                                               list_id_parcelle,
                                                                                               history_field,
                                                                                               history_abatement_field)
        sortant_total_up, history, history_abat_line_up = self.get_parcel_inflow_from_line(line_layer, id_parcel,
                                                                                           sortant_total_up, history)
        # Inflow equal the outflow from linears and parcels above plus the production of the selected parcel.
        entrant_total = sortant_total_up + prod
        abattement_total, parcel_abat, history, history_abat = self.get_parcel_abatement(parcel, id_parcel,
                                                                                         parcel_layer, entrant_total,
                                                                                         parcel_abat, history)
        sortant = entrant_total - abattement_total  # Outflow equal inflow - the absorbed flow.

        sortant, entrant_total, abattement_total, drain_outflow, history, history_abat = self.get_drain_outflow(
            parcel, id_parcel, line_layer, parcel_layer, sortant, entrant_total, abattement_total, history,
            history_abat)

        history_abat = update_flow_history(history_abat, history_abat_parcel_up, 1)
        history_abat = update_flow_history(history_abat, history_abat_line_up, 1)
        sortant = sortant - drain_outflow

        new_attributes = {field_parcel_outflow_drain: drain_outflow, field_incoming_flow: entrant_total,
                          field_outgoing_flow: sortant,
                          field_flow_abatement: abattement_total, history_field: history,
                          history_abatement_field: history_abat}
        self.save_attributes(parcel_layer, id_parcel, new_attributes)
        processed_poly.append(id_parcel)
        return processed_poly, parcel_abat

    def get_parcel_inflow_from_parcel(self, parcel, id_parcel, line_layer, parcel_layer, connexion_layer, history,
                                      list_id_parcelle, history_field, history_abatement_field):
        sortant_total_up = 0
        history_abat_up = {}
        attrs = parcel.attributes()
        gm_uh_up = attrs[parcel_layer.fields().indexFromName(field_parcel_above)]
        if gm_uh_up != NULL:
            poly_up = *map(int, gm_uh_up.split(', ')),
            not_selected = [x for x in poly_up if x not in list_id_parcelle]
            poly_up = [x for x in poly_up if x not in not_selected]
            if len(poly_up) != 0:
                top_parcel_outflow = 0
                for uh_up in poly_up:  # We can get the outflow from the parcel above.
                    dict_history = {}
                    line_above = None
                    select_lineaire = QgsExpression("{champ_parcelle_aval_lineaire} = '{uh_dwn}' and "
                                                    "{champ_parcelle_amont_lineaire} = '{uh_up}' and "
                                                    "{champ_type_ligne} != '{valeur_null}' and "
                                                    "{champ_type_ligne} != '{valeur_riviere}' and "
                                                    "{champ_type_ligne} != '{valeur_drain}'".format(
                        champ_parcelle_aval_lineaire=field_line_parcel_below,
                        champ_parcelle_amont_lineaire=field_line_parcel_above,
                        champ_type_ligne=field_type_line_middle, uh_dwn=id_parcel, uh_up=uh_up,
                        valeur_null=null, valeur_riviere=river, valeur_drain=drain))
                    # If there is a linear between the two parcels, the outflow come from the linear.
                    for feature in line_layer.getFeatures(QgsFeatureRequest(select_lineaire)):
                        line_above = 1
                        attrs = feature.attributes()
                        sortant_lat = attrs[
                            line_layer.fields().indexFromName(field_outgoing_flow_lat)]
                        top_parcel_outflow = sortant_lat
                        if attrs[line_layer.fields().indexFromName(history_field)] != NULL:
                            flow_history = (attrs[line_layer.fields().indexFromName(history_field)]).split("; ")
                            if flow_history[0] != '':
                                for elem in flow_history:
                                    dict_history[elem.split(": ")[0]] = float(elem.split(": ")[1])
                                history = update_flow_history(history, dict_history, 1)
                        if attrs[line_layer.fields().indexFromName(field_history_abatement_lat)] != NULL:
                            flow_history = (
                                attrs[line_layer.fields().indexFromName(field_history_abatement_lat)]).split("; ")
                            if flow_history[0] != '':
                                for elem in flow_history:
                                    history_abat_up[elem.split(": ")[0]] = float(elem.split(": ")[1])
                    if not line_above:
                        select_uh_up = QgsExpression("{champ_identifiant_parcelle} = '{id}'".format(
                            champ_identifiant_parcelle=field_parcel_id, id=uh_up))
                        for feat in parcel_layer.getFeatures(QgsFeatureRequest(select_uh_up)):
                            attrs = feat.attributes()
                            parcel_outflow = attrs[
                                parcel_layer.fields().indexFromName(field_outgoing_flow)]
                            type_drain = attrs[parcel_layer.fields().indexFromName(field_parcel_drain_type)]
                            actif_drain = attrs[parcel_layer.fields().indexFromName(field_parcel_active_drain)]
                            if actif_drain == 1 and (type_drain == 2 or type_drain == 3):
                                coef = 0.2
                            else:
                                coef = 1
                            if attrs[parcel_layer.fields().indexFromName(history_field)] != NULL:
                                flow_history = (attrs[parcel_layer.fields().indexFromName(history_field)]).split("; ")
                                if flow_history[0] != '':
                                    for elem in flow_history:
                                        dict_history[elem.split(": ")[0]] = float(elem.split(": ")[1])
                            dict_history = update_flow_history({}, dict_history, coef)
                            if attrs[parcel_layer.fields().indexFromName(history_abatement_field)] != NULL:
                                flow_history = (
                                    attrs[parcel_layer.fields().indexFromName(history_abatement_field)]).split("; ")
                            else:
                                flow_history = ['']
                            # parcel_outflow = parcel_outflow - drain_outflow
                            select_connect_up = QgsExpression("{champ_parcelle_aval_connexions} = '{uh_dwn}' and "
                                                              "{champ_parcelle_amont_connexions} = '{uh_up}'".format(
                                champ_parcelle_aval_connexions=field_connexions_parcel_below,
                                champ_parcelle_amont_connexions=field_connexions_parcel_above,
                                uh_dwn=id_parcel, uh_up=uh_up))
                            for connex_feat in connexion_layer.getFeatures(QgsFeatureRequest(select_connect_up)):
                                attrs = connex_feat.attributes()
                                flow_coefficient = attrs[connexion_layer.fields().indexFromName(
                                    field_connexions_flow_coefficient)]
                                if flow_history[0] != '':
                                    for elem in flow_history:
                                        if elem.split(": ")[0] in history_abat_up.keys():
                                            history_abat_up[elem.split(": ")[0]] = history_abat_up[
                                                                                       elem.split(": ")[0]] + (float(
                                                elem.split(": ")[1]) * coef) * flow_coefficient
                                        else:
                                            history_abat_up[elem.split(": ")[0]] = (float(
                                                elem.split(": ")[1]) * coef) * flow_coefficient
                                history = update_flow_history(history, dict_history, flow_coefficient)
                                # From the connexion_layer we can get the coefficient of flow between the two parcels.
                                top_parcel_outflow = flow_coefficient * parcel_outflow
                    sortant_total_up = sortant_total_up + top_parcel_outflow
        return sortant_total_up, history, history_abat_up

    def get_parcel_inflow_from_line(self, line_layer, id_parcel, sortant_total_up, history):
        history_abat_up = {}
        select_lineaire = QgsExpression("{champ_outflow_direction} = '{uh_dwn}' and {field_line_type} != "
                                        "'{null}' and {field_line_type} != '{river}'".format(
            champ_outflow_direction=field_outgoing_flow_line_to_parcel,
            field_line_type=field_type_line_middle, uh_dwn=id_parcel, null=null,
            river=river))
        for feature in line_layer.getFeatures(QgsFeatureRequest(
                select_lineaire)):  # If there is a linear between the two parcels, the outflow come from the linear.
            attrs = feature.attributes()
            sortant_long = attrs[line_layer.fields().indexFromName(field_outgoing_flow_long)]
            sortant_total_up = sortant_total_up + sortant_long
            dict_history = {}
            if attrs[line_layer.fields().indexFromName(field_history_outflow_long)] != NULL:
                flow_history = (attrs[line_layer.fields().indexFromName(field_history_outflow_long)]).split("; ")
                if flow_history[0] != '':
                    for elem in flow_history:
                        dict_history[elem.split(": ")[0]] = float(elem.split(": ")[1])
            history = update_flow_history(history, dict_history, 1)
            if attrs[line_layer.fields().indexFromName(field_history_abatement_long)] != NULL:
                flow_history = (attrs[line_layer.fields().indexFromName(field_history_abatement_long)]).split("; ")
                if flow_history[0] != '':
                    for elem in flow_history:
                        history_abat_up[elem.split(": ")[0]] = float(elem.split(": ")[1])
        return sortant_total_up, history, history_abat_up

    def get_parcel_abatement(self, parcel, id_parcel, parcel_layer, entrant_total, parcel_abat, history):
        abattement_total = 0
        history_abat = {}
        attrs = parcel.attributes()
        type_parcelle = attrs[parcel_layer.fields().indexFromName(field_type_parcel)]
        river_side = attrs[parcel_layer.fields().indexFromName(field_parcel_below)]
        if type_parcelle == 300 and river_side == NULL and self.watershed_name == "gimond":
            coef_minus = 0.5
        else:
            coef_minus = 1
        if entrant_total != 0 and type_parcelle in self.abatement:
            longueur = attrs[parcel_layer.fields().indexFromName(field_parcel_slope_length)]
            pente = attrs[parcel_layer.fields().indexFromName(field_parcel_slope)]
            if id_parcel not in parcel_abat:
                parcel_abat.append(id_parcel)
            coeff = coefficient_abatement_UH(type_parcelle, pente, longueur, self.slope,
                                             self.abatement)
            abatement_coefficient = coeff * coef_minus
            for elem in history:
                history[elem] = history[elem] - history[elem] * abatement_coefficient
            abattement_total = entrant_total * abatement_coefficient
            if abattement_total > entrant_total:
                abattement_total = entrant_total
            history_abat["parcelle_" + str(id_parcel)] = abattement_total
        return abattement_total, parcel_abat, history, history_abat

    def get_drain_outflow(self, parcel, id_parcel, line_layer, parcel_layer, sortant, entrant_total,
                          abattement_total, history, history_abat):
        drain_outflow = 0
        attrs = parcel.attributes()
        if parcel_layer.fields().indexFromName(field_parcel_active_drain) == -1:
            active_drain = 0
            drain_type = 0
            drain_id = 0
        else:
            active_drain = attrs[parcel_layer.fields().indexFromName(field_parcel_active_drain)]
            drain_type = attrs[parcel_layer.fields().indexFromName(field_parcel_drain_type)]
            drain_id = attrs[parcel_layer.fields().indexFromName(field_parcel_drain_id)]
        if active_drain == 1:
            if drain_type == 1:
                drain_outflow = sortant * 0.20
            elif drain_type == 2:
                drain_outflow = sortant * 0.80
                entrant_drain = line_layer.getFeature(drain_id).attributes()[
                    line_layer.fields().indexFromName(field_incoming_flow)]
                abattement_drain = line_layer.getFeature(drain_id).attributes()[
                    line_layer.fields().indexFromName(field_flow_abatement)]
                line_layer.changeAttributeValue(drain_id, line_layer.fields().indexFromName(
                    field_incoming_flow), entrant_drain + drain_outflow)
                line_layer.changeAttributeValue(drain_id, line_layer.fields().indexFromName(
                    field_outgoing_flow), entrant_drain + drain_outflow - abattement_drain)
                line_layer.changeAttributeValue(drain_id, line_layer.fields().indexFromName(
                    field_outgoing_flow_long), entrant_drain + drain_outflow - abattement_drain)
            elif drain_type == 3:
                drain_outflow = sortant * 0.80
                history = update_flow_history_abat({}, history, 0.20)
                drain_outflow_total = drain_outflow
                select_uh = QgsExpression(
                    " {champ_drain} = '{drain}'".format(champ_drain=field_parcel_drain_id, drain=drain_id))
                for uh in parcel_layer.getFeatures(QgsFeatureRequest(select_uh)):
                    attrs = uh.attributes()
                    drain_outflow_up = attrs[parcel_layer.fields().indexFromName(field_parcel_outflow_drain)]
                    drain_outflow_total = drain_outflow_total + drain_outflow_up
                entrant_total = entrant_total + drain_outflow_total - drain_outflow
                abattement_ztha = drain_outflow_total * 0.50
                history = update_flow_history_abat({}, history, 0.50)
                line_layer.changeAttributeValue(drain_id, line_layer.fields().indexFromName(
                    field_incoming_flow), drain_outflow_total)
                line_layer.changeAttributeValue(drain_id, line_layer.fields().indexFromName(
                    field_incoming_flow_from_parcel), drain_outflow_total)
                abattement_drain = line_layer.getFeature(drain_id).attributes()[
                    line_layer.fields().indexFromName(field_flow_abatement)]
                line_layer.changeAttributeValue(drain_id, line_layer.fields().indexFromName(
                    field_outgoing_flow), drain_outflow_total - abattement_drain)
                line_layer.changeAttributeValue(drain_id, line_layer.fields().indexFromName(
                    field_outgoing_flow_lat), drain_outflow_total - abattement_drain)
                abattement_total = abattement_total + abattement_ztha
                sortant = entrant_total - abattement_total
                drain_outflow = 0
                history_abat = update_flow_history(history_abat,
                                                   {"parcelle_" + str(id_parcel): abattement_ztha}, 1)
        elif drain_type == 1:
            abattement_mouillere = sortant * 0.20
            history_abat = update_flow_history(history_abat, {"parcelle_" + str(id_parcel): abattement_mouillere},
                                               1)
            history = update_flow_history_abat(history, {"parcelle_" + str(id_parcel): abattement_mouillere}, 1)
            sortant = sortant - abattement_mouillere
            abattement_total = abattement_total + abattement_mouillere
        elif drain_type == 3:
            dict_history = {}
            dict_history_abat = {}
            select_lineaire = QgsExpression(
                " {champ_type_ligne} = '{drain}' and {champ_uh_aval} = '{id}'".format(
                    champ_type_ligne=field_type_line_middle, drain=drain,
                    champ_uh_aval=field_line_parcel_below,
                    id=id_parcel))
            for drain_feature in line_layer.getFeatures(QgsFeatureRequest(select_lineaire)):
                attrs = drain_feature.attributes()
                entrant_ztha = attrs[line_layer.fields().indexFromName(field_incoming_flow)]
                flow_history = (attrs[line_layer.fields().indexFromName(field_history_outflow_long)]).split("; ")
                if flow_history[0] != '':
                    for elem in flow_history:
                        dict_history[elem.split(": ")[0]] = float(elem.split(": ")[1])
                flow_history = (attrs[line_layer.fields().indexFromName(field_history_abatement_long)]).split("; ")
                if flow_history[0] != '':
                    for elem in flow_history:
                        dict_history_abat[elem.split(": ")[0]] = float(elem.split(": ")[1])
                abattement_ztha = entrant_ztha * 0.5
                sortant = sortant - abattement_ztha + entrant_ztha
                abattement_total = abattement_total + abattement_ztha
                entrant_total = entrant_total + entrant_ztha
                line_layer.changeAttributeValue(drain_feature.id(), line_layer.fields().indexFromName(
                    field_outgoing_flow_lat), entrant_ztha)
                line_layer.changeAttributeValue(drain_feature.id(), line_layer.fields().indexFromName(
                    field_outgoing_flow_long), 0)
                history = update_flow_history(history, dict_history, 1)
                history = update_flow_history({}, history, 0.5)
                history_abat = update_flow_history(history_abat, dict_history_abat, 1)
                dict_test = {"parcelle_" + str(id_parcel): abattement_ztha}
                history_abat = update_flow_history(history_abat, dict_test, 1)

        return sortant, entrant_total, abattement_total, drain_outflow, history, history_abat

    def save_attributes(self, layer, feature, new_attributes):
        for attribute in new_attributes:
            if isinstance(new_attributes[attribute], dict):
                new_attribute = self.save_history(new_attributes[attribute])
                layer.changeAttributeValue(feature, layer.fields().indexFromName(attribute), new_attribute)
            else:
                layer.changeAttributeValue(feature, layer.fields().indexFromName(attribute), new_attributes[attribute])

    def save_history(self, history):
        value = ""
        if history != NULL:
            for elem in history:
                value = value + str(elem) + ": " + str(history[elem])
                if elem != list(history.keys())[-1]:
                    value = value + "; "
        return value

    def create_symbology(self, layer, all_rules):
        rules = ()
        n = 0
        while n < len(all_rules):
            expression = all_rules[n][1]
            layer.selectByExpression(expression)
            if layer.selectedFeatureCount() > 0:
                rule = (all_rules[n],)
                rules = rules + rule
            layer.removeSelection()
            n = n + 1
        # create a new rule-based renderer
        symbol = QgsSymbol.defaultSymbol(layer.geometryType())
        symbol.symbolLayer(0).setStrokeColor(QColor('transparent'))
        if layer.geometryType() == 2:
            symbol.symbolLayer(0).setStrokeColor(QColor('#565656'))
            symbol.symbolLayer(0).setStrokeWidth(0.06)
        elif layer.geometryType() == 1:
            symbol.deleteSymbolLayer(0)
            symbol.appendSymbolLayer(QgsSimpleLineSymbolLayer())
            symbol.appendSymbolLayer(QgsSimpleLineSymbolLayer())
            symbol.symbolLayer(0).setStrokeColor(QColor('transparent'))
        renderer = QgsRuleBasedRenderer(symbol)

        # get the "root" rule
        root_rule = renderer.rootRule()
        if layer.geometryType() == 2 and len(all_rules) == 0:
            rule = root_rule.children()[0].clone()
            rule.setLabel('')
            rule.symbol().symbolLayer(0).setColor(QColor('transparent'))
            rule.symbol().symbolLayer(0).setStrokeColor(QColor('#565656'))
            rule.symbol().symbolLayer(0).setStrokeWidth(0.06)
            root_rule.appendChild(rule)
        for label, expression, color_name, size in rules:
            # create a clone (i.e. a copy) of the default rule
            rule = root_rule.children()[0].clone()
            # set the label, expression and color
            rule.setLabel(label)
            rule.setFilterExpression(expression)
            rule.symbol().setColor(QColor(color_name))
            if layer.geometryType() == 0:
                # set size
                rule.symbol().setSize(size)
            elif layer.geometryType() == 1:
                if color_name == QColor('transparent'):
                    rule.symbol().symbolLayer(0).setColor(color_name)
                    rule.symbol().symbolLayer(1).setColor(color_name)
                    rule.symbol().symbolLayer(1).setPenCapStyle(0)
                elif color_name == "dashed":
                    rule.symbol().symbolLayer(1).setPenStyle(Qt.PenStyle(Qt.DotLine))
                    rule.symbol().symbolLayer(1).setColor(QColor('#00ba41'))
                    rule.symbol().symbolLayer(1).setWidth(size)
                    rule.symbol().symbolLayer(0).setPenStyle(Qt.PenStyle(Qt.NoPen))
                else:
                    rule.symbol().symbolLayer(0).setColor(QColor('black'))
                    rule.symbol().symbolLayer(1).setColor(color_name)
                    rule.symbol().symbolLayer(1).setPenCapStyle(0)
                rule.symbol().symbolLayer(0).setWidth(size + 0.4)
                rule.symbol().symbolLayer(0).setPenCapStyle(0)
                rule.symbol().symbolLayer(1).setWidth(size)
            # append the rule to the list of rules
            root_rule.appendChild(rule)

        # delete the default rule
        root_rule.removeChildAt(0)

        # apply the renderer to the layer
        layer.setRenderer(renderer)
        layer.triggerRepaint()

    def create_layers_emit(self, args, parcel_layer, line_layer, processed_poly, group_name_1, group_name_2,
                           group_name_3, prefix):
        QgsProject.instance().layerTreeRoot().insertGroup(0, group_name_1)
        group = QgsProject.instance().layerTreeRoot().findGroup(group_name_1)

        group.insertGroup(0, group_name_2)
        group_abattement = QgsProject.instance().layerTreeRoot().findGroup(group_name_2)

        group.insertGroup(0, group_name_3)
        group_transfert = QgsProject.instance().layerTreeRoot().findGroup(group_name_3)

        if not args:
            idx_entrant = parcel_layer.fields().indexFromName(field_incoming_flow)
            max_entrant_parcelle = parcel_layer.maximumValue(idx_entrant)
        else:
            max_entrant_parcelle = args[0]
        parcel_layer.startEditing()
        for f in parcel_layer.getFeatures():
            attrs = f.attributes()
            abatt = attrs[parcel_layer.fields().indexFromName(field_flow_abatement)]
            entrant = attrs[parcel_layer.fields().indexFromName(field_incoming_flow)]
            parcel_id = attrs[parcel_layer.fields().indexFromName(field_parcel_id)]
            if parcel_id not in processed_poly:
                indice_ent = 99
                indice_ab = 999
            else:
                if max_entrant_parcelle == 0:
                    indice_ent = 0
                else:
                    indice_ent = (entrant / max_entrant_parcelle) * 10
                if entrant == 0:
                    indice_ab = 0
                else:
                    indice_ab = (abatt / entrant) * 100
            parcel_layer.changeAttributeValue(f.id(),
                                              parcel_layer.fields().indexFromName(field_flow_abatement_rating),
                                              indice_ab)
            parcel_layer.changeAttributeValue(f.id(),
                                              parcel_layer.fields().indexFromName(field_incoming_flow_rating),
                                              indice_ent)
        parcel_layer.commitChanges()
        parcel_layer.triggerRepaint()

        line_layer.selectByExpression(
            "{field_type_line} = '{river}' and {field_type_top} = {zero} and {field_type_bottom} = {zero}".format(
                field_type_line=field_type_line_middle, river=river, field_type_top=field_type_line_top,
                field_type_bottom=field_type_line_bottom, zero=0))
        line_layer.invertSelection()
        not_riviere_layer = processing.run("native:saveselectedfeatures",
                                           {'INPUT': line_layer,
                                            'OUTPUT': 'memory:' + lines_not_river_layer_name + prefix})[
            'OUTPUT']

        if not args:
            idx_entrant = not_riviere_layer.fields().indexFromName(field_incoming_flow)
            max_entrant_lineaire = not_riviere_layer.maximumValue(idx_entrant)
        else:
            max_entrant_lineaire = args[1]
            if max_entrant_lineaire == 0:
                max_entrant_lineaire = -1
        line_layer.startEditing()
        for f in line_layer.getFeatures():
            attrs = f.attributes()
            abatt = attrs[line_layer.fields().indexFromName(field_flow_abatement)]
            entrant = attrs[line_layer.fields().indexFromName(field_incoming_flow)]
            line_type = attrs[line_layer.fields().indexFromName(field_type_line_middle)]
            if line_type == null:
                indice_ab = 999
                indice_ent = 99
            else:
                if entrant == 0:
                    indice_ab = 0
                else:
                    if line_type == drain:
                        abatt = 0
                    indice_ab = (abatt / entrant) * 100
                if max_entrant_lineaire == 0:
                    indice_ent = 0
                elif max_entrant_lineaire == -1:
                    idx_entrant = not_riviere_layer.fields().indexFromName(field_incoming_flow)
                    max_entrant_lineaire = not_riviere_layer.maximumValue(idx_entrant)
                    if line_type == river:
                        indice_ent = 0
                    else:
                        indice_ent = (entrant / max_entrant_lineaire) * 10
                else:
                    if line_type == river:
                        indice_ent = 0
                    else:
                        indice_ent = (entrant / max_entrant_lineaire) * 10

            line_layer.changeAttributeValue(f.id(), line_layer.fields().indexFromName(
                field_flow_abatement_rating), indice_ab)
            line_layer.changeAttributeValue(f.id(), line_layer.fields().indexFromName(
                field_incoming_flow_rating), indice_ent)
        line_layer.commitChanges()
        line_layer.triggerRepaint()
        line_layer.removeSelection()

        line_layer.selectByExpression(
            " {field_type_line} = '{river}'".format(field_type_line=field_type_line_middle, river=river))
        riviere_layer = processing.run("native:saveselectedfeatures",
                                       {'INPUT': line_layer,
                                        'OUTPUT': 'memory:' + river_incoming_flow_layer_name + prefix})['OUTPUT']
        line_layer.removeSelection()
        QgsProject().instance().addMapLayer(riviere_layer, False)
        if not args:
            idx = riviere_layer.fields().indexFromName(field_outgoing_flow)
            max_outflow_river = riviere_layer.maximumValue(idx)
        else:
            max_outflow_river = args[2]
        riviere_layer.startEditing()
        total_entrant = []
        for f in riviere_layer.getFeatures():
            attrs = f.attributes()
            outflow = attrs[riviere_layer.fields().indexFromName(field_outgoing_flow)]
            te_dwn = attrs[riviere_layer.fields().indexFromName(field_line_line_below)]
            line_type = attrs[riviere_layer.fields().indexFromName(field_type_line_middle)]
            if te_dwn == NULL:
                exutoire_id = f.id()
                sort_long = attrs[riviere_layer.fields().indexFromName(field_outgoing_flow_long)]
                total_entrant.append(sort_long)
            total_entrant.append(outflow)
            if line_type != river or outflow == 0:
                indice = 99
            else:
                indice = 11
                if max_outflow_river != 0:
                    indice = (outflow / max_outflow_river) * 10
            riviere_layer.changeAttributeValue(f.id(),
                                               riviere_layer.fields().indexFromName(field_incoming_flow_rating), indice)
        exutoire = sum(total_entrant)
        riviere_layer.changeAttributeValue(exutoire_id, riviere_layer.fields().indexFromName(field_outlet_inflow),
                                           exutoire)
        riviere_layer.commitChanges()
        riviere_layer.triggerRepaint()
        rules = (
            (transfer_map_river_legend_pt1, '"{field}" = 0 AND "{field_2}" = 0'.format(
                field=field_incoming_flow_rating, field_2=field_incoming_flow), QColor('transparent'), 1),
            (transfer_map_river_legend_pt2, '"{field}" >= 0 AND "{field}" <= 1 AND "{field_2}" > 0'.format(
                field=field_incoming_flow_rating, field_2=field_incoming_flow), QColor('#81ceba'), 1.46),
            (transfer_map_river_legend_pt3, '"{field}" >= 1 AND "{field}" <= 2'.format(
                field=field_incoming_flow_rating), QColor('#c0e5fb'), 1.46),
            (transfer_map_river_legend_pt4, '2 < "{field}" AND "{field}" <= 4'.format(
                field=field_incoming_flow_rating), QColor('#91baec'), 1.46),
            (transfer_map_river_legend_pt5, '4 < "{field}" AND "{field}" <= 6'.format(
                field=field_incoming_flow_rating), QColor('#628fdd'), 1.46),
            (transfer_map_river_legend_pt6, '6 < "{field}" AND "{field}" <= 8'.format(
                field=field_incoming_flow_rating), QColor('#3364ce'), 1.46),
            (transfer_map_river_legend_pt7, '8 < "{field}" AND "{field}" <= 10'.format(
                field=field_incoming_flow_rating), QColor('#0439bf'), 1.46),
            (transfer_map_river_legend_pt8, '"{field}" > 10 AND "{field}" != 99'.format(
                field=field_incoming_flow_rating), QColor('#000d2c'), 1.66),
        )
        self.create_symbology(riviere_layer, rules)
        group_transfert.addLayer(riviere_layer)

        line_layer.selectAll()
        layer_lineaire_abattement = processing.run("native:saveselectedfeatures",
                                                   {'INPUT': line_layer,
                                                    'OUTPUT': 'memory:' + line_abatement_layer_name + prefix})['OUTPUT']
        layer_lineaire_transfert = processing.run("native:saveselectedfeatures",
                                                  {'INPUT': line_layer,
                                                   'OUTPUT': 'memory:' + line_transfer_layer_name + prefix})['OUTPUT']
        line_layer.removeSelection()
        QgsProject().instance().addMapLayer(layer_lineaire_abattement, False)
        group_abattement.addLayer(layer_lineaire_abattement)
        rules = (
            (abatement_map_line_legend_pt1, '"{field}" = 0 AND "{field_2}" = 0'.format(
                field=field_incoming_flow_rating, field_2=field_incoming_flow), QColor('#832331'), 1),
            (abatement_map_line_legend_pt2, '"{field}" = 0 AND "{field_2}" = 0 AND "{field_3}" > 0'.format(
                field=field_flow_abatement_rating, field_2=field_flow_abatement, field_3=field_incoming_flow),
             "dashed", 0.66),
            (abatement_map_line_legend_pt3, '"{field}" >= 0 AND "{field}" <= 20 AND "{field_2}" > 0'.format(
                field=field_flow_abatement_rating, field_2=field_flow_abatement), QColor('#00ba41'), 0.6),
            (abatement_map_line_legend_pt4, '20 < "{field}" AND "{field}" <= 40'.format(
                field=field_flow_abatement_rating), QColor('#00ba41'), 1.1),
            (abatement_map_line_legend_pt5, '40 < "{field}" AND "{field}" <= 60'.format(
                field=field_flow_abatement_rating), QColor('#00ba41'), 1.6),
            (abatement_map_line_legend_pt6, '60 < "{field}" AND "{field}" <= 80'.format(
                field=field_flow_abatement_rating), QColor('#00ba41'), 2.1),
            (abatement_map_line_legend_pt7, '80 < "{field}" AND "{field}" < 100'.format(
                field=field_flow_abatement_rating), QColor('#00ba41'), 2.6),
            (abatement_map_line_legend_pt8, '"{field}" = 100'.format(
                field=field_flow_abatement_rating), QColor('#00ba41'), 3.06),
        )
        self.create_symbology(layer_lineaire_abattement, rules)
        QgsProject().instance().addMapLayer(layer_lineaire_transfert, False)
        group_transfert.addLayer(layer_lineaire_transfert)
        rules = (
            (transfer_map_line_legend_pt1, '"{field}" = 0 AND "{field_2}" = 0'.format(
                field=field_incoming_flow_rating, field_2=field_incoming_flow), QColor('transparent'), 1),
            (transfer_map_line_legend_pt2, '"{field}" >= 0 AND "{field}" <= 2 AND "{field_2}" > 0'.format(
                field=field_incoming_flow_rating, field_2=field_incoming_flow), QColor('#ffd7d7'), 0.7),
            (transfer_map_line_legend_pt3, '2 < "{field}" AND "{field}" <= 4'.format(
                field=field_incoming_flow_rating), QColor('#ffbfbf'), 0.7),
            (transfer_map_line_legend_pt4, '4 < "{field}" AND "{field}" <= 6'.format(
                field=field_incoming_flow_rating), QColor('#ff8080'), 0.7),
            (transfer_map_line_legend_pt5, '6 < "{field}" AND "{field}" <= 8'.format(
                field=field_incoming_flow_rating), QColor('#ff4040'), 0.7),
            (transfer_map_line_legend_pt6, '8 < "{field}" AND "{field}" <= 10'.format(
                field=field_incoming_flow_rating), QColor('#ff0000'), 0.7),
            (transfer_map_line_legend_pt7, '"{field}" > 10 AND "{field}" != 99'.format(
                field=field_incoming_flow_rating), QColor('#232323'), 1.26),
        )
        self.create_symbology(layer_lineaire_transfert, rules)

        parcel_layer.selectAll()
        parcel_layer_abattement = processing.run("native:saveselectedfeatures",
                                                 {'INPUT': parcel_layer,
                                                  'OUTPUT': 'memory:' + parcel_abatement_layer_name + prefix})['OUTPUT']
        parcel_layer_transfert = processing.run("native:saveselectedfeatures",
                                                {'INPUT': parcel_layer,
                                                 'OUTPUT': 'memory:' + parcel_transfer_layer_name + prefix})['OUTPUT']
        parcel_layer_limit = processing.run("native:saveselectedfeatures",
                                            {'INPUT': parcel_layer,
                                             'OUTPUT': 'memory:' + 'layer_limit_' + prefix})['OUTPUT']
        parcel_layer.removeSelection()
        QgsProject().instance().addMapLayer(parcel_layer_limit, False)
        group_abattement.addLayer(parcel_layer_limit)
        QgsProject().instance().addMapLayer(parcel_layer_abattement, False)
        group_abattement.addLayer(parcel_layer_abattement)
        rules = (
        )
        self.create_symbology(parcel_layer_limit, rules)
        rules = (
            (abatement_map_parcel_legend_pt1, '"{field_2}" = 0'.format(
                field_2=field_incoming_flow), QColor('#c9c9c9'), 1),
            (abatement_map_parcel_legend_pt2, '"{field}" = 0 AND "{field_2}" > 0 AND "{field_3}" = 0'.format(
                field=field_flow_abatement_rating, field_2=field_incoming_flow, field_3=field_flow_abatement),
             QColor('#ffffff'), 1),
            (abatement_map_parcel_legend_pt3, '"{field}" >= 0 AND "{field}" <= 20 AND "{field_3}" > 0'.format(
                field=field_flow_abatement_rating, field_3=field_flow_abatement), QColor('#f7fcf5'), 1),
            (abatement_map_parcel_legend_pt4, '20 < "{field}" AND "{field}" <= 40'.format(
                field=field_flow_abatement_rating), QColor('#d5efcf'), 1),
            (abatement_map_parcel_legend_pt5, '40 < "{field}" AND "{field}" <= 60'.format(
                field=field_flow_abatement_rating), QColor('#9ed898'), 1),
            (abatement_map_parcel_legend_pt6, '60 < "{field}" AND "{field}" <= 80'.format(
                field=field_flow_abatement_rating), QColor('#54b567'), 1),
            (abatement_map_parcel_legend_pt7, '80 < "{field}" AND "{field}" < 100'.format(
                field=field_flow_abatement_rating), QColor('#1d8641'), 1),
            (abatement_map_parcel_legend_pt8, '"{field}" = 100'.format(
                field=field_flow_abatement_rating), QColor('#00441b'), 1),
        )
        self.create_symbology(parcel_layer_abattement, rules)
        group_transfert.addLayer(parcel_layer_limit)
        QgsProject().instance().addMapLayer(parcel_layer_transfert, False)
        group_transfert.addLayer(parcel_layer_transfert)
        rules = (
            (transfer_map_parcel_legend_pt1, '"{field_2}" = 0'.format(
                field_2=field_incoming_flow), QColor('#ffffff'), 1),
            (transfer_map_parcel_legend_pt2, '"{field}" >= 0 AND "{field}" <= 2 AND "{field_2}" > 0'.format(
                field=field_incoming_flow_rating, field_2=field_incoming_flow), QColor('#ffe4e3'), 1),
            (transfer_map_parcel_legend_pt3, '2 < "{field}" AND "{field}" <= 4'.format(
                field=field_incoming_flow_rating), QColor('#f3b2ac'), 1),
            (transfer_map_parcel_legend_pt4, '4 < "{field}" AND "{field}" <= 6'.format(
                field=field_incoming_flow_rating), QColor('#ec7c6d'), 1),
            (transfer_map_parcel_legend_pt5, '6 < "{field}" AND "{field}" <= 8'.format(
                field=field_incoming_flow_rating), QColor('#e95042'), 1),
            (transfer_map_parcel_legend_pt6, '8 < "{field}" AND "{field}" <= 10'.format(
                field=field_incoming_flow_rating), QColor('#e41304'), 1),
            (transfer_map_parcel_legend_pt7, '"{field}" > 10 AND "{field}" != 99'.format(
                field=field_incoming_flow_rating), QColor('#1c1715'), 1),
        )
        self.create_symbology(parcel_layer_transfert, rules)
        return parcel_layer_transfert, layer_lineaire_transfert, riviere_layer, parcel_layer_abattement, \
               layer_lineaire_abattement, max_entrant_parcelle, max_entrant_lineaire, max_outflow_river

    def create_layers_received(self, parcel_layer, line_layer, intrant_total, abatement_total_p, list_parcel_id,
                               group_name_1, prefix):
        QgsProject.instance().layerTreeRoot().insertGroup(0, group_name_1)
        group = QgsProject.instance().layerTreeRoot().findGroup(group_name_1)

        line_layer.startEditing()
        for f in line_layer.getFeatures():
            attrs = f.attributes()
            abatt = attrs[line_layer.fields().indexFromName(field_flow_abatement)]
            entrant = attrs[line_layer.fields().indexFromName(field_incoming_flow)]
            entrant_up = attrs[line_layer.fields().indexFromName(field_outgoing_flow_long_up)]
            entrant_dwn = attrs[line_layer.fields().indexFromName(field_outgoing_flow_long_down)]
            lineaire_type = attrs[line_layer.fields().indexFromName(field_type_line_middle)]
            if lineaire_type == null or abatt == NULL or entrant == 0 or entrant == NULL:
                indice_ab = 999
            else:
                indice_ab = 999
                if entrant != NULL or entrant > 0:
                    if lineaire_type == 300:
                        abatt = 0
                    elif lineaire_type == 700:
                        if entrant_up + entrant_dwn > 0:
                            entrant = entrant_up + entrant_dwn
                    indice_ab = (abatt / entrant) * 100
            line_layer.changeAttributeValue(f.id(), line_layer.fields().indexFromName(
                field_flow_abatement_rating), indice_ab)
        line_layer.commitChanges()
        line_layer.triggerRepaint()

        line_layer.selectAll()
        layer_lineaire_abattement = processing.run("native:saveselectedfeatures",
                                                   {'INPUT': line_layer,
                                                    'OUTPUT': 'memory:' + line_abatement_layer_name + prefix})['OUTPUT']
        line_layer.removeSelection()
        QgsProject().instance().addMapLayer(layer_lineaire_abattement, False)
        group.addLayer(layer_lineaire_abattement)
        rules = (
            (abatement_map_line_legend_pt1, '"{field_2}" = 0'.format(
                field_2=field_incoming_flow), QColor('transparent'), 1),
            (abatement_map_line_legend_pt2, '"{field}" = 0 AND "{field_2}" > 0 AND "{field_3}" = 0'.format(
                field=field_flow_abatement_rating, field_2=field_incoming_flow, field_3=field_flow_abatement),
             "dashed", 0.66),
            (abatement_map_line_legend_pt3, '"{field}" >= 0 AND "{field}" <= 20 AND "{field_2}" > 0'.format(
                field=field_flow_abatement_rating, field_2=field_flow_abatement), QColor('#00ba41'), 0.6),
            (abatement_map_line_legend_pt4, '20 < "{field}" AND "{field}" <= 40'.format(
                field=field_flow_abatement_rating), QColor('#00ba41'), 1.1),
            (abatement_map_line_legend_pt5, '40 < "{field}" AND "{field}" <= 60'.format(
                field=field_flow_abatement_rating), QColor('#00ba41'), 1.6),
            (abatement_map_line_legend_pt6, '60 < "{field}" AND "{field}" <= 80'.format(
                field=field_flow_abatement_rating), QColor('#00ba41'), 2.1),
            (abatement_map_line_legend_pt7, '80 < "{field}" AND "{field}" < 100'.format(
                field=field_flow_abatement_rating), QColor('#00ba41'), 2.6),
            (abatement_map_line_legend_pt8, '"{field}" = 100'.format(
                field=field_flow_abatement_rating), QColor('#00ba41'), 3.06),
        )
        self.create_symbology(layer_lineaire_abattement, rules)

        parcel_layer.startEditing()
        for f in parcel_layer.getFeatures():
            attrs = f.attributes()
            prod_reel = attrs[parcel_layer.fields().indexFromName(field_flow_production_relative)]
            abatt_reel = attrs[parcel_layer.fields().indexFromName(field_flow_abatement)]
            indice_pr = 99
            indice_ab = 999
            if f.id() not in list_parcel_id and abatt_reel == NULL:
                indice_pr = 99
                indice_ab = 999
            elif intrant_total != 0:
                indice_pr = 99
                if prod_reel != NULL and prod_reel > 0:
                    indice_pr = (prod_reel / intrant_total) * 10
                    indice_ab = 0
                if abatt_reel != NULL and abatt_reel > 0:
                    if abatement_total_p != 0:
                        indice_ab = (abatt_reel / abatement_total_p) * 10
                    if 0 < indice_ab < 1:
                        indice_ab = 1
            parcel_layer.changeAttributeValue(f.id(), parcel_layer.fields().indexFromName(
                field_flow_production_rating), indice_pr)
            parcel_layer.changeAttributeValue(f.id(), parcel_layer.fields().indexFromName(
                field_flow_abatement_rating), indice_ab)
        parcel_layer.commitChanges()
        parcel_layer.triggerRepaint()

        indice_pr_layer = processing.run("native:centroids",
                                         {'INPUT': parcel_layer, 'ALL_PARTS': False,
                                          'OUTPUT': 'memory:' + parcel_contribution_layer_name + prefix})['OUTPUT']
        QgsProject().instance().addMapLayer(indice_pr_layer, False)
        group.addLayer(indice_pr_layer)
        # define some rules: label, expression, color name, (min scale, max scale)
        rules = (
            (parcel_river_map_production_legend_pt1, '"indice_p" = 0', QColor('transparent'), 0),
            (parcel_river_map_production_legend_pt2,
             '{indice} = 0'.format(indice=field_flow_production_rating), QColor('red'), 1.2),
            (parcel_river_map_production_legend_pt3,
             '{indice} = 1'.format(indice=field_flow_production_rating), QColor('red'), 1.8),
            (parcel_river_map_production_legend_pt4,
             '{indice} = 2'.format(indice=field_flow_production_rating), QColor('red'), 2.4),
            (parcel_river_map_production_legend_pt5,
             '{indice} = 3'.format(indice=field_flow_production_rating), QColor('red'), 3.4),
            (parcel_river_map_production_legend_pt6,
             '{indice} = 4'.format(indice=field_flow_production_rating), QColor('red'), 4.4),
            (parcel_river_map_production_legend_pt7,
             '{indice} = 5'.format(indice=field_flow_production_rating), QColor('red'), 5.4),
            (parcel_river_map_production_legend_pt8,
             '{indice} = 6'.format(indice=field_flow_production_rating), QColor('red'), 6.4),
            (parcel_river_map_production_legend_pt9,
             '{indice} = 7'.format(indice=field_flow_production_rating), QColor('red'), 7.0),
            (parcel_river_map_production_legend_pt10,
             '{indice} = 8'.format(indice=field_flow_production_rating), QColor('red'), 8.0),
            (parcel_river_map_production_legend_pt11,
             '{indice} = 9'.format(indice=field_flow_production_rating), QColor('red'), 9.0),
            (parcel_river_map_production_legend_pt12,
             '{indice} = 10'.format(indice=field_flow_production_rating), QColor('red'), 10.0),
        )

        self.create_symbology(indice_pr_layer, rules)
        parcel_layer.selectAll()
        indice_ab_layer = processing.run("native:saveselectedfeatures",
                                         {'INPUT': parcel_layer,
                                          'OUTPUT': 'memory:' + parcel_abatement_layer_name + prefix})['OUTPUT']
        QgsProject().instance().addMapLayer(indice_ab_layer, False)
        group.addLayer(indice_ab_layer)
        rules = (
            (abatement_map_parcel_legend_pt1, '"{field}" = 999 AND "{field_2}" <= 99'.format(
                field=field_flow_abatement_rating, field_2=field_flow_production_rating), QColor('#c9c9c9'), 1),
            (abatement_map_parcel_legend_pt2, '"{field_2}" != 99 AND "{field}" != 999'.format(
                field_2=field_flow_production_rating, field=field_flow_abatement_rating),
             QColor('#ffffff'), 1),
            (abatement_map_parcel_legend_pt3, '"{field}" >= 0 AND "{field}" <= 2 AND "{field_3}" > 0'.format(
                field=field_flow_abatement_rating, field_3=field_flow_abatement), QColor('#f7fcf5'), 1),
            (abatement_map_parcel_legend_pt4, '2 < "{field}" AND "{field}" <= 4'.format(
                field=field_flow_abatement_rating), QColor('#d5efcf'), 1),
            (abatement_map_parcel_legend_pt5, '4 < "{field}" AND "{field}" <= 6'.format(
                field=field_flow_abatement_rating), QColor('#9ed898'), 1),
            (abatement_map_parcel_legend_pt6, '6 < "{field}" AND "{field}" <= 8'.format(
                field=field_flow_abatement_rating), QColor('#54b567'), 1),
            (abatement_map_parcel_legend_pt7, '8 < "{field}" AND "{field}" < 10'.format(
                field=field_flow_abatement_rating), QColor('#1d8641'), 1),
            (abatement_map_parcel_legend_pt8, '"{field}" = 10'.format(
                field=field_flow_abatement_rating), QColor('#00441b'), 1),
        )
        self.create_symbology(indice_ab_layer, rules)
        parcel_layer.removeSelection()

    def ecoulement_bv(self, parcel_layer, line_layer, connexion_layer, count, element, *args):
        if element == 0:
            self.abatement = self.abatement_water
            self.production = self.production_water
            self.abatement_long = self.abatement_long_water
            self.abatement_lat = self.abatement_lat_water
            history_field = field_history_water
            history_abatement_field = field_history_abatement_water
        elif element == 1:
            self.abatement = self.abatement_mes
            self.production = self.production_mes
            self.abatement_long = self.abatement_long_mes
            self.abatement_lat = self.abatement_lat_mes
            history_field = field_history_mes
            history_abatement_field = field_history_abatement_mes
        elif element == 2:
            self.abatement = self.abatement_phyto
            self.production = self.production_phyto
            self.abatement_long = self.abatement_long_phyto
            self.abatement_lat = self.abatement_lat_phyto
            history_field = field_history_phyto
            history_abatement_field = field_history_abatement_phyto
        parcelle_id_selected = []
        list_id_parcel = []

        if len(args) == 0:
            args = None
        else:
            args = [args[0][element], args[1][element], args[2][element]]

        self.prepare_layers(parcel_layer, line_layer)

        line_layer.startEditing()
        line_layer.addAttribute(QgsField(field_outlet_inflow, QVariant.Double, "double", 10, 2))
        line_layer.commitChanges()
        line_layer.triggerRepaint()

        parcel_layer.startEditing()
        parcel_layer.addAttribute(QgsField(field_flow_abatement_rating, QVariant.Int, "int", 2))
        parcel_layer.addAttribute(QgsField(field_incoming_flow_rating, QVariant.Int, "int", 2))
        for parcelle in parcel_layer.getFeatures():
            parcelle_id_selected.append(parcelle.attributes()[parcel_layer.fields().indexFromName(field_parcel_id)])
            list_id_parcel.append(parcelle.attributes()[parcel_layer.fields().indexFromName(field_parcel_id)])
            parcel_layer.changeAttributeValue(parcelle.id(), parcel_layer.fields().indexFromName(
                field_flow_abatement_rating), 99)
            parcel_layer.changeAttributeValue(parcelle.id(), parcel_layer.fields().indexFromName(
                field_incoming_flow_rating), 99)
        parcel_layer.commitChanges()
        parcel_layer.triggerRepaint()

        n = 0
        limit = parcel_layer.featureCount() + line_layer.featureCount() + 1
        list_ecoulement = order_feature(parcel_layer, line_layer, n, limit)

        processed_poly = []
        parcel_abat = []
        line_layer.startEditing()
        parcel_layer.startEditing()
        for f_id in list_ecoulement:
            id_split = int(f_id.split('_')[1])
            if f_id.split('_')[0] == 'line':  # Selection of linear element in the list of parcel and linear.
                self.line_analysis(line_layer, parcel_layer, connexion_layer, id_split, history_field,
                                   history_abatement_field)
            if f_id.split('_')[0] == 'parcel':  # Selection of parcel element in the list of parcel and linear.
                processed_poly, parcel_abat = self.parcel_analysis(line_layer, parcel_layer,
                                                                   connexion_layer,
                                                                   id_split, parcelle_id_selected,
                                                                   list_id_parcel,
                                                                   parcel_abat, processed_poly, history_field,
                                                                   history_abatement_field)
        line_layer.commitChanges()
        line_layer.triggerRepaint()
        parcel_layer.commitChanges()
        parcel_layer.triggerRepaint()
        prefix = str(count)
        parcel_layer_transfert, layer_lineaire_transfert, riviere_layer, parcel_layer_abattement, \
        layer_lineaire_abattement, max_entrant_parcelle, max_entrant_lineaire, \
        max_entrant_riviere = self.create_layers_emit(
            args, parcel_layer, line_layer, processed_poly, group_watershed_analysis + str(count),
                                                            group_abatement_analysis + "BV " + str(count),
                                                            group_flow_transfer + "BV " + str(count), prefix)
        result = {}
        select_river = QgsExpression("{champ_type} = {river}".format(champ_type=field_type_line_middle, river=river))
        for line in line_layer.getFeatures(QgsFeatureRequest(select_river)):
            dict_history = {}
            attrs = line.attributes()
            history = attrs[line_layer.fields().indexFromName(history_field)]
            flow_history = history.split("; ")
            if flow_history[0] != '':
                for elem in flow_history:
                    dict_history[elem.split(": ")[0]] = float(elem.split(": ")[1])
            history = update_flow_history(result, dict_history, 1)
            dict_history = {}
            history_abat = attrs[line_layer.fields().indexFromName(history_abatement_field)]
            flow_history = history_abat.split("; ")
            if flow_history[0] != '':
                for elem in flow_history:
                    dict_history[elem.split(": ")[0]] = float(elem.split(": ")[1])
        parcel_layer.startEditing()
        for elem in history:
            parcel_id = int(elem.split("parcelle_")[1])
            parcel = parcel_layer.getFeature(parcel_id)
            attrs = parcel.attributes()
            prod = attrs[parcel_layer.fields().indexFromName(field_flow_production)]
            area = attrs[parcel_layer.fields().indexFromName(field_parcel_area)]
            if prod != 0:
                pourcent = history[elem] / prod
                relative_prod = history[elem] / area
                total_prod = prod / area
                if 1.0011 > pourcent > 1:
                    pourcent = 1
                if 1.0011 > relative_prod > 1:
                    relative_prod = 1
                if 1.0011 > total_prod > 1:
                    total_prod = 1
            else:
                pourcent = 0
                relative_prod = 0
                total_prod = 0
            parcel_layer.changeAttributeValue(parcel_id, parcel_layer.fields().indexFromName(
                field_flow_river_rate), pourcent)
            parcel_layer.changeAttributeValue(parcel_id, parcel_layer.fields().indexFromName(
                field_flow_production_area_river), relative_prod)
            parcel_layer.changeAttributeValue(parcel_id, parcel_layer.fields().indexFromName(
                field_flow_production_area), total_prod)
        parcel_layer.commitChanges()
        parcel_layer.triggerRepaint()
        parcel_layer.selectAll()
        selection_parameters = {'INPUT': parcel_layer, 'OUTPUT': 'memory:' + "taux_de_transfert_" + prefix}
        parcel_layer_real_prod = processing.run("native:saveselectedfeatures", selection_parameters)['OUTPUT']
        selection_parameters = {
            'INPUT': parcel_layer,
            'OUTPUT': 'memory:' + "production_rceptionne_par_le_cours_d_eau_en_fonction_de_la_surface_" + prefix}
        parcel_layer_rela_prod = processing.run("native:saveselectedfeatures", selection_parameters)['OUTPUT']
        selection_parameters = {
            'INPUT': parcel_layer, 'OUTPUT': 'memory:' + "production_en_fonction_de_la_surface_" + prefix}
        parcel_layer_prod = processing.run("native:saveselectedfeatures", selection_parameters)['OUTPUT']
        selection_parameters = {'INPUT': parcel_layer, 'OUTPUT': 'memory:' + 'layer_limit_' + prefix}
        parcel_layer_limit = processing.run("native:saveselectedfeatures", selection_parameters)['OUTPUT']
        parcel_layer.removeSelection()
        QgsProject().instance().addMapLayer(parcel_layer_real_prod, False)
        group = QgsProject.instance().layerTreeRoot().findGroup(group_watershed_analysis + str(count))
        group.insertGroup(0, "Taux de transfert " + "BV " + str(count))
        group_real_prod = QgsProject.instance().layerTreeRoot().findGroup("Taux de transfert " + "BV " + str(count))
        QgsProject().instance().addMapLayer(parcel_layer_limit, False)
        group_real_prod.addLayer(parcel_layer_limit)
        rules = (
        )
        self.create_symbology(parcel_layer_limit, rules)
        group_real_prod.addLayer(parcel_layer_real_prod)
        rules = (
            (production_area_map_parcel_legend_pt1,
             '"{field_2}" = 0'.format(field_2=field_flow_production), QColor('#b4b0b0'), 1),
            (production_area_map_parcel_legend_pt2,
             '"{field}" = 0 AND "{field_2}" > 0'.format(field=field_flow_river_rate, field_2=field_flow_production),
             QColor('#ffffff'), 1),
            (production_area_map_parcel_legend_pt3,
             '0 < "{field}" AND "{field}" <= 0.25'.format(field=field_flow_river_rate), QColor('#d1e3f3'), 1),
            (production_area_map_parcel_legend_pt4,
             '0.25 < "{field}" AND "{field}" <= 0.5'.format(field=field_flow_river_rate), QColor('#9ac8e1'), 1),
            (production_area_map_parcel_legend_pt5,
             '0.5 < "{field}" AND "{field}" <= 0.75'.format(field=field_flow_river_rate), QColor('#529dcc'), 1),
            (production_area_map_parcel_legend_pt6,
             '0.75 < "{field}" AND "{field}" < 1'.format(field=field_flow_river_rate), QColor('#1c6cb1'), 1),
            (production_area_map_parcel_legend_pt7,
             '"{field}" = 1'.format(field=field_flow_river_rate), QColor('#08306b'), 1),
        )
        self.create_symbology(parcel_layer_real_prod, rules)
        QgsProject().instance().addMapLayer(parcel_layer_rela_prod, False)
        group.insertGroup(0, "Contribution des parcelles " + "BV " + str(count))
        group_rela_prod = QgsProject.instance().layerTreeRoot().findGroup(
            "Contribution des parcelles " + "BV " + str(count))
        QgsProject().instance().addMapLayer(parcel_layer_limit, False)
        group_rela_prod.addLayer(parcel_layer_limit)
        group_rela_prod.addLayer(parcel_layer_rela_prod)
        rules = (
            (production_potential_map_parcel_legend_pt1, '"{field_2}" = 0'.format(field_2=field_flow_production),
             QColor('#b4b0b0'), 1),
            (production_potential_map_parcel_legend_pt2, '"{field}" = 0 AND "{field_2}" > 0'.format(
                field=field_flow_production_area_river, field_2=field_flow_production), QColor('#1a9641'), 1),
            (production_potential_map_parcel_legend_pt3, '0 < "{field}" AND "{field}" <= 0.25'.format(
                field=field_flow_production_area_river), QColor('#8acc62'), 1),
            (production_potential_map_parcel_legend_pt4, '0.25 < "{field}" AND "{field}" <= 0.5'.format(
                field=field_flow_production_area_river), QColor('#dbf09e'), 1),
            (production_potential_map_parcel_legend_pt5, '0.5 < "{field}" AND "{field}" <= 0.75'.format(
                field=field_flow_production_area_river), QColor('#fedf9a'), 1),
            (production_potential_map_parcel_legend_pt6, '0.75 < "{field}" AND "{field}" < 1'.format(
                field=field_flow_production_area_river), QColor('#f59053'), 1),
            (production_potential_map_parcel_legend_pt7, '"{field}" = 1'.format(field=field_flow_production_area_river),
             QColor('#d7191c'), 1),
        )
        self.create_symbology(parcel_layer_rela_prod, rules)
        QgsProject().instance().addMapLayer(parcel_layer_prod, False)
        group.insertGroup(0, "Production de ruissellement des parcelles " + "BV " + str(count))
        group_prod = QgsProject.instance().layerTreeRoot().findGroup(
            "Production de ruissellement des parcelles " + "BV " + str(count))
        QgsProject().instance().addMapLayer(parcel_layer_limit, False)
        group_prod.addLayer(parcel_layer_limit)
        group_prod.addLayer(parcel_layer_prod)
        rules = (
            (production_area_map_parcel_legend_pt1, '"{field_2}" = 0'.format(
                field_2=field_flow_production), QColor('#b4b0b0'), 1),
            (production_area_map_parcel_legend_pt2, '"{field}" = 0 AND "{field_2}" > 0'.format(
                field=field_flow_production_area, field_2=field_flow_production), QColor('#1a9641'), 1),
            (production_area_map_parcel_legend_pt3, '0 < "{field}" AND "{field}" <= 0.25'.format(
                field=field_flow_production_area), QColor('#8acc62'), 1),
            (production_area_map_parcel_legend_pt4, '0.25 < "{field}" AND "{field}" <= 0.5'.format(
                field=field_flow_production_area), QColor('#dbf09e'), 1),
            (production_area_map_parcel_legend_pt5, '0.5 < "{field}" AND "{field}" <= 0.75'.format(
                field=field_flow_production_area), QColor('#fedf9a'), 1),
            (production_area_map_parcel_legend_pt6, '0.75 < "{field}" AND "{field}" < 1'.format(
                field=field_flow_production_area), QColor('#f59053'), 1),
            (production_area_map_parcel_legend_pt7, '"{field}" = 1'.format(
                field=field_flow_production_area), QColor('#d7191c'), 1),
        )
        self.create_symbology(parcel_layer_prod, rules)
        return [parcel_layer_transfert, layer_lineaire_transfert, riviere_layer, parcel_layer_abattement,
                layer_lineaire_abattement, max_entrant_parcelle, max_entrant_lineaire, max_entrant_riviere]

    def ecoulement_emis(self, parcel_layer, line_layer, connexion_layer, count, element):
        if element == 0:
            self.abatement = self.abatement_water
            self.production = self.production_water
            self.abatement_long = self.abatement_long_water
            self.abatement_lat = self.abatement_lat_water
            history_field = field_history_water
            history_abatement_field = field_history_abatement_water
        elif element == 1:
            self.abatement = self.abatement_mes
            self.production = self.production_mes
            self.abatement_long = self.abatement_long_mes
            self.abatement_lat = self.abatement_lat_mes
            history_field = field_history_mes
            history_abatement_field = field_history_abatement_mes
        elif element == 2:
            self.abatement = self.abatement_phyto
            self.production = self.production_phyto
            self.abatement_long = self.abatement_long_phyto
            self.abatement_lat = self.abatement_lat_phyto
            history_field = field_history_phyto
            history_abatement_field = field_history_abatement_phyto
        parcelle_id_selected = [parcel_layer.selectedFeatures()[0].attributes()[
                                    parcel_layer.fields().indexFromName(field_parcel_id)]]
        args = None
        self.prepare_layers(parcel_layer, line_layer)

        line_layer.startEditing()
        line_layer.addAttribute(QgsField(field_outlet_inflow, QVariant.Double, "double", 10, 2))
        line_layer.commitChanges()
        line_layer.triggerRepaint()

        parcel_layer.startEditing()
        parcel_layer.addAttribute(QgsField(field_parcel_rating, QVariant.Int, "int", 2))
        parcel_layer.addAttribute(QgsField(field_feature_selected, QVariant.Int, "int", 1))
        parcel_layer.changeAttributeValue(parcelle_id_selected[0], parcel_layer.fields().indexFromName(
            field_feature_selected), 1)
        for parcelle in parcel_layer.getFeatures():
            parcel_layer.changeAttributeValue(parcelle.id(), parcel_layer.fields().indexFromName(
                field_parcel_rating), 99)
        parcel_layer.commitChanges()
        parcel_layer.triggerRepaint()

        list_id_parcelle = [parcel_layer.selectedFeatures()[0].attributes()[
                                parcel_layer.fields().indexFromName(field_parcel_id)]]
        selection = [str(parcel_layer.selectedFeatures()[0].id())]
        if parcel_layer.selectedFeatures()[0].attributes()[parcel_layer.fields().indexFromName(field_type_parcel)] in self.production_type:
            while len(selection) > 0:
                for selected_feature in selection:
                    selection.remove(selected_feature)
                    f = parcel_layer.getFeature(int(selected_feature))
                    attrs = f.attributes()
                    parcel_id = attrs[parcel_layer.fields().indexFromName(field_parcel_id)]
                    select_connexion = QgsExpression("{field_connexions_parcel_above} = '{id}'".format(
                        field_connexions_parcel_above=field_connexions_parcel_above, id=parcel_id))
                    for feat in connexion_layer.getFeatures(QgsFeatureRequest(select_connexion)):
                        attrs = feat.attributes()
                        uh_dwn = attrs[
                            connexion_layer.fields().indexFromName(field_connexions_parcel_below)]
                        if uh_dwn != NULL:
                            if uh_dwn not in list_id_parcelle:
                                list_id_parcelle.append(uh_dwn)
                                selection.append(uh_dwn)
        parcel_layer.startEditing()
        for parcel_id in list_id_parcelle:
            parcel_layer.changeAttributeValue(parcel_id,
                                              parcel_layer.fields().indexFromName(field_incoming_flow),
                                              0)
        parcel_layer.commitChanges()
        parcel_layer.triggerRepaint()

        n = parcel_layer.selectedFeatures()[0].attributes()[
            parcel_layer.fields().indexFromName(field_order)]
        limit = parcel_layer.featureCount() + line_layer.featureCount() + 1
        list_ecoulement = order_feature(parcel_layer, line_layer, n, limit)
        processed_poly = []
        parcel_abat = []
        line_layer.startEditing()
        parcel_layer.startEditing()
        for f_id in list_ecoulement:
            id_split = int(f_id.split('_')[1])
            if f_id.split('_')[0] == 'line':  # Selection of linear element in the list of parcel and linear.
                self.line_analysis(line_layer, parcel_layer, connexion_layer, id_split, history_field,
                                   history_abatement_field)
            if f_id.split('_')[0] == 'parcel':  # Selection of parcel element in the list of parcel and linear.
                processed_poly, parcel_abat = self.parcel_analysis(line_layer, parcel_layer,
                                                                   connexion_layer,
                                                                   id_split, parcelle_id_selected,
                                                                   list_id_parcelle,
                                                                   parcel_abat, processed_poly, history_field,
                                                                   history_abatement_field)
        line_layer.commitChanges()
        line_layer.triggerRepaint()
        parcel_layer.commitChanges()
        parcel_layer.triggerRepaint()

        prefix = str(count) + '_' + str(parcelle_id_selected[0])
        parcel_layer_transfert, layer_lineaire_transfert, riviere_layer, parcel_layer_abattement, \
        layer_lineaire_abattement, max_entrant_parcelle, max_entrant_lineaire, \
        max_entrant_riviere = self.create_layers_emit(
            args, parcel_layer, line_layer, processed_poly,
            group_outgoing_flow_parcel + str(count) + " " + str(parcelle_id_selected[0]),
            group_abatement_analysis + str(count) + ' ' + str(parcelle_id_selected[0]),
            group_flow_transfer + str(count) + ' ' + str(parcelle_id_selected[0]), prefix)
        return parcel_layer_transfert, layer_lineaire_transfert, riviere_layer, parcel_layer_abattement, \
               layer_lineaire_abattement

    def ecoulement_recu(self, parcel_layer, line_layer, connexion_layer, count, element, quick_value):
        if element == 0:
            self.abatement = self.abatement_water
            self.production = self.production_water
            self.abatement_long = self.abatement_long_water
            self.abatement_lat = self.abatement_lat_water
            history_field = field_history_water
            history_abatement_field = field_history_abatement_water
        elif element == 1:
            self.abatement = self.abatement_mes
            self.production = self.production_mes
            self.abatement_long = self.abatement_long_mes
            self.abatement_lat = self.abatement_lat_mes
            history_field = field_history_mes
            history_abatement_field = field_history_abatement_mes
        elif element == 2:
            self.abatement = self.abatement_phyto
            self.production = self.production_phyto
            self.abatement_long = self.abatement_long_phyto
            self.abatement_lat = self.abatement_lat_phyto
            history_field = field_history_phyto
            history_abatement_field = field_history_abatement_phyto
        parcelle_id_select = parcel_layer.selectedFeatures()[0].attributes()[
            parcel_layer.fields().indexFromName(field_parcel_id)]
        limit = parcel_layer.selectedFeatures()[0].attributes()[
                    parcel_layer.fields().indexFromName(field_order)] + 1
        parcel_layer.removeSelection()
        if not quick_value:
            self.prepare_layers(parcel_layer, line_layer)

        parcelle_id_selected = []
        list_id_parcel = []
        for parcelle in parcel_layer.getFeatures():
            parcel_layer.changeAttributeValue(
                parcelle.id(), parcel_layer.fields().indexFromName(field_flow_production_rating), 99)
            parcel_layer.changeAttributeValue(
                parcelle.id(), parcel_layer.fields().indexFromName(field_flow_abatement_rating),
                999)
            parcelle_id_selected.append(parcelle.attributes()[parcel_layer.fields().indexFromName(field_parcel_id)])
            list_id_parcel.append(parcelle.attributes()[parcel_layer.fields().indexFromName(field_parcel_id)])
        n = 0
        list_ecoulement = order_feature(parcel_layer, line_layer, n, limit)
        if not quick_value:
            processed_poly = []
            parcel_abat = []
            line_layer.startEditing()
            parcel_layer.startEditing()
            for f_id in list_ecoulement:
                id_split = int(f_id.split('_')[1])
                if f_id.split('_')[0] == 'line':  # Selection of linear element in the list of parcel and linear.
                    self.line_analysis(line_layer, parcel_layer, connexion_layer, id_split, history_field,
                                       history_abatement_field)
                if f_id.split('_')[0] == 'parcel':  # Selection of parcel element in the list of parcel and linear.
                    processed_poly, parcel_abat = self.parcel_analysis(line_layer, parcel_layer,
                                                                       connexion_layer,
                                                                       id_split, parcelle_id_selected,
                                                                       list_id_parcel,
                                                                       parcel_abat, processed_poly, history_field,
                                                                       history_abatement_field)
            line_layer.commitChanges()
            line_layer.triggerRepaint()
            parcel_layer.commitChanges()
            parcel_layer.triggerRepaint()

        line_layer.startEditing()
        if line_layer.fields().indexFromName(field_flow_abatement_rating) != -1:
            line_layer.deleteAttribute(line_layer.fields().indexFromName(field_outlet_inflow))
            line_layer.deleteAttribute(
                line_layer.fields().indexFromName(field_flow_abatement_rating))
            line_layer.deleteAttribute(line_layer.fields().indexFromName(field_flow_abatement))
        line_layer.addAttribute(QgsField(field_outlet_inflow, QVariant.Double, "double", 10, 2))
        line_layer.addAttribute(QgsField(field_flow_abatement_rating, QVariant.Int, "int", 3))
        line_layer.addAttribute(QgsField(field_flow_abatement, QVariant.Double, "double", 10, 2))
        line_layer.commitChanges()
        line_layer.triggerRepaint()

        parcel_layer.startEditing()
        parcel_layer.deleteAttribute(
            parcel_layer.fields().indexFromName(field_flow_production_relative))
        parcel_layer.deleteAttribute(
            parcel_layer.fields().indexFromName(field_flow_production_rating))
        parcel_layer.deleteAttribute(
            parcel_layer.fields().indexFromName(field_flow_abatement_rating))
        parcel_layer.deleteAttribute(parcel_layer.fields().indexFromName(field_feature_selected))
        parcel_layer.deleteAttribute(parcel_layer.fields().indexFromName(field_flow_abatement))
        parcel_layer.commitChanges()
        parcel_layer.triggerRepaint()

        parcel_layer.startEditing()
        parcel_layer.addAttribute(
            QgsField(field_flow_production_relative, QVariant.Double, "double", 5, 2))
        parcel_layer.addAttribute(QgsField(field_flow_production_rating, QVariant.Int, "int", 2))
        parcel_layer.addAttribute(QgsField(field_flow_abatement_rating, QVariant.Int, "int", 2))
        parcel_layer.addAttribute(QgsField(field_feature_selected, QVariant.Int, "int", 1))
        parcel_layer.addAttribute(QgsField(field_flow_abatement, QVariant.Double, "double", 10, 2))
        parcel_layer.changeAttributeValue(parcelle_id_select, parcel_layer.fields().indexFromName(
            field_feature_selected), 1)
        parcel_layer.commitChanges()
        parcel_layer.triggerRepaint()

        list_parcel_id = []
        attrs = parcel_layer.getFeature(parcelle_id_select).attributes()
        dict_history = {}
        if attrs[parcel_layer.fields().indexFromName(history_field)] != NULL:
            flow_history = (attrs[parcel_layer.fields().indexFromName(history_field)]).split("; ")
            if flow_history[0] != '':
                for elem in flow_history:
                    dict_history[elem.split(": ")[0]] = float(elem.split(": ")[1])
        dict_history_abat = {}
        if attrs[parcel_layer.fields().indexFromName(history_abatement_field)] != NULL:
            flow_history_abat = (attrs[parcel_layer.fields().indexFromName(history_abatement_field)]).split("; ")
            if flow_history_abat[0] != '':
                for elem in flow_history_abat:
                    dict_history_abat[elem.split(": ")[0]] = float(elem.split(": ")[1])
        parcel_layer.startEditing()
        line_layer.startEditing()
        abatement_total_p = 0
        abatement_total_l = 0
        intrant_total = 0
        for elem in dict_history_abat:
            new_attributes = {}
            if elem.split("_")[0] == "parcelle":
                layer = parcel_layer
                abatement = dict_history_abat[elem]
                feature = int(elem.split("_")[1])
                new_attributes[field_flow_abatement] = abatement
                if feature not in list_parcel_id:
                    list_parcel_id.append(feature)
                abatement_total_p = abatement_total_p + abatement
            elif elem.split("_")[0] == "line":
                layer = line_layer
                abatement = dict_history_abat[elem]
                feature = int(elem.split("_")[1])
                new_attributes[field_flow_abatement] = abatement
                abatement_total_l = abatement_total_l + abatement
            self.save_attributes(layer, feature, new_attributes)
        for elem in dict_history:
            new_attributes = {}
            layer = parcel_layer
            intrant = dict_history[elem]
            feature = int(elem.split("_")[1])
            if feature not in list_parcel_id:
                list_parcel_id.append(feature)
            new_attributes[field_flow_production_relative] = intrant
            intrant_total = intrant_total + intrant
            self.save_attributes(layer, feature, new_attributes)
        parcel_layer.commitChanges()
        parcel_layer.triggerRepaint()
        line_layer.commitChanges()
        line_layer.triggerRepaint()
        prefix = str(count) + '_' + str(parcelle_id_select)
        group_name_1 = group_incoming_flow_parcel + prefix
        self.create_layers_received(parcel_layer, line_layer, intrant_total, abatement_total_p,
                                    list_parcel_id, group_name_1, prefix)

    def ecoulement_riviere(self, parcel_layer, line_layer, connexion_layer, count, count_riviere, element, quick_value):
        if element == 0:
            self.abatement = self.abatement_water
            self.production = self.production_water
            self.abatement_long = self.abatement_long_water
            self.abatement_lat = self.abatement_lat_water
            history_field = field_history_water
            history_abatement_field = field_history_abatement_water
        elif element == 1:
            self.abatement = self.abatement_mes
            self.production = self.production_mes
            self.abatement_long = self.abatement_long_mes
            self.abatement_lat = self.abatement_lat_mes
            history_field = field_history_mes
            history_abatement_field = field_history_abatement_mes
        elif element == 2:
            self.abatement = self.abatement_phyto
            self.production = self.production_phyto
            self.abatement_long = self.abatement_long_phyto
            self.abatement_lat = self.abatement_lat_phyto
            history_field = field_history_phyto
            history_abatement_field = field_history_abatement_phyto
        riviere_id_selected = line_layer.selectedFeatureIds()[0]
        list_limit = []
        connexion_layer.selectByExpression(
            "{champ_riviere_aval} = '{id_troncon}' ".format(
                champ_riviere_aval=field_connexions_river_below, id_troncon=riviere_id_selected))
        for connexion in connexion_layer.selectedFeatures():
            attrs = connexion.attributes()
            uh_up = attrs[connexion_layer.fields().indexFromName(field_connexions_parcel_above)]
            list_limit.append(parcel_layer.getFeature(uh_up).attributes()[
                                  parcel_layer.fields().indexFromName(field_order)])
        limit = max(list_limit) + 1
        if not quick_value:
            self.prepare_layers(parcel_layer, line_layer)

        parcelle_id_selected = []
        list_id_parcel = []
        parcel_layer.startEditing()
        for parcelle in parcel_layer.getFeatures():
            parcel_layer.changeAttributeValue(
                parcelle.id(), parcel_layer.fields().indexFromName(field_flow_production_rating), 99)
            parcel_layer.changeAttributeValue(
                parcelle.id(), parcel_layer.fields().indexFromName(field_flow_abatement_rating),
                999)
            parcelle_id_selected.append(parcelle.attributes()[
                                            parcel_layer.fields().indexFromName(
                                                field_parcel_id)])
            list_id_parcel.append(parcelle.attributes()[
                                      parcel_layer.fields().indexFromName(field_parcel_id)])
        parcel_layer.commitChanges()
        parcel_layer.triggerRepaint()
        n = 0
        list_ecoulement = order_feature(parcel_layer, line_layer, n, limit)
        list_ecoulement.append('line_' + str(riviere_id_selected))
        if not quick_value:
            processed_poly = []
            parcel_abat = []
            line_layer.startEditing()
            parcel_layer.startEditing()
            for f_id in list_ecoulement:
                id_split = int(f_id.split('_')[1])
                if f_id.split('_')[0] == 'line':  # Selection of linear element in the list of parcel and linear.
                    self.line_analysis(
                        line_layer, parcel_layer, connexion_layer, id_split, history_field, history_abatement_field)
                if f_id.split('_')[0] == 'parcel':  # Selection of parcel element in the list of parcel and linear.
                    processed_poly, parcel_abat = self.parcel_analysis(line_layer, parcel_layer,
                                                                       connexion_layer,
                                                                       id_split, parcelle_id_selected,
                                                                       list_id_parcel,
                                                                       parcel_abat, processed_poly, history_field,
                                                                       history_abatement_field)
            line_layer.commitChanges()
            line_layer.triggerRepaint()
            parcel_layer.commitChanges()
            parcel_layer.triggerRepaint()

        line_layer.startEditing()
        line_layer.deleteAttribute(line_layer.fields().indexFromName(field_feature_selected))
        line_layer.commitChanges()
        line_layer.triggerRepaint()

        line_layer.startEditing()
        if line_layer.fields().indexFromName(field_flow_abatement_rating) != -1:
            line_layer.deleteAttribute(line_layer.fields().indexFromName(field_outlet_inflow))
            line_layer.deleteAttribute(
                line_layer.fields().indexFromName(field_feature_selected))
            line_layer.deleteAttribute(
                line_layer.fields().indexFromName(field_flow_abatement_rating))
            line_layer.deleteAttribute(line_layer.fields().indexFromName(field_flow_abatement))
        line_layer.addAttribute(QgsField(field_outlet_inflow, QVariant.Double, "double", 10, 2))
        line_layer.addAttribute(QgsField(field_feature_selected, QVariant.Int, "int", 1))
        line_layer.addAttribute(QgsField(field_flow_abatement_rating, QVariant.Int, "int", 3))
        line_layer.addAttribute(QgsField(field_flow_abatement, QVariant.Double, "double", 10, 2))
        line_layer.changeAttributeValue(riviere_id_selected, line_layer.fields().indexFromName(
            field_feature_selected), 1)
        line_layer.commitChanges()
        line_layer.triggerRepaint()

        parcel_layer.startEditing()
        parcel_layer.deleteAttribute(
            parcel_layer.fields().indexFromName(field_flow_production_relative))
        parcel_layer.deleteAttribute(
            parcel_layer.fields().indexFromName(field_flow_production_rating))
        parcel_layer.deleteAttribute(
            parcel_layer.fields().indexFromName(field_flow_abatement_rating))
        parcel_layer.deleteAttribute(parcel_layer.fields().indexFromName(field_feature_selected))
        parcel_layer.deleteAttribute(parcel_layer.fields().indexFromName(field_flow_abatement))
        parcel_layer.commitChanges()
        parcel_layer.triggerRepaint()

        parcel_layer.startEditing()
        parcel_layer.addAttribute(
            QgsField(field_flow_production_relative, QVariant.Double, "double", 5, 2))
        parcel_layer.addAttribute(QgsField(field_flow_abatement, QVariant.Double, "double", 10, 2))
        parcel_layer.addAttribute(QgsField(field_flow_production_rating, QVariant.Int, "int", 2))
        parcel_layer.addAttribute(QgsField(field_flow_abatement_rating, QVariant.Int, "int", 2))
        parcel_layer.commitChanges()
        parcel_layer.triggerRepaint()

        list_parcel_id = []
        attrs = line_layer.getFeature(riviere_id_selected).attributes()
        dict_history = {}
        if attrs[line_layer.fields().indexFromName(history_field)] != NULL:
            flow_history = (attrs[line_layer.fields().indexFromName(history_field)]).split("; ")
            if flow_history[0] != '':
                for elem in flow_history:
                    dict_history[elem.split(": ")[0]] = float(elem.split(": ")[1])
        dict_history_abat = {}
        if attrs[line_layer.fields().indexFromName(history_abatement_field)] != NULL:
            flow_history = (attrs[line_layer.fields().indexFromName(history_abatement_field)]).split("; ")
            if flow_history[0] != '':
                for elem in flow_history:
                    dict_history_abat[elem.split(": ")[0]] = float(elem.split(": ")[1])
        parcel_layer.startEditing()
        line_layer.startEditing()
        abatement_total_p = 0
        abatement_total_l = 0
        intrant_total = 0
        for elem in dict_history_abat:
            new_attributes = {}
            if elem.split("_")[0] == "parcelle":
                layer = parcel_layer
                abatement = dict_history_abat[elem]
                feature = int(elem.split("_")[1])
                new_attributes[field_flow_abatement] = abatement
                if feature not in list_parcel_id:
                    list_parcel_id.append(feature)
                abatement_total_p = abatement_total_p + abatement
            else:
                layer = line_layer
                abatement = dict_history_abat[elem]
                feature = int(elem.split("_")[1])
                new_attributes[field_flow_abatement] = abatement
                abatement_total_l = abatement_total_l + abatement
            self.save_attributes(layer, feature, new_attributes)
        for elem in dict_history:
            new_attributes = {}
            layer = parcel_layer
            intrant = dict_history[elem]
            feature = int(elem.split("_")[1])
            if feature not in list_parcel_id:
                list_parcel_id.append(feature)
            new_attributes[field_flow_production_relative] = intrant
            intrant_total = intrant_total + intrant
            self.save_attributes(layer, feature, new_attributes)
        parcel_layer.commitChanges()
        parcel_layer.triggerRepaint()
        line_layer.commitChanges()
        line_layer.triggerRepaint()
        prefix = str(count) + "_" + str(count_riviere)
        group_name_1 = group_incoming_flow_river + prefix
        self.create_layers_received(parcel_layer, line_layer, intrant_total, abatement_total_p, list_parcel_id,
                                    group_name_1, prefix)
