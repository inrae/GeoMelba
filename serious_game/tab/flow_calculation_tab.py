# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeomelbaSpirit
                                 A QGIS plugin
 Based on GeoMelba software, meant to be used with the serious game CAUSERIE.
 This file contains the functions to use when the user configure the dock widget.
 Buttons and widget of the dock widget are controlled with functions from this file.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-08-24
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Jules Grillot / INRAE
        email                : jules.grillot@inrae.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import csv
import os
import processing
from PyQt5.QtCore import QUrl, QSize
from qgis.PyQt.QtWidgets import QPushButton, QButtonGroup, QLabel, QDialog, QTextBrowser
from qgis.core import QgsVectorLayer, QgsLineSymbol, QgsSingleSymbolRenderer

from .tab_management import TabManagement
from .result_viewer.map_viewer import MapViewer
from .result_viewer.result_viewer import ResultViewer
from .interface_tools.buttonpointer import ButtonPointer
from .result_viewer.map_creation import MapCreation
from .hydrological_model.indices_calculation import FlowCalculation
from .hydrological_model.history import after_watershed_analysis
from ...dictionnaire import infos_tab_calcul_edit, style_parcel, date_m_y, author, history_table_name, \
    history_field_action, history_field_layer, history_field_feature, history_field_field, history_field_field_idx, \
    history_field_previous, history_field_next, group_watershed_analysis, group_flow_transfer, \
    parcel_abatement_layer_name, line_abatement_layer_name, river_incoming_flow_layer_name, \
    parcel_transfer_layer_name, line_transfer_layer_name, field_incoming_flow, owner_cover_layer_name, \
    group_outgoing_flow_parcel, parcel_contribution_layer_name, field_flow_production_rating, \
    field_flow_abatement_rating, field_flow_abatement, river_selection_layer_name, group_incoming_flow_river, \
    style_river_selection, group_incoming_flow_parcel, map_watershed_land_cover, map_watershed_abatement, \
    map_watershed_transfer, map_watershed_transfer_rate, map_watershed_potential_production, \
    map_watershed_production_area, map_parcel_abatement, map_parcel_transfer, map_parcel_received, map_river_received, \
    field_type_line_middle, regular_font, river, data_folder, watershed_prefix, flow_calculation_tab_name, \
    loader_title, loader_text, watershed_analysis_button_name, save_value_button_name, select_parcel_button_name, \
    parcel_emit_analysis_button_name, parcel_reception_analysis_button_name, river_reception_analysis_button_name, \
    select_river_button_name, start_comparison_button_name, open_result_viewer_button_name, studied_elements, coded_studied_elements,\
    land_cover_map_title, land_cover_map_parcel, land_cover_map_line, watershed_abatement_map_title_pt1, \
    watershed_abatement_map_title_pt2, watershed_abatement_map_parcel_pt1, watershed_abatement_map_parcel_pt2, \
    watershed_abatement_map_line_pt1, watershed_abatement_map_line_pt2, watershed_transfer_map_title_pt1, \
    watershed_transfer_map_title_pt2, watershed_transfer_map_parcel_pt1, watershed_transfer_map_parcel_pt2, \
    watershed_transfer_map_line_pt1, watershed_transfer_map_line_pt2, watershed_transfer_map_river_pt1, \
    watershed_transfer_map_river_pt2, watershed_transfer_rate_map_title_pt1, watershed_transfer_rate_map_title_pt2, \
    watershed_transfer_rate_map_parcel_pt1, watershed_transfer_rate_map_parcel_pt2, watershed_transfer_rate_map_river, \
    watershed_production_potential_map_title_pt1, watershed_production_potential_map_title_pt2, \
    watershed_production_potential_map_parcel_pt1, watershed_production_potential_map_parcel_pt2, \
    watershed_production_potential_map_river, watershed_production_area_map_title_pt1, \
    watershed_production_area_map_title_pt2, watershed_production_area_map_parcel_pt1, \
    watershed_production_area_map_parcel_pt2, watershed_production_area_map_river, parcel_abatement_map_title_pt1, \
    parcel_abatement_map_title_pt2, parcel_abatement_map_parcel_pt1, parcel_abatement_map_parcel_pt2, \
    parcel_abatement_map_line_pt1, parcel_abatement_map_line_pt2, parcel_transfer_map_title_pt1, \
    parcel_transfer_map_title_pt2, parcel_transfer_map_parcel_pt1, parcel_transfer_map_parcel_pt2, \
    parcel_transfer_map_line_pt1, parcel_transfer_map_line_pt2, parcel_transfer_map_river_pt1, \
    parcel_transfer_map_river_pt2, parcel_reception_map_title, parcel_reception_map_parcel_production, \
    parcel_reception_map_parcel_abatement, parcel_reception_map_line, parcel_reception_map_river, \
    river_reception_map_title, river_reception_map_parcel_production, river_reception_map_parcel_abatement, \
    river_reception_map_line, river_reception_map_river


class FlowCalculationTab(TabManagement):

    def __init__(self, parent=None, canvas=None, production_type=None, practices=None, slope=None, land_cover=None,
                 abatement_type=None, abatement=None, abatement_water=None, abatement_mes=None, abatement_phyto=None,
                 production=None, production_water=None, production_mes=None, production_phyto=None, line_type=None,
                 abatement_type_long=None, abatement_type_lat=None, abatement_long=None, abatement_long_water=None,
                 abatement_long_mes=None, abatement_long_phyto=None, abatement_lat=None, abatement_lat_water=None,
                 abatement_lat_mes=None, abatement_lat_phyto=None, output_path=None, connexion_layer=None,
                 button_rollback=None, plot_creation=None):
        """Concern the tab creation of flow analysis :
        - 9 buttons to do analysis, select element or compare result.

        Every function connected to the signals emitted by the buttons. To launch analysis, save result, open the
        result dialog or the comparison dialog.
        """
        super().__init__(tab_widget=parent.tab_widget, project=parent.project, path=parent.path,
                         parcel_layer=parent.parcel_layer, line_layer=parent.line_layer,
                         watershed_name=parent.watershed_name, style_line_layer=parent.style_line_layer, crs=parent.crs)

        self.canvas = canvas
        self.production_type = production_type
        self.output_path = output_path
        self.connexion_layer = connexion_layer
        self.button_rollback = button_rollback
        self.plot_creation = plot_creation
        self.tab_widget.setTabText(self._tab_index_abatement, flow_calculation_tab_name)

        # Counter variables
        self.count_referential = 0  # Test if values after a abatement analysis on the watershed are already saved.
        self.count_runoff_received_analysis = 0  # Count the number of made analysis on runoff received by a parcel.
        self.count_runoff_emitted_analysis = 0  # Count the number of made analysis on runoff emitted by a parcel.
        self.count_runoff_river_section_analysis = 0  # Count the number of made analysis on runoff received by a
        # river section.

        # Loader variables
        self.messagebox = QDialog()
        self.messagebox.setWindowTitle(loader_title)
        self.label = QLabel(self.messagebox)
        self.label.setText(loader_text)
        self.label.resize(QSize(500, 500))
        self.label.move(100, 60)

        # List use to store the values saved.
        self._referential_ = []
        self.max_input_parcel = 0
        self.max_input_line = 0
        self.max_input_river_section = 0
        self.val_river_section_t0 = 0

        self.signal_stop = 0
        # Object use for the comparison.
        self.map_viewer = MapViewer()
        self.map_viewer.init_map_viewer(self)
        # Creation of the interface.
        self.init_calculation_tab()
        # Help text at the bottom of the tab.
        text_calcul = QTextBrowser(self.tab_widget.widget(self._tab_index_abatement))
        text_calcul.setGeometry(10, 430, 610, 330)
        text_calcul.setSource(QUrl.fromLocalFile(infos_tab_calcul_edit))
        # Object use to realize different analysis.
        self.flow_calculation = FlowCalculation(watershed_name=self.watershed_name, practices=practices,
                                                slope=slope, land_cover=land_cover,
                                                abatement_type=abatement_type, abatement=abatement,
                                                abatement_water=abatement_water, abatement_mes=abatement_mes,
                                                abatement_phyto=abatement_phyto, production_type=self.production_type,
                                                production=production,
                                                production_water=production_water,
                                                production_mes=production_mes,
                                                production_phyto=production_phyto,
                                                line_type=line_type, abatement_type_long=abatement_type_long,
                                                abatement_type_lat=abatement_type_lat,
                                                abatement_long=abatement_long,
                                                abatement_long_water=abatement_long_water,
                                                abatement_long_mes=abatement_long_mes,
                                                abatement_long_phyto=abatement_long_phyto,
                                                abatement_lat=abatement_lat,
                                                abatement_lat_water=abatement_lat_water,
                                                abatement_lat_mes=abatement_lat_mes,
                                                abatement_lat_phyto=abatement_lat_phyto, )
        # Object use to create maps.
        self.map_creation = MapCreation()

    @property
    def referential(self) -> list:
        return self._referential_

    def init_calculation_tab(self):
        """Place the buttons on the abatement tab.

        Creation of 9 buttons.
        """
        button_group = QButtonGroup()
        # Creation of the button for the abatement analysis on the watershed.
        button_watershed_analysis = QPushButton(self.tab_widget.widget(self._tab_index_abatement))
        button_watershed_analysis.setText(watershed_analysis_button_name)
        button_watershed_analysis.setGeometry(20, 30, 600, 30)
        button_watershed_analysis.setEnabled(True)
        button_watershed_analysis.setFont(regular_font)
        button_group.addButton(button_watershed_analysis)
        # Function connected to the signal emitted by the button.
        button_watershed_analysis.clicked.connect(self.analysis_watershed)
        # Creation of the button to save some values of the last analysis as reference.
        self.button_save_value = QPushButton(self.tab_widget.widget(self._tab_index_abatement))
        self.button_save_value.setText(save_value_button_name)
        self.button_save_value.setGeometry(20, 70, 600, 30)
        self.button_save_value.setEnabled(False)
        self.button_save_value.setFont(regular_font)
        button_group.addButton(self.button_save_value)
        # Function connected to the signal emitted by the button.
        self.button_save_value.clicked.connect(self.saving_values)
        # Creation of the button to select a parcel.
        self.button_select_parcel = ButtonPointer(self.tab_widget.widget(self._tab_index_abatement))
        self.button_select_parcel.setText(select_parcel_button_name)
        self.button_select_parcel.setAccessibleName("select")
        self.button_select_parcel.setGeometry(20, 110, 600, 30)
        self.button_select_parcel.setEnabled(False)
        self.button_select_parcel.setFont(regular_font)
        button_group.addButton(self.button_select_parcel)
        self.button_select_parcel.on_click(self.button_select_parcel, self.canvas, self.parcel_layer.sourceCrs(),
                                           self.parcel_layer, "none",
                                           "none")  # Function form ButtonPointer to select a feature.
        # Creation of the button to calculate runoff emitted by the selected parcel.
        self.button_parcel_emit = QPushButton(self.tab_widget.widget(self._tab_index_abatement))
        self.button_parcel_emit.setText(parcel_emit_analysis_button_name)
        self.button_parcel_emit.setGeometry(20, 150, 600, 30)
        self.button_parcel_emit.setEnabled(False)
        self.button_parcel_emit.setFont(regular_font)
        button_group.addButton(self.button_parcel_emit)
        # Function connected to the signal emitted by the button.
        self.button_parcel_emit.clicked.connect(self.analysis_parcel_runoff_emit)
        # Creation of the button to calculate runoff received by the selected parcel.
        self.button_parcel_reception = QPushButton(self.tab_widget.widget(self._tab_index_abatement))
        self.button_parcel_reception.setText(parcel_reception_analysis_button_name)
        self.button_parcel_reception.setGeometry(20, 190, 600, 30)
        self.button_parcel_reception.setEnabled(False)
        self.button_parcel_reception.setFont(regular_font)
        button_group.addButton(self.button_parcel_reception)
        # Function connected to the signal emitted by the button.
        self.button_parcel_reception.clicked.connect(self.analysis_parcel_runoff_reception)
        # Creation of the button to select a river section.
        self.button_select_river_section = ButtonPointer(self.tab_widget.widget(self._tab_index_abatement))
        self.button_select_river_section.setText(select_river_button_name)
        self.button_select_river_section.setAccessibleName("select")
        self.button_select_river_section.setGeometry(20, 230, 600, 30)
        self.button_select_river_section.setEnabled(False)
        self.button_select_river_section.setFont(regular_font)
        button_group.addButton(self.button_select_river_section)
        self.button_select_river_section.on_click(self.button_select_river_section, self.canvas,
                                                  self.line_layer.sourceCrs(),
                                                  self.line_layer, "none",
                                                  "none")  # Function form ButtonPointer to select a feature.

        # Creation of the button to calculate runoff received by the selected river section.
        self.button_river_reception = QPushButton(self.tab_widget.widget(self._tab_index_abatement))
        self.button_river_reception.setText(river_reception_analysis_button_name)
        self.button_river_reception.setGeometry(20, 270, 600, 30)
        self.button_river_reception.setEnabled(False)
        self.button_river_reception.setFont(regular_font)
        button_group.addButton(self.button_river_reception)
        # Function connected to the signal emitted by the button.
        self.button_river_reception.clicked.connect(self.analysis_river_section_runoff_reception)
        # Creation of the button to compare the abatement analysis on the watershed.
        self.button_comparison = QPushButton(self.tab_widget.widget(self._tab_index_abatement))
        self.button_comparison.setText(start_comparison_button_name)
        self.button_comparison.setGeometry(20, 310, 600, 30)
        self.button_comparison.setEnabled(False)
        self.button_comparison.setFont(regular_font)
        button_group.addButton(self.button_comparison)
        self.button_comparison.clicked.connect(
            self.map_viewer.open_map_viewer)  # Function connected to the signal emitted by the button.
        # Creation of the button to show the different map results.
        self.button_result_viewer = QPushButton(self.tab_widget.widget(self._tab_index_abatement))
        self.button_result_viewer.setText(open_result_viewer_button_name)
        self.button_result_viewer.setGeometry(20, 350, 600, 70)
        self.button_result_viewer.setEnabled(False)
        self.button_result_viewer.setFont(regular_font)
        button_group.addButton(self.button_result_viewer)
        # Function connected to the signal emitted by the button.
        self.button_result_viewer.clicked.connect(self.open_result_viewer)

    def open_result_viewer(self):
        """Open the dialog to show the result of analysis.
        """
        self.result_viewer = ResultViewer(directory_path=self.output_path, count_turn=self.count_watershed_analysis,
                                          line_layer=self.line_layer, parcel_layer=self.parcel_layer, crs=self.crs)
        self.result_viewer.open_result_viewer()

    def return_signal(self):
        """Return the value of the variable used to know if the changes made in layers need to be written.
        """
        return self.signal_stop

    # Functions to launch abatement analysis
    def analysis_watershed(self):
        """ Launch the analysis on the whole watershed. If it exists, the cover layer will be removed. A map of the land
        cover and line type will be created. Then the analysis will be launched. A new empty csv history is created.
        2 maps are created with one analysis on the inflow in the watershed and one analysis on the abatement. Finally,
        the plot are updated with the new values from the analysis.
        """
        for element in os.listdir(self.output_path):
            if element.replace(".jpg", "").split("_", -1)[-1] == str(self.count_watershed_analysis + 1):
                os.remove(self.output_path + element)
        # The count of turn is increased.
        self.new_watershed_analysis()
        # The signal for saving changes in the history CSV is stopped.
        self.signal_stop = 1
        self._referential_ = []
        # self.bug_correction()
        # Creation of the map of land cover and line type. The layers needs to be the only one on display.
        for group in self.project.layerTreeRoot().children():
            if self.project.layerTreeRoot().isGroup(group):
                self.project.layerTreeRoot().findGroup(group.name()).setItemVisibilityChecked(False)
                self.project.layerTreeRoot().findGroup(group.name()).setExpanded(0)
            elif group.name() != self.line_layer.name() and group.name() != self.parcel_layer.name():
                layer = self.project.mapLayersByName(group.name())[0]
                self.project.layerTreeRoot().findLayer(layer.id()).setItemVisibilityChecked(False)
                self.project.layerTreeRoot().findLayer(layer.id()).setExpanded(0)
            else:
                layer = self.project.mapLayersByName(group.name())[0]
                self.project.layerTreeRoot().findLayer(layer.id()).setItemVisibilityChecked(True)
                self.project.layerTreeRoot().findLayer(layer.id()).setExpanded(1)

            names = [layer.name() for layer in self.project.mapLayers().values()]
            # The cover layer is removed.
            for string in names:
                if len(string.split(owner_cover_layer_name, 1)) > 1:
                    cover_layer = self.project.mapLayersByName(string)
                    self.project.removeMapLayer(cover_layer[0].id())
        parcel_style = QgsVectorLayer("Polygon", "memory_polygon", "memory")
        parcel_style.loadNamedStyle(
            self.path + data_folder + watershed_prefix + str(self.watershed_name) + '/' + style_parcel)
        parcel_style.triggerRepaint()
        layers = [parcel_style, self.style_line_layer]
        names = [land_cover_map_parcel, land_cover_map_line]
        title = land_cover_map_title
        name = map_watershed_land_cover + str(self.count_watershed_analysis)
        rect = self.parcel_layer.extent()
        self.parcel_layer.setLabelsEnabled(False)
        self.parcel_layer.triggerRepaint()
        self.map_creation.create_map_jpg(self.project, layers, names, title, rect, date_m_y, author, name,
                                         self.output_path, self.count_watershed_analysis)
        self.parcel_layer.setLabelsEnabled(True)
        self.parcel_layer.triggerRepaint()
        # Every layer is unchecked and not visible.
        for group in self.project.layerTreeRoot().children():
            if self.project.layerTreeRoot().isGroup(group):
                self.project.layerTreeRoot().findGroup(group.name()).setItemVisibilityChecked(False)
                self.project.layerTreeRoot().findGroup(group.name()).setExpanded(0)
            elif (group.name() == self.style_line_layer.name() or group.name() == self.line_layer.name() or
                  group.name() == self.parcel_layer.name() and group.isVisible()):
                layer = self.project.mapLayersByName(group.name())[0]
                self.project.layerTreeRoot().findLayer(layer.id()).setItemVisibilityChecked(False)
                self.project.layerTreeRoot().findLayer(layer.id()).setExpanded(0)
        self.parcel_layer.commitChanges()
        self.line_layer.commitChanges()
        self.messagebox.show()
        elements = studied_elements
        # studied_elements = ["d'eau", "de MES", "de phytosanitaires"]
        # coded_studied_elements = [0,1,2]

        coded_elements=coded_studied_elements
        iter=0
        for i in coded_elements:
        #for i in range(len(elements)):
            element = elements[iter]
            iter +=1
            element_underscore = element.replace(' ', '_').lower()
            # The analysis are launched, the function will return 3 layers.
            # If the save value button has not been clicked, no variables are added to the analysis.
            if self.count_referential == 0:
                reference = self.flow_calculation.ecoulement_bv(self.parcel_layer, self.line_layer,
                                                                self.connexion_layer, self.count_watershed_analysis, i)
            # If the save value button has been clicked, max values are imported to compare the new result with data
            # from a previous turn.
            else:
                reference = self.flow_calculation.ecoulement_bv(self.parcel_layer, self.line_layer,
                                                                self.connexion_layer, self.count_watershed_analysis, i,
                                                                self.max_input_parcel, self.max_input_line,
                                                                self.max_input_river_section)
            self._referential_.append(reference)
            # The results are saved into the parcel and line layer.
            after_watershed_analysis(self.parcel_layer, self.line_layer, reference[2], self.count_watershed_analysis)
            # A new empty history CSV is created.
            with open(self.path + history_table_name, 'w') as csvfile:
                file_writer = csv.writer(csvfile, delimiter=';', quotechar='|', quoting=csv.QUOTE_MINIMAL)
                file_writer.writerow(
                    [history_field_action, history_field_layer, history_field_feature, history_field_field,
                     history_field_field_idx, history_field_previous, history_field_next])
            # Creation of the abatement map. Display only the right group.
            parent = self.project.layerTreeRoot().findGroup(
                group_watershed_analysis + str(self.count_watershed_analysis))
            parent.findGroup(group_flow_transfer + "BV " + str(self.count_watershed_analysis)).setItemVisibilityChecked(
                False)
            parent.findGroup(
                "Taux de transfert " + "BV " + str(
                    self.count_watershed_analysis)).setItemVisibilityChecked(
                False)
            parent.findGroup(
                "Contribution des parcelles " + "BV " + str(
                    self.count_watershed_analysis)).setItemVisibilityChecked(
                False)
            parent.findGroup(
                "Production de ruissellement des parcelles " + "BV " + str(
                    self.count_watershed_analysis)).setItemVisibilityChecked(
                False)
            # Map parameters.
            parcels = parcel_abatement_layer_name + str(self.count_watershed_analysis)
            lines = line_abatement_layer_name + str(self.count_watershed_analysis)
            parcels_layer = self.project.mapLayersByName(parcels)[0]
            lines_layer = self.project.mapLayersByName(lines)[0]
            layers = [parcels_layer, lines_layer]
            names = [watershed_abatement_map_parcel_pt1 + str(element) + watershed_abatement_map_parcel_pt2,
                     watershed_abatement_map_line_pt1 + str(element) + watershed_abatement_map_line_pt2]
            title = watershed_abatement_map_title_pt1 + str(element) + watershed_abatement_map_title_pt2
            name = map_watershed_abatement + str(element_underscore) + '_' + str(self.count_watershed_analysis)
            rect = parcels_layer.extent()
            self.map_creation.create_map_jpg(self.project, layers, names, title, rect, date_m_y, author, name,
                                             self.output_path, self.count_watershed_analysis)
            # Creation of the inflow map. Display only the right group.
            parent.findGroup(
                group_flow_transfer + "BV " + str(
                    self.count_watershed_analysis)).setItemVisibilityChecked(
                True)
            # Map parameters.
            parcels = parcel_transfer_layer_name + str(self.count_watershed_analysis)
            lines = line_transfer_layer_name + str(self.count_watershed_analysis)
            river_name = river_incoming_flow_layer_name + str(self.count_watershed_analysis)
            parcels_layer = self.project.mapLayersByName(parcels)[0]
            lines_layer = self.project.mapLayersByName(lines)[0]
            river_layer = self.project.mapLayersByName(river_name)[0]
            layers = [parcels_layer, lines_layer, river_layer]
            names = [watershed_transfer_map_parcel_pt1 + str(element) + watershed_transfer_map_parcel_pt2,
                     watershed_transfer_map_line_pt1 + str(element) + watershed_transfer_map_line_pt2,
                     watershed_transfer_map_river_pt1 + str(element) + watershed_transfer_map_river_pt2]
            title = watershed_transfer_map_title_pt1 + str(element) + watershed_transfer_map_title_pt2
            name = map_watershed_transfer + str(element_underscore) + '_' + str(self.count_watershed_analysis)
            self.map_creation.create_map_jpg(self.project, layers, names, title, rect, date_m_y, author, name,
                                             self.output_path, self.count_watershed_analysis)
            # Creation of the transfer map. Display only the right group.
            parent.findGroup(
                "Taux de transfert " + "BV " + str(self.count_watershed_analysis)).setItemVisibilityChecked(True)
            # Map parameters.
            parcels = "taux_de_transfert_" + str(self.count_watershed_analysis)
            parcels_layer = self.project.mapLayersByName(parcels)[0]
            self.line_layer.selectByExpression("\"{field_type}\" = {river}".format(
                field_type=field_type_line_middle, river=river))
            river_layer = processing.run("native:saveselectedfeatures",
                                         {'INPUT': self.line_layer,
                                          'OUTPUT': 'memory:' + river_selection_layer_name + str(
                                              self.count_watershed_analysis) + "_" + str(
                                              self.count_runoff_river_section_analysis)})['OUTPUT']
            self.project.addMapLayer(river_layer, False)
            parent.insertLayer(0, river_layer)
            self.line_layer.removeSelection()
            # create a new symbol
            symbol = QgsLineSymbol.createSimple({'line_style': 'solid', 'color': '#281df3', 'width': '0.66'})
            simple_renderer = QgsSingleSymbolRenderer(symbol)
            river_layer.setRenderer(simple_renderer)
            # repaint the layer
            river_layer.triggerRepaint()
            layers = [river_layer, parcels_layer]
            names = [watershed_transfer_rate_map_river,
                     watershed_transfer_rate_map_parcel_pt1 + str(element) + watershed_transfer_rate_map_parcel_pt2]
            title = watershed_transfer_rate_map_title_pt1 + str(element) + watershed_transfer_rate_map_title_pt2
            name = map_watershed_transfer_rate + str(element_underscore) + '_' + str(
                self.count_watershed_analysis)
            self.map_creation.create_map_jpg(self.project, layers, names, title, rect, date_m_y, author, name,
                                             self.output_path, self.count_watershed_analysis)
            # Creation of the contribution map. Display only the right group.
            parent.findGroup(
                "Contribution des parcelles " + "BV " + str(self.count_watershed_analysis)).setItemVisibilityChecked(
                True)
            parent.setItemVisibilityChecked(True)
            # Map parameters.
            parcels = "production_réceptionnée_par_le_cours_d_eau_en_fonction_de_la_surface_" + str(
                self.count_watershed_analysis)
            parcels_layer = self.project.mapLayersByName(parcels)[0]
            layers = [river_layer, parcels_layer]
            names = [watershed_production_potential_map_river,
                     watershed_production_potential_map_parcel_pt1 + str(element) +
                     watershed_production_potential_map_parcel_pt2]
            title = watershed_production_potential_map_title_pt1 + str(
                element) + watershed_production_potential_map_title_pt2
            name = map_watershed_potential_production + str(element_underscore) + '_' + str(
                self.count_watershed_analysis)
            self.map_creation.create_map_jpg(self.project, layers, names, title, rect, date_m_y, author, name,
                                             self.output_path, self.count_watershed_analysis)
            # Creation of the contribution map. Display only the right group.
            parent.findGroup(
                "Production de ruissellement des parcelles " + "BV " + str(
                    self.count_watershed_analysis)).setItemVisibilityChecked(
                True)
            parent.setItemVisibilityChecked(True)
            # Map parameters.
            parcels = "production_en_fonction_de_la_surface_" + str(self.count_watershed_analysis)
            parcels_layer = self.project.mapLayersByName(parcels)[0]
            layers = [river_layer, parcels_layer]
            names = [watershed_production_area_map_river,
                     watershed_production_area_map_parcel_pt1 + str(element) + watershed_production_area_map_parcel_pt2]
            title = watershed_production_area_map_title_pt1 + str(element) + watershed_production_area_map_title_pt2
            name = map_watershed_production_area + str(element_underscore) + '_' + str(
                self.count_watershed_analysis)
            self.map_creation.create_map_jpg(self.project, layers, names, title, rect, date_m_y, author, name,
                                             self.output_path, self.count_watershed_analysis)
            # Update the plots.
            self.plot_creation.data_visualisation_creation(self.line_layer, self.parcel_layer,
                                                           self.count_watershed_analysis, reference,
                                                           self.production_type)
            parent.removeAllChildren()
            self.project.layerTreeRoot().removeChildNode(parent)
        # The save value button is enabled so the user can chose this turn as reference.
        self.button_save_value.setEnabled(True)
        # Result button is enabled.
        self.button_result_viewer.setEnabled(True)
        if len(self.parcel_layer.selectedFeatures()) != 0:
            self.button_parcel_emit.setEnabled(False)
            self.button_parcel_reception.setEnabled(False)
        # The rollback button is disabled because the history CSV is empty.
        self.button_rollback.setEnabled(False)
        # Update the comparison tools.
        if self.count_watershed_analysis > 0:
            # Update the range slider
            self.map_viewer.update_range_slider(self.count_watershed_analysis)
            # Comparison button is enabled.
            self.button_comparison.setEnabled(True)
        self.project.layerTreeRoot().findLayer(self.line_layer.id()).setItemVisibilityChecked(True)
        self.project.layerTreeRoot().findLayer(self.parcel_layer.id()).setItemVisibilityChecked(True)
        self.project.layerTreeRoot().findLayer(self.style_line_layer.id()).setItemVisibilityChecked(True)
        self.project.layerTreeRoot().findLayer(self.line_layer.id()).setExpanded(1)
        self.project.layerTreeRoot().findLayer(self.parcel_layer.id()).setExpanded(1)
        self.project.layerTreeRoot().findLayer(self.style_line_layer.id()).setExpanded(1)
        # The signal for saving history changes in the CSV is started.
        self.signal_stop = 0
        # Select all features of the parcel layer.
        self.parcel_layer.selectAll()
        # Get the bounding box
        box = self.parcel_layer.boundingBoxOfSelected()
        # Set the bounding box as extent of the canvas.
        self.canvas.setExtent(box)
        self.canvas.refresh()
        # Remove the selection.
        self.parcel_layer.removeSelection()
        self.messagebox.done(1)
        self.max_input_parcel = []
        self.max_input_line = []
        self.max_input_river_section = []
        for i in range(len(elements)):
            # Parcel inflow reference.
            self.max_input_parcel.append(self.referential[i][5])
            # Line inflow reference.
            self.max_input_line.append(self.referential[i][6])
            # River section reference.
            self.max_input_river_section.append(self.referential[i][7])

    def saving_values(self):
        """ Save references values of maximum inflow for parcels, lines and river section. Those values are used to
        compare new result from watershed analysis with values from previous turn.
        """
        self.count_referential = self.incrementation(self.count_referential)
        # As long as a reference is not selected, the select parcel and river section button are disabled.
        self.button_select_parcel.setEnabled(True)
        self.button_select_river_section.setEnabled(True)

    def analysis_parcel_runoff_emit(self):
        """ Launch the analysis on a parcel to know where the runoff emitted from the parcel is going.
        If it exists, the cover layer is removed. The analysis is launched. 2 maps are made with the result, one for the
        abatement and one for the inflow.
        """
        # Increment the count of parcel runoff emitted analysis.
        self.count_runoff_emitted_analysis = self.incrementation(self.count_runoff_emitted_analysis)
        self.line_layer.removeSelection()
        # Stop the signal to save changes made on layers.
        self.signal_stop = 1
        # Set all layers to invisible.
        # self.bug_correction()
        for group in self.project.layerTreeRoot().children():
            if self.project.layerTreeRoot().isGroup(group):
                self.project.layerTreeRoot().findGroup(group.name()).setItemVisibilityChecked(False)
                self.project.layerTreeRoot().findGroup(group.name()).setExpanded(0)
            elif (group.name() == self.style_line_layer.name() or group.name() == self.line_layer.name() or
                  group.name() == self.parcel_layer.name() and group.isVisible()):
                layer = self.project.mapLayersByName(group.name())[0]
                self.project.layerTreeRoot().findLayer(layer.id()).setItemVisibilityChecked(False)
                self.project.layerTreeRoot().findLayer(layer.id()).setExpanded(0)
            names = [layer.name() for layer in self.project.mapLayers().values()]
            # Delete the cover layer.
            for string in names:
                if len(string.split(owner_cover_layer_name, 1)) > 1:
                    cover_layer = self.project.mapLayersByName(string)
                    self.project.removeMapLayer(cover_layer[0].id())
        self.messagebox.show()
        selected_parcel_id = self.parcel_layer.selectedFeatureIds()[0]
        elements = studied_elements
        # studied_elements = ["d'eau", "de MES", "de phytosanitaires"]
        coded_elements=coded_studied_elements
        for i in coded_elements:
        #for i in range(len(elements)):            element = elements[i]
            element_underscore = element.replace(' ', '_').lower()
            # Launch the analysis.
            self.flow_calculation.ecoulement_emis(self.parcel_layer, self.line_layer, self.connexion_layer,
                                                  self.count_watershed_analysis, i)
            # Creation of the abatement map, only display the abatement layers.
            parent = self.project.layerTreeRoot().findGroup(
                group_outgoing_flow_parcel + str(self.count_watershed_analysis) + " " + str(selected_parcel_id))
            parent.findGroup(group_flow_transfer + str(self.count_watershed_analysis) + " " + str(
                selected_parcel_id)).setItemVisibilityChecked(False)
            # Map parameters.
            parcels = parcel_abatement_layer_name + str(self.count_watershed_analysis) + "_" + str(selected_parcel_id)
            lines = line_abatement_layer_name + str(self.count_watershed_analysis) + "_" + str(selected_parcel_id)
            parcels_layer = self.project.mapLayersByName(parcels)[0]
            lines_layer = self.project.mapLayersByName(lines)[0]
            layers = [parcels_layer, lines_layer]
            names = [parcel_abatement_map_parcel_pt1 + str(element) + parcel_abatement_map_parcel_pt2,
                     parcel_abatement_map_line_pt1 + str(element) + parcel_abatement_map_line_pt2]
            title = parcel_abatement_map_title_pt1 + str(element) + parcel_abatement_map_title_pt2
            count_file = 1
            for file in os.listdir(self.output_path):
                if file.replace(".jpg", "").split("_", -1)[0:2] == map_parcel_abatement.split("_", -1)[0:2]:
                    if int(file.replace(".jpg", "").split("_", -1)[-3]) == selected_parcel_id:
                        count_file = count_file + 1
            name = map_parcel_abatement + str(element_underscore) + '_' + str(selected_parcel_id) + "_" + str(
                count_file) + "_" + str(self.count_watershed_analysis)
            parcels_layer.selectByExpression(
                "{entrant} > 0".format(entrant=field_incoming_flow))
            rect1 = parcels_layer.boundingBoxOfSelected()
            lines_layer.selectByExpression(
                "{entrant} > 0".format(entrant=field_incoming_flow))
            rect2 = lines_layer.boundingBoxOfSelected()
            rect1.combineExtentWith(rect2)
            # rect1.grow(50)
            parcels_layer.removeSelection()
            lines_layer.removeSelection()
            self.map_creation.create_map_jpg(self.project, layers, names, title, rect1, date_m_y, author, name,
                                             self.output_path, self.count_watershed_analysis)
            # Creation of the inflow map. Display only the inflow layers.
            parent.findGroup(
                group_flow_transfer + str(self.count_watershed_analysis) + " " + str(
                    selected_parcel_id)).setItemVisibilityChecked(
                True)
            parent.setItemVisibilityChecked(True)
            # Map parameters.
            parcels = parcel_transfer_layer_name + str(self.count_watershed_analysis) + "_" + str(selected_parcel_id)
            lines = line_transfer_layer_name + str(self.count_watershed_analysis) + "_" + str(selected_parcel_id)
            river_name = river_incoming_flow_layer_name + str(self.count_watershed_analysis) + "_" + str(
                selected_parcel_id)
            parcels_layer = self.project.mapLayersByName(parcels)[0]
            lines_layer = self.project.mapLayersByName(lines)[0]
            river_layer = self.project.mapLayersByName(river_name)[0]
            layers = [parcels_layer, lines_layer, river_layer]
            names = [parcel_transfer_map_parcel_pt1 + str(element) + parcel_transfer_map_parcel_pt2,
                     parcel_transfer_map_line_pt1 + str(element) + parcel_transfer_map_line_pt2,
                     parcel_transfer_map_river_pt1 + str(element) + parcel_transfer_map_river_pt2]
            title = parcel_transfer_map_title_pt1 + str(element) + parcel_transfer_map_title_pt2
            count_file = 1
            for file in os.listdir(self.output_path):
                if file.replace(".jpg", "").split("_", -1)[0:2] == map_parcel_transfer.split("_", -1)[0:2]:
                    if int(file.replace(".jpg", "").split("_", -1)[-3]) == selected_parcel_id:
                        count_file = count_file + 1
            name = map_parcel_transfer + str(element_underscore) + '_' + str(selected_parcel_id) + "_" + str(
                count_file) + "_" + str(self.count_watershed_analysis)
            self.map_creation.create_map_jpg(self.project, layers, names, title, rect1, date_m_y, author, name,
                                             self.output_path, self.count_watershed_analysis)
            parent.removeAllChildren()
            self.project.layerTreeRoot().removeChildNode(parent)
            self.parcel_layer.selectByIds([selected_parcel_id])
        # Buttons for parcel analysis are disabled because no parcel is selected.
        self.button_parcel_emit.setEnabled(False)
        self.button_parcel_reception.setEnabled(False)
        self.project.layerTreeRoot().findLayer(self.line_layer.id()).setItemVisibilityChecked(True)
        self.project.layerTreeRoot().findLayer(self.parcel_layer.id()).setItemVisibilityChecked(True)
        self.project.layerTreeRoot().findLayer(self.style_line_layer.id()).setItemVisibilityChecked(True)
        self.project.layerTreeRoot().findLayer(self.line_layer.id()).setExpanded(1)
        self.project.layerTreeRoot().findLayer(self.parcel_layer.id()).setExpanded(1)
        self.project.layerTreeRoot().findLayer(self.style_line_layer.id()).setExpanded(1)
        # Start the signal to save changes made on layers.
        self.signal_stop = 0
        # Select all features of the parcel layer.
        self.parcel_layer.selectAll()
        # Get the bounding box
        box = self.parcel_layer.boundingBoxOfSelected()
        # Set the bounding box as extent of the canvas.
        self.canvas.setExtent(box)
        self.canvas.refresh()
        # Remove the selection.
        self.parcel_layer.removeSelection()
        self.messagebox.done(1)

    def analysis_parcel_runoff_reception(self):
        """ Launch the analysis on a parcel to know where the runoff received by the parcel is from.
        If it exists, the cover layer is removed. The analysis is launched. A map is made with the result with the
        contribution of the parcels above the selected parcel.
        """
        # Increment the count of parcel runoff reception analysis.
        self.count_runoff_received_analysis = self.incrementation(self.count_runoff_received_analysis)
        self.line_layer.removeSelection()
        # Stop the signal to save changes when layers are modified.
        self.signal_stop = 1
        # Hide all the layers.
        for group in self.project.layerTreeRoot().children():
            if self.project.layerTreeRoot().isGroup(group):
                self.project.layerTreeRoot().findGroup(group.name()).setItemVisibilityChecked(False)
                self.project.layerTreeRoot().findGroup(group.name()).setExpanded(0)
            elif (group.name() == self.style_line_layer.name() or group.name() == self.line_layer.name() or
                  group.name() == self.parcel_layer.name() and group.isVisible()):
                layer = self.project.mapLayersByName(group.name())[0]
                self.project.layerTreeRoot().findLayer(layer.id()).setItemVisibilityChecked(False)
                self.project.layerTreeRoot().findLayer(layer.id()).setExpanded(0)
            names = [layer.name() for layer in self.project.mapLayers().values()]
            # Delete cover layer.
            for string in names:
                if len(string.split(owner_cover_layer_name, 1)) > 1:
                    cover_layer = self.project.mapLayersByName(string)
                    self.project.removeMapLayer(cover_layer[0].id())
        self.messagebox.show()
        selected_parcel_id = self.parcel_layer.selectedFeatureIds()[0]
        if self.button_rollback.isEnabled() or self.count_runoff_emitted_analysis > 0:
            quick_value = False
        else:
            quick_value = True
        elements = studied_elements
        # studied_elements = ["d'eau", "de MES", "de phytosanitaires"]
        coded_elements=coded_studied_elements
        for i in coded_elements:
        #for i in range(len(elements)):
            element = elements[i]
            element_underscore = element.replace(' ', '_').lower()
            # Launch analysis.
            self.flow_calculation.ecoulement_recu(self.parcel_layer, self.line_layer, self.connexion_layer,
                                                  self.count_watershed_analysis, i, quick_value)
            # Creation of the map to show the impact of the parcels on the inflow of the selected parcels.
            # Map parameters.
            production = parcel_contribution_layer_name + str(self.count_watershed_analysis) + "_" + str(
                selected_parcel_id)
            abatement = parcel_abatement_layer_name + str(self.count_watershed_analysis) + "_" + str(selected_parcel_id)
            lines = line_abatement_layer_name + str(self.count_watershed_analysis) + "_" + str(selected_parcel_id)
            production_layer = self.project.mapLayersByName(production)[0]
            abatement_layer = self.project.mapLayersByName(abatement)[0]
            lines_layer = self.project.mapLayersByName(lines)[0]
            self.line_layer.selectByExpression("\"{field_type}\" = {river}".format(
                field_type=field_type_line_middle, river=river))
            river_layer = processing.run("native:saveselectedfeatures",
                                         {'INPUT': self.line_layer,
                                          'OUTPUT': 'memory:' + river_selection_layer_name + str(
                                              self.count_watershed_analysis) + "_" + str(
                                              self.count_runoff_river_section_analysis)})['OUTPUT']
            self.project.addMapLayer(river_layer, False)
            group = self.project.layerTreeRoot().findGroup(
                group_incoming_flow_parcel + str(self.count_watershed_analysis) + '_' + str(selected_parcel_id))
            group.insertLayer(0, river_layer)
            self.line_layer.removeSelection()
            # create a new symbol
            symbol = QgsLineSymbol.createSimple({'line_style': 'solid', 'color': '#281df3', 'width': '0.66'})
            simple_renderer = QgsSingleSymbolRenderer(symbol)
            river_layer.setRenderer(simple_renderer)
            # repaint the layer
            river_layer.triggerRepaint()
            layers = [river_layer, production_layer, lines_layer, abatement_layer]
            names = [parcel_reception_map_river, parcel_reception_map_parcel_production, parcel_reception_map_line,
                     parcel_reception_map_parcel_abatement]
            title = parcel_reception_map_title + str(selected_parcel_id)
            count_file = 1
            for file in os.listdir(self.output_path):
                if file.replace(".jpg", "").split("_", -1)[0:2] == map_parcel_received.split("_", -1)[0:2]:
                    if int(file.replace(".jpg", "").split("_", -1)[-3]) == selected_parcel_id:
                        count_file = count_file + 1
            name = map_parcel_received + str(element_underscore) + '_' + str(selected_parcel_id) + "_" + str(
                count_file) + "_" + str(self.count_watershed_analysis)
            production_layer.selectByExpression(
                " {champ_entrant} > 0 and {champ_indice_prod} != 99".format(
                    champ_entrant=field_incoming_flow, champ_indice_prod=field_flow_production_rating))
            rect1 = production_layer.boundingBoxOfSelected()
            abatement_layer.selectByExpression(
                "{champ_indice_abatt}  != 99".format(champ_indice_abatt=field_flow_abatement_rating))
            rect2 = abatement_layer.boundingBoxOfSelected()
            lines_layer.selectByExpression(
                "{champ_entrant} > 0 and {champ_indice_abatement} != 999".format(
                    champ_entrant=field_incoming_flow,
                    champ_indice_abatement=field_flow_abatement))
            rect3 = lines_layer.boundingBoxOfSelected()
            rect1.combineExtentWith(rect2)
            rect1.combineExtentWith(rect3)
            # rect1.grow(50)
            production_layer.removeSelection()
            abatement_layer.removeSelection()
            lines_layer.removeSelection()

            self.map_creation.create_map_jpg(self.project, layers, names, title, rect1, date_m_y, author, name,
                                             self.output_path, self.count_watershed_analysis)
            group.removeAllChildren()
            self.project.layerTreeRoot().removeChildNode(group)
            self.parcel_layer.selectByIds([selected_parcel_id])
        # Buttons for parcel analysis are disabled because no parcel is selected.
        self.button_parcel_emit.setEnabled(False)
        self.button_parcel_reception.setEnabled(False)
        self.project.layerTreeRoot().findLayer(self.line_layer.id()).setItemVisibilityChecked(True)
        self.project.layerTreeRoot().findLayer(self.parcel_layer.id()).setItemVisibilityChecked(True)
        self.project.layerTreeRoot().findLayer(self.style_line_layer.id()).setItemVisibilityChecked(True)
        self.project.layerTreeRoot().findLayer(self.line_layer.id()).setExpanded(1)
        self.project.layerTreeRoot().findLayer(self.parcel_layer.id()).setExpanded(1)
        self.project.layerTreeRoot().findLayer(self.style_line_layer.id()).setExpanded(1)
        # Start the signal to save changes made on layers.
        self.signal_stop = 0
        # Select all features of the parcel layer.
        self.parcel_layer.selectAll()
        # Get the bounding box
        box = self.parcel_layer.boundingBoxOfSelected()
        # Set the bounding box as extent of the canvas.
        self.canvas.setExtent(box)
        self.canvas.refresh()
        # Remove the selection.
        self.parcel_layer.removeSelection()
        self.messagebox.done(1)

    def analysis_river_section_runoff_reception(self):
        """ Launch the analysis on a river section to know where the runoff received by the river section is from.
        If it exists, the cover layer is removed. The analysis is launched. A map is made with the result with the
        contribution of the parcels above the selected river section.
        """
        # Increment the count of parcel runoff reception analysis.
        self.count_runoff_river_section_analysis = self.incrementation(self.count_runoff_river_section_analysis)
        self.parcel_layer.removeSelection()
        # Stop the signal to save changes when layers are modified.
        self.signal_stop = 1
        # Hide all the layers.
        # self.bug_correction()
        for group in self.project.layerTreeRoot().children():
            if self.project.layerTreeRoot().isGroup(group):
                self.project.layerTreeRoot().findGroup(group.name()).setItemVisibilityChecked(False)
                self.project.layerTreeRoot().findGroup(group.name()).setExpanded(0)
            elif (group.name() == self.style_line_layer.name() or group.name() == self.line_layer.name() or
                  group.name() == self.parcel_layer.name() and group.isVisible()):
                layer = self.project.mapLayersByName(group.name())[0]
                self.project.layerTreeRoot().findLayer(layer.id()).setItemVisibilityChecked(False)
                self.project.layerTreeRoot().findLayer(layer.id()).setExpanded(0)
            names = [layer.name() for layer in self.project.mapLayers().values()]
            # Delete cover layer.
            for string in names:
                if len(string.split(owner_cover_layer_name, 1)) > 1:
                    cover_layer = self.project.mapLayersByName(string)
                    self.project.removeMapLayer(cover_layer[0].id())
        self.messagebox.show()
        # Launch analysis.
        river_section_selected = self.line_layer.selectedFeatureIds()
        if self.button_rollback.isEnabled() or self.count_runoff_emitted_analysis > 0:
            quick_value = False
        else:
            quick_value = True
        elements = studied_elements
        # studied_elements = ["d'eau", "de MES", "de phytosanitaires"]
        coded_elements=coded_studied_elements
        for i in coded_elements:
        #for i in range(len(elements)):
            element = elements[i]
            element_underscore = element.replace(' ', '_').lower()
            self.flow_calculation.ecoulement_riviere(self.parcel_layer, self.line_layer, self.connexion_layer,
                                                     self.count_watershed_analysis,
                                                     self.count_runoff_river_section_analysis, i, quick_value)
            # Creation of the map to show the impact of the parcels on the inflow of the selected river section.
            # Map parameters.
            production = parcel_contribution_layer_name + str(self.count_watershed_analysis) + "_" + str(
                self.count_runoff_river_section_analysis)
            abatement = parcel_abatement_layer_name + str(self.count_watershed_analysis) + "_" + str(
                self.count_runoff_river_section_analysis)
            lines = line_abatement_layer_name + str(self.count_watershed_analysis) + "_" + str(
                self.count_runoff_river_section_analysis)
            production_layer = self.project.mapLayersByName(production)[0]
            abatement_layer = self.project.mapLayersByName(abatement)[0]
            lines_layer = self.project.mapLayersByName(lines)[0]
            self.line_layer.selectByIds(river_section_selected)
            river_layer = processing.run("native:saveselectedfeatures",
                                         {'INPUT': self.line_layer,
                                          'OUTPUT': 'memory:' + river_selection_layer_name + str(
                                              self.count_watershed_analysis) + "_" + str(
                                              self.count_runoff_river_section_analysis)})['OUTPUT']
            self.project.addMapLayer(river_layer, False)
            group = self.project.layerTreeRoot().findGroup(group_incoming_flow_river + str(
                self.count_watershed_analysis) + "_" + str(
                self.count_runoff_river_section_analysis))
            group.insertLayer(0, river_layer)
            river_layer.loadNamedStyle(style_river_selection)
            river_layer.triggerRepaint()
            self.line_layer.removeSelection()
            layers = [production_layer, lines_layer, abatement_layer, river_layer]
            names = [river_reception_map_parcel_production, river_reception_map_line,
                     river_reception_map_parcel_abatement, river_reception_map_river]
            title = river_reception_map_title
            name = map_river_received + str(element_underscore) + '_' + str(
                self.count_runoff_river_section_analysis) + "_" + str(
                self.count_watershed_analysis)
            production_layer.selectByExpression(
                " {champ_entrant} > 0 and {champ_indice_prod} != 99".format(
                    champ_entrant=field_incoming_flow, champ_indice_prod=field_flow_production_rating))
            rect1 = production_layer.boundingBoxOfSelected()
            abatement_layer.selectByExpression(
                " {champ_indice_abatt}  != 99".format(champ_indice_abatt=field_flow_abatement_rating))
            rect2 = abatement_layer.boundingBoxOfSelected()
            lines_layer.selectByExpression(
                " {champ_entrant} > 0 and {champ_indice_abatement} != 999".format(
                    champ_entrant=field_incoming_flow,
                    champ_indice_abatement=field_flow_abatement_rating))
            rect3 = lines_layer.boundingBoxOfSelected()
            river_layer.selectAll()
            rect4 = river_layer.boundingBoxOfSelected()
            rect1.combineExtentWith(rect2)
            rect1.combineExtentWith(rect3)
            rect1.combineExtentWith(rect4)
            # rect1.grow(50)
            production_layer.removeSelection()
            abatement_layer.removeSelection()
            lines_layer.removeSelection()
            river_layer.removeSelection()
            self.map_creation.create_map_jpg(self.project, layers, names, title, rect1, date_m_y, author, name,
                                             self.output_path, self.count_watershed_analysis)
            group.removeAllChildren()
            self.project.layerTreeRoot().removeChildNode(group)
            self.line_layer.selectByIds(river_section_selected)
        self.line_layer.removeSelection()
        # Button for river section analysis is disabled because no river section is selected.
        self.button_river_reception.setEnabled(False)
        self.project.layerTreeRoot().findLayer(self.line_layer.id()).setItemVisibilityChecked(True)
        self.project.layerTreeRoot().findLayer(self.parcel_layer.id()).setItemVisibilityChecked(True)
        self.project.layerTreeRoot().findLayer(self.style_line_layer.id()).setItemVisibilityChecked(True)
        self.project.layerTreeRoot().findLayer(self.line_layer.id()).setExpanded(1)
        self.project.layerTreeRoot().findLayer(self.parcel_layer.id()).setExpanded(1)
        self.project.layerTreeRoot().findLayer(self.style_line_layer.id()).setExpanded(1)
        # Start the signal to save changes made on layers.
        self.signal_stop = 0
        # Select all features of the parcel layer.
        self.parcel_layer.selectAll()
        # Get the bounding box
        box = self.parcel_layer.boundingBoxOfSelected()
        # Set the bounding box as extent of the canvas.
        self.canvas.setExtent(box)
        self.canvas.refresh()
        # Remove the selection.
        self.parcel_layer.removeSelection()
        self.messagebox.done(1)
