# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeomelbaSpirit
                                 A QGIS plugin
 Based on GeoMelba software, meant to be used with the serious game CAUSERIE.
 This file contains a class based on QT QPushButton used to add a pointer tool on the QGIS Canvas.
 This button is used to modify element of the landscape and also to select an element and realize analysis.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-08-24
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Jules Grillot / INRAE
        email                : jules.grillot@inrae.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# Qgis Modules
from qgis.PyQt.QtWidgets import QPushButton, QMessageBox
from qgis.gui import QgsMapCanvas
from qgis.core import QgsWkbTypes, QgsVectorLayer, QgsSpatialIndex, QgsExpression, QgsFeatureRequest, QgsGeometry, \
    QgsPointXY, QgsFeature, QgsCoordinateReferenceSystem
from qgis.gui import QgsMapToolEmitPoint
import processing
# Personal Modules
from ....dictionnaire import field_parcel_id, field_line_id, river, field_type_line_middle, line_type, polygon_type, \
    information_selection_error, information_selection_error_pt1


class ButtonPointer(QPushButton):
    """New type of QPushButton allowing the user to point features on canvas.
    This allow two different actions, select feature and modify features with a specified value.
    """

    def __init__(self, parent=None):
        """Class attributes are :
        - field to modify
        - action of the pointer
        - canvas which contains the layer
        - crs of the layer
        - layer
        - value (if needed for modification)
        - name of the id field
        - type of element in the layer for pointer's distance and error message
        - distance of the pointer
        - pointer
        """
        super(ButtonPointer, self).__init__(parent)
        self.field = ""
        self.action = ""
        self.canvas = QgsMapCanvas()
        self.crs = QgsCoordinateReferenceSystem()
        self.layer = QgsVectorLayer()
        self.value = 0
        self.field_id = ""
        self.type = ""
        self.distance = 0
        self.point_tool = None

    def on_click(self, button, canvas, crs, layer, value, field):
        """Function triggered when the ButtonPointer is clicked, give values to attributes and launch the pointer
        function. """
        self.action = button.accessibleName()
        self.canvas = canvas
        self.crs = crs
        self.layer = layer
        self.value = value
        self.field = field
        # The size of the pointer is different depending on the geometry type.
        geometry_type = QgsWkbTypes.geometryDisplayString(self.layer.geometryType())
        if geometry_type == "Polygon":
            self.type = polygon_type
            self.distance = 0.01
            self.field_id = field_parcel_id
        elif geometry_type == "Line":
            self.type = line_type
            self.distance = 4
            self.field_id = field_line_id
        # Function connected to the signal emitted by the button on click. Launch the pointer function.
        button.clicked.connect(self.pointer)

    def pointer(self):
        """Function to create the pointer."""

        def select_element(point):
            """Function to select feature with the pointer."""
            # The pointer is a memory layer.
            pointer_layer = QgsVectorLayer("Point?crs=" + str(self.crs.authid()), "point", "memory")
            # An index is made for faster selection.
            layer_index = QgsSpatialIndex()
            features = {}
            # Only one tool allow to select a line, the button to select a river section. If those 2 conditions are True
            # Only the river section features are selected.
            if self.type == line_type and self.action == "select":
                selection = QgsExpression("{field_type_line} = '{river}'".format(field_type_line=field_type_line_middle,
                                                                                 river=river))
            else:
                # If those two conditions are not required, every features are selected.
                selection = QgsExpression("{field_id} >= 0".format(field_id=self.field_id))
            for feature in self.layer.getFeatures(QgsFeatureRequest(selection)):
                features[feature.id()] = feature
                layer_index.addFeature(feature)
            # Geometry creation based on the click of the user.
            pointer = QgsGeometry.fromPointXY(QgsPointXY(point.x(), point.y()))
            # Creation of a feature to add to the memory layer.
            point_feature = QgsFeature(pointer_layer.fields())
            point_feature.setGeometry(pointer)
            pointer_layer.dataProvider().addFeatures([point_feature])
            pointer_layer.updateExtents()
            # Creation of a buffer around the point with the specified distance.
            buffer = processing.run("native:buffer",
                                    {'INPUT': pointer_layer, 'DISTANCE': self.distance, 'SEGMENTS': 5,
                                     'END_CAP_STYLE': 0, 'JOIN_STYLE': 0, 'MITER_LIMIT': 2, 'DISSOLVE': False,
                                     'OUTPUT': 'TEMPORARY_OUTPUT'})
            pointer_layer = buffer['OUTPUT']
            # Get layer features into the buffer.
            for point in pointer_layer.getFeatures():
                list_ids = layer_index.intersects(point.geometry().boundingBox())
                distance = {}
                for feat_id in list_ids:
                    feature = features[feat_id]
                    # If the geometry type is a polygon, only the selected polygon is kept.
                    if self.type == polygon_type:
                        if point.geometry().intersection(feature.geometry()):
                            distance[feat_id] = 0
                    # If the geometry type is line, multiple lines can be in the buffer are, they are ordered by
                    # distance to the point clicked.
                    elif self.type == line_type:
                        distance[feat_id] = feature.geometry().closestSegmentWithContext(pointer.asPoint())[0]
                # In case multiple features are selected, the closest one of the click is kept.
                if len(distance) > 0:
                    min_value = min(distance.values())
                    feat_id = [key for key in distance if distance[key] == min_value][0]
                    self.pointer_action(feat_id)
                # If no features are selected, an error message appear.
                else:
                    QMessageBox.information(None, information_selection_error,
                                            information_selection_error_pt1 + self.type)
                    self.layer.removeSelection()
        # Creation of the pointer.
        self.point_tool = QgsMapToolEmitPoint(self.canvas)
        # If the canvas is clicked the mouse become a point tool and a function is launched.
        self.point_tool.canvasClicked.connect(select_element)
        self.canvas.setMapTool(self.point_tool)

    def pointer_action(self, feature_id):
        """Depending on the action the feature clicked on is selected or modified.
        """
        # If the action is a selection the feature is selected. In the case of the advanced line tool, the pointer is
        # unset after selection.
        if self.action == "select" or self.action == "advanced_modification":
            self.layer.selectByIds([feature_id])
            if self.action == "advanced_modification":
                self.canvas.unsetMapTool(self.point_tool)
        # If the action is an edit of the feature, a function is launched based on the layers.py file.
        elif self.action == "edit":
            attrs = self.layer.getFeature(feature_id).attributes()
            old_value = attrs[self.layer.fields().indexFromName(self.field)]
            self.layer.handle_value_changed(self.field, [feature_id], self.value, old_value)

    def unset_map_tool(self):
        """Unset the pointer so the mouse get backs to the basic arrow.
        """
        if self.canvas.mapTool():
            self.canvas.unsetMapTool(self.point_tool)
            self.point_tool = None
