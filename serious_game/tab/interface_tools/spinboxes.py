# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeomelbaSpirit
                                 A QGIS plugin
 Based on GeoMelba software, meant to be used with the serious game CAUSERIE.
 This file contains a class based on QT QSpinBox, used to synchronize two Spinboxes.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-08-24
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Jules Grillot / INRAE
        email                : jules.grillot@inrae.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# QT Modules
from PyQt5.QtWidgets import QSpinBox


class SpinBoxes(QSpinBox):
    """Class for specific spinbox, they are controlled by the user. Every change are controlled by the SpinBoxManager
    to check some condition. If the value doesn't respond to the condition, it is skipped.
    """
    def __init__(self, parent=None):
        """The variables are :
        - the value
        - the last value
        - the way the spinbox is switching, up or down
        """
        super(SpinBoxes, self).__init__(parent)
        self.manager = None
        self._last = self.value()
        self.valueChanged.connect(self.handleValueChanged)
        self.lastValue = None
        self.isUp = False

    def addManager(self, manager):
        """Add a manager to the spinbox.
        The mandatory argument is :
        - the ManagerSpinBoxes
        The manager will not only check every value of the spinbox but also define the first value and the range of the
        SpinBoxes.
        """
        self.manager = manager
        self.manager.addSpinBox(self)
        self.lastValue = min(manager.values)  # Take the min of the parcels list
        self.setRange(min(manager.values), max(manager.values))  # Define the range

    def handleValueChanged(self, value):
        """Check the way the spinbox is switching value and call a method from the manager.
        The mandatory argument is :
        - the new value
        """
        if value > self.lastValue:  # If is up
            self.isUp = True
        else:  # If is down
            self.isUp = False
        # Call the method from ManagerSpinBoxes to manage values
        self.manager.manageChanges(value, self)


class ManagerSpinBoxes:
    """Class used to manage the SpinBoxes. It has a list of value to check if the new value of the spinbox is in the
    list or it will be automatically switched to a value in the list.
    """

    def __init__(self):
        """The variables are :
        - the spinboxes managed by the manager.
        - the values accepted for the spinboxes.
        """
        self.spinBoxes = []
        self.values = []

    def addSpinBox(self, spinBox):  # add spinbox to its list
        """Add a spinbox to the manager.
        The variables are :
        - the spinbox to add to the manager.
        """
        self.spinBoxes.append(spinBox)

    def defineValues(self, tab):
        """Define values accepted by the manager.
        The variables are :
        - a list of values.
        """
        self.values = tab

    def manageChanges(self, value, spin_boxes):
        """Manage the value modification from a spinbox.
        The variables are :
        - The new value entered by the user.
        - the spinbox concerned with the modification.
        """
        # While our value is not in the parcels list
        while value not in self.values:
            # If the way of switching value is up, the next value is checked.
            if spin_boxes.isUp:
                value = value + 1
            # If the way of switching value is dwn, the previous value is checked.
            else:
                value = value - 1

        spin_boxes.setValue(value)
        # When we found a value possible we test if the other spinboxes have the same value.
        for spin in self.spinBoxes:
            # Loop through all the spinboxes to check their values.
            # If spin is not the current spinbox AND if values are equal
            if spin != spin_boxes and spin.value() == value:
                # Case UP
                # if other spin different of max, recall manageChanges
                if spin_boxes.isUp and spin.value() != max(self.values):
                    self.manageChanges(value + 1, spin_boxes)  # recall the function not to have same values
                # if other spin is max
                elif spin_boxes.isUp and spin.value() == max(self.values):
                    # take the old value
                    spin_boxes.setValue(spin_boxes.lastValue)

                # Case DOWN similar to UP but with the min value.
                elif not spin_boxes.isUp and spin.value() != min(self.values):
                    self.manageChanges(value - 1, spin_boxes)

                elif not spin_boxes.isUp and spin.value() == min(self.values):
                    spin_boxes.setValue(spin_boxes.lastValue)

        # Update the lastValue.
        spin_boxes.lastValue = spin_boxes.value()

    def set_begin_values(self):
        """Make the default values different to avoid bugs if the user validates.
        """
        for i in range(0, len(self.spinBoxes)):
            self.spinBoxes[i].setValue(self.values[i])
