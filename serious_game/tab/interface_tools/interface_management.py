# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeomelbaSpirit
                                 A QGIS plugin
 Based on GeoMelba software, meant to be used with the serious game CAUSERIE.
 This file contains the functions to use when the user configure the dock widget.
 Buttons and widget of the dock widget are controlled with functions from this file.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-08-24
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Jules Grillot / INRAE
        email                : jules.grillot@inrae.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtWidgets import QLabel, QButtonGroup, QPushButton, QCheckBox, QMessageBox
from qgis.core import QgsVectorLayer

from .buttonpointer import ButtonPointer
from .spinboxes import SpinBoxes, ManagerSpinBoxes
from ....dictionnaire import field_parcel_owner, field_parcel_drain_id, field_parcel_drain_enabled, \
    field_type_line_middle, field_parcel_drain_type, field_line_drain_enabled, field_parcel_id, regular_font, \
    owner_selection_top_label, municipality_button_name, owner_button_name, remove_cover_button_name, \
    switch_parcels_owner_label_pt1, switch_parcels_owner_label_pt2, switch_parcels_owner_label_pt3, \
    switch_parcel_owner_button_name, information_selection_error, information_switch_parcel_owner_error, \
    owner_cover_layer_name, drain_selection_top_label, drain, information_modification_multiple_error_1, \
    information_modification_multiple_error_2


# Functions to create the interface and modify one feature (parcel, line)
# Functions to create the interface on single feature modification
def init_button_pointer(tab_widget, tab_index, label_txt, action, canvas, crs, layer, dict_elems, field):
    """Place the buttons on the specified tab index based on dictionaries, line type, land cover or agricultural
    practice. Those buttons ButtonPointer are a class imported from another python file. They allow the user to
    modify one feature to the value the button represent. Each button represent a different value. The mandatory
    arguments are :
    - the index of the tab they populate
    - the label to introduce the buttons
    - the name of the action, ButtonPointer can either edit a feature,
    select a feature or both in the case of the advanced lines tool
    - the canvas where the user is going to click
    - the coordinates system (some like 4326 have a unit system in degrees, therefore selection tool will not work.
    The user must use a metric system like 2154 in France, or 3857 worldwide).
    - the layer concerned by the buttons (parcel or line)
    - the dictionary to base the labels and values on
    - the field modified

   For each element of the dictionary a button is created with the key as label and value as value.
   The first button as a determined position, the other buttons are placed based on the first one
   and the place left on the line. If there is no place left, the button begins another line.
   The label are modified to fit the buttons, if its too long line breaks are added.
    """
    # Creation of the label.
    label = QLabel(tab_widget.widget(tab_index))
    label.setFont(regular_font)
    label.setGeometry(10, 25, 650, 30)
    label.setText(label_txt)
    # Position of the first button.
    x_place = 25
    y_place = 75
    # Loop on all the element of the dictionary to create a button for every element.
    for elem in dict_elems:
        # Every button is a ButtonPointer.
        button_pointer = ButtonPointer(tab_widget.widget(tab_index))
        button_pointer.setFont(regular_font)
        button_name = elem
        # Change the name if it's too long for the button size.
        if len(button_name) > 15:
            # Get indexes where there is a '_', so we can cut the labels between words and not in the middle of one.
            res = [i for i in range(len(button_name)) if button_name.startswith('_', i)]
            for i in range(len(res)):
                if res[i] > 10:
                    button_name = button_name[0:res[i]] + '\n' + button_name[res[i] + 1:]
                    while (res[i] < 30 and res[i] < len(
                            res)):  # Loop to avoid too much \n and potentially add one if >30.
                        i += 1
                        if res[i] > 30:
                            button_name = button_name[0:res[i]] + '\n' + button_name[res[i] + 1:]
                            break
                    break
        button_name = str(button_name.replace('_', ' ').capitalize())  # Transform last '_' to spaces.
        button_pointer.setText(button_name)
        button_pointer.setAccessibleName(str(action))  # The action name is stocked inside the button.
        # For the lines a button to delete a line is created at a certain position and with a certain size.
        if dict_elems[elem] == 0:
            button_pointer.setGeometry(10, 320, 300, 30)
        else:
            button_pointer.setGeometry(x_place, y_place, 175, 35)
        # Function of the ButtonPointer used when the button is clicked. Launch the modification of the feature.
        button_pointer.on_click(button_pointer, canvas, crs, layer, dict_elems[elem], field)
        # Position of the next button
        if x_place >= 375:
            # After a certain value on the x-axis it's a new line is started.
            x_place = 25
            y_place += 50
        else:
            # While the limit on the x-axis is not outmoded a button is added on the same line.
            x_place += 200


class UiCreationOwnerModification:
    def __init__(self, tab_manager=None, parcel_layer=None, project=None):
        """Arguments are :
        - tab manager instance
        - parcel layer
        - qgis project

        Variables are:
        - Arguments
        - 2 SpinBoxes
        - a list if multiple modification are done at the same time

        This object concern the creation of the OwnerTab's user interface.

        The "init_owner" function automatically create the interfaces depending on the number of owners.
        The "switch_parcel" function allow the user to switch the owner of 2 parcels depending on the number in the 2
        SpinBoxes.
        The "write_changes" function transfer a variable to the function which keep tracks of all modifications.
        Those function are other method from the class UiCreationOwnerModification. Each of them are described in their
        individual docstring.
        """
        self.tab_manager = tab_manager
        self.parcel_layer = parcel_layer
        self.project = project
        self.first_spinbox = None
        self.second_spinbox = None
        self._multiple_actions = []

    # Functions to create the interface on owner, switch owner and create covers
    def init_owner(self, tab_widget, tab_index, max_owner):
        """Place the buttons on the owner tab.
        The mandatory arguments are :
        - the index of the owner tab

        For each number between 0 and the maximum number of owner a button is created.
        The first one (0) is the municipality, all the other have a label "Owner " plus the owner number.
        If there is less than 12 owner, only 2 columns of buttons are created, if there is more, 3 columns are created.
        Another button is added at the bottom of the other to delete the cover.
        After the buttons, the tools to switch owners between two parcels are added to the interface. It's 2 SpinBoxes
        and 1 button.
        """
        # Label creation
        label_top = QLabel(tab_widget.widget(tab_index))
        label_top.setFont(regular_font)
        label_top.setGeometry(10, 25, 650, 30)
        label_top.setText(owner_selection_top_label)

        # First button position
        x_place = 50
        y_place = 75
        # If there is less than 12 person, only two columns of buttons are created.
        if max_owner < 11:
            for i in range(max_owner + 1):
                button = QPushButton(tab_widget.widget(tab_index))
                button.setFont(regular_font)
                # Buttons are vertically spaced (y-axis) by a value of 70 plus a multiple of 30.
                # The first button (index 0) value is 70 (70 + 0 x 30),
                # the second (index 1) is 70 as well (70 + (1 - 1) x 30),
                # the third (index 2) is 130 (70 + 2 x 30).
                # Every index not divisible by 2 have the same y-axis value as the previous button.
                # Owner number 0 is the municipality.
                if i == 0:
                    button.setText(municipality_button_name)
                    button.setGeometry(100, i * 30 + 70, 200, 40)
                else:
                    button.setText(owner_button_name + str(i))
                    # If index is divisible by 2, the button is place in the first column (2, 4, 6, etc...).
                    if i % 2 == 0:
                        button.setGeometry(100, i * 30 + 70, 200, 40)
                    # If index is not divisible by 2, the button is place in the second column.
                    else:
                        button.setGeometry(350, (i - 1) * 30 + 70, 200, 40)

                button.clicked.connect(lambda state, owner_number=i: self.tab_manager.create_cover(owner_number))
        # If there is more than 12 person, three columns of buttons are created.
        else:
            for i in range(max_owner + 1):
                button = QPushButton(tab_widget.widget(tab_index))
                # Owner number 0 is the municipality
                if i == 0:
                    button.setText(municipality_button_name)
                else:
                    button.setText(owner_button_name + str(i))

                button.setGeometry(x_place, y_place, 150, 40)
                button.clicked.connect(lambda state, owner_number=i: self.tab_manager.create_cover(owner_number))
                # Position of the next button
                if x_place >= 450:
                    # After a certain value on the x-axis it's a new line is started.
                    x_place = 50
                    y_place += 50
                else:
                    # While the limit on the x-axis is not outmoded a button is added on the same line.
                    x_place += 200
        # As this tab is unique, standard buttons, labels and spinboxes are added to the init function.
        # Creation of the button to withdraw the cover.
        button_null = QPushButton(tab_widget.widget(tab_index))
        button_null.setFont(regular_font)
        button_null.setText(remove_cover_button_name)
        button_null.setGeometry(20, 420, 600, 30)
        # Function connected to the signal emitted by the button.
        button_null.clicked.connect(self.tab_manager.delete_cover)
        # Labels creation.
        label_switch = QLabel(tab_widget.widget(tab_index))
        label_switch.setFont(regular_font)
        label_switch.setGeometry(10, 490, 650, 30)
        label_switch.setText(switch_parcels_owner_label_pt1)
        label_switch_1 = QLabel(tab_widget.widget(tab_index))
        label_switch_1.setFont(regular_font)
        label_switch_1.setGeometry(10, 530, 190, 30)
        label_switch_1.setText(switch_parcels_owner_label_pt2)
        label_switch_2 = QLabel(tab_widget.widget(tab_index))
        label_switch_2.setFont(regular_font)
        label_switch_2.setGeometry(310, 530, 190, 30)
        label_switch_2.setText(switch_parcels_owner_label_pt3)
        # Creation of the SpinBoxes to switch  parcel ownership.
        list_id_selected = []
        for parcel in self.parcel_layer.getFeatures():
            attrs = parcel.attributes()

            # Add only the id of parcels with owner. And parcels not belonging to the municipality.
            if attrs[self.parcel_layer.fields().indexFromName(field_parcel_owner)] != 0:
                list_id_selected.append(parcel.id())
        # SpinBoxes creation, class created based on QSpinBox. Both will contain an id of the parcels to switch.
        self.first_spinbox = SpinBoxes(tab_widget.widget(tab_index))
        self.second_spinbox = SpinBoxes(tab_widget.widget(tab_index))
        # Place the SpinBoxes.
        self.first_spinbox.setGeometry(210, 530, 71, 26)
        self.second_spinbox.setGeometry(490, 530, 71, 26)
        # ManagerSpinBox creation. It will control the values of the SpinBoxes and correct them if needed.
        manager_spin_boxes = ManagerSpinBoxes()
        # Defining values needed for the manager.
        manager_spin_boxes.defineValues(list_id_selected)
        # Then, add to the SpinBoxes the manager needed
        self.first_spinbox.addManager(manager_spin_boxes)
        self.second_spinbox.addManager(manager_spin_boxes)
        # Method used to define beginning values of each spinBox
        manager_spin_boxes.set_begin_values()
        # Creation of the button to make the switch between the two parcels selected by the SpinBoxes.
        button_switch = QPushButton(tab_widget.widget(tab_index))
        button_switch.setFont(regular_font)
        button_switch.setText(switch_parcel_owner_button_name)
        button_switch.setGeometry(20, 590, 600, 30)
        button_switch.clicked.connect(self.switch_parcel)  # Function connected to the signal emitted by the button.
        # button_switch.clicked.connect(switch_parcel)  # Function connected to the signal emitted by the button.

# Functions to switch owner of a parcel
    def switch_parcel(self):
        """Switch the owners of two parcels. The parcels are selected with the 2 SpinBoxes.
        The function is launched when the specific button is clicked on.

        First we select the two parcels to switch.
        We then check if the owner is different. If it's not, an error message is send to the user.
        If the owner is different, the owners are changed.
        """
        # Selection of the two parcels based on the SpinBoxes values.
        self.parcel_layer.selectByExpression(
            "{field_id} = '{num_parcel_1}' or {field_id} = '{num_parcel_2}'".format(
                field_id=field_parcel_id,
                num_parcel_1=int(self.first_spinbox.value()), num_parcel_2=int(self.second_spinbox.value())))
        # Check if the owners are different.
        attrs = self.parcel_layer.selectedFeatures()[0].attributes()
        owner_1 = attrs[self.parcel_layer.fields().indexFromName(field_parcel_owner)]
        attrs = self.parcel_layer.selectedFeatures()[1].attributes()
        owner_2 = attrs[self.parcel_layer.fields().indexFromName(field_parcel_owner)]
        # If the owner is the same, an error message is send.
        if owner_1 == owner_2:
            QMessageBox.information(None, information_selection_error, information_switch_parcel_owner_error)
            self.parcel_layer.removeSelection()
        else:
            # The action will concern several features, every lines created in the CSV must have the same action id.
            self.multiple_actions = self.parcel_layer.selectedFeatureIds()
            # Change the owners of the two parcels.
            self.parcel_layer.startEditing()
            self.parcel_layer.changeAttributeValue(self.parcel_layer.selectedFeatures()[0].id(),
                                                   self.parcel_layer.fields().indexFromName(
                                                       field_parcel_owner), owner_2)
            self.parcel_layer.changeAttributeValue(self.parcel_layer.selectedFeatures()[1].id(),
                                                   self.parcel_layer.fields().indexFromName(
                                                       field_parcel_owner), owner_1)
            self.parcel_layer.commitChanges()
            self.parcel_layer.triggerRepaint()
            self.parcel_layer.removeSelection()
            # If a cover already exists, it is recreate in case the parcels switched were concerned by the cover.
            names = [layer.name() for layer in self.project.mapLayers().values()]
            for string in names:
                if len(string.split(owner_cover_layer_name, 1)) > 1:
                    owner = string.split(owner_cover_layer_name, 1)[1]
                    self.tab_manager.create_cover(owner)
            self._multiple_actions = []

    def write_change(self):
        return self.multiple_actions


class UiCreationDrainModification:
    def __init__(self, tab_widget=None, parcel_layer=None, line_layer=None):
        """Arguments are :
        - tab widget
        - parcel layer
        - line layer

        Variables are:
        - Arguments
        - a list if multiple modification are done at the same time

        This object concern the creation of the DrainTab's user interface.

        The "init_drain" function automatically create the interfaces depending on the presence of the config file
        drain.csv.
        The "modif..." functions allow the user to add or remove ztha or mouillere.
        The "write_change" function transfer a variable to the function which keep tracks of all modifications.
        Those function are other method from the class UiCreationDrainModification. Each of them are described in their
        individual docstring.
        """
        self.tab_widget = tab_widget
        self.parcel_layer = parcel_layer
        self.line_layer = line_layer
        self.multiple_actions = []  # List used when multiple features are modified at the same time. Every feature

    # Functions to create the interface on drain management
    def init_drain(self, tab_widget, tab_index, drain_type):
        """Place the buttons on the drain management tab.
        The mandatory arguments are :
        - the index of the drain tab

        For each number between 0 and the maximum number of owner a button is created.
        The first one (0) is the municipality, all the other have a label "Owner " plus the owner number.
        If there is less than 12 owner, only 2 columns of buttons are created, if there is more, 3 columns are created.
        Another button is added at the bottom of the other to delete the cover.
        After the buttons, the tools to switch owners between two parcels are added to the interface. It's 2 SpinBoxes
        and 1 button.
        """
        # Label creation
        label_top = QLabel(tab_widget.widget(tab_index))
        label_top.setFont(regular_font)
        label_top.setGeometry(10, 25, 650, 30)
        label_top.setText(drain_selection_top_label)

        # First button position
        x_place = 25
        y_place = 75

        for elem in drain_type:
            # Every button is a ButtonPointer.
            button = QPushButton(tab_widget.widget(tab_index))
            button.setFont(regular_font)
            button_name = str(drain_type[elem]) + " " + str(elem)
            # Change the name if it's too long for the button size.
            if len(button_name) > 15:
                # Get indexes where there is a '_', so we can cut the labels between words and not in the middle of one.
                res = [i for i in range(len(button_name)) if button_name.startswith('_', i)]
                for i in range(len(res)):
                    if res[i] > 17:
                        button_name = button_name[0:res[i]] + '\n' + button_name[res[i] + 1:]
                        while (res[i] < 30 and res[i] < len(
                                res)):  # Loop to avoid too much \n and potentially add one if >30.
                            i += 1
                            if res[i] > 30:
                                button_name = button_name[0:res[i]] + '\n' + button_name[res[i] + 1:]
                                break
                        break
            button_name = str(button_name.replace('_', ' ').capitalize())  # Transform last '_' to spaces.
            button.setText(button_name)
            button.setGeometry(x_place, y_place, 175, 35)
            if drain_type[elem] != "ZTHA":
                # Function of the QPushButton used when the button is clicked. Launch the modification of the feature.
                button.clicked.connect(lambda state, id_parcel_drain=int(elem): self.modif_mouillere(id_parcel_drain))
            else:
                # Function of the QPushButton used when the button is clicked. Launch the modification of the feature.
                button.clicked.connect(lambda state, id_parcel_drain=int(elem): self.modif_ztha(id_parcel_drain))
            # Position of the next button
            if x_place >= 375:
                # After a certain value on the x-axis it's a new line is started.
                x_place = 25
                y_place += 50
            else:
                # While the limit on the x-axis is not outmoded a button is added on the same line.
                x_place += 200

    def modif_mouillere(self, id_parcel_drain):
        drain_id = self.parcel_layer.getFeature(id_parcel_drain).attributes()[
            self.parcel_layer.fields().indexFromName(field_parcel_drain_id)]
        value_actif_old = self.parcel_layer.getFeature(id_parcel_drain).attributes()[
            self.parcel_layer.fields().indexFromName(field_parcel_drain_enabled)]
        if value_actif_old == 1:
            value_actif = 0
            value_type = 0
        else:
            value_actif = 1
            value_type = drain
        self.multiple_actions = [id_parcel_drain, drain_id]
        self.parcel_layer.startEditing()
        self.parcel_layer.changeAttributeValue(id_parcel_drain,
                                               self.parcel_layer.fields().indexFromName(field_parcel_drain_enabled),
                                               value_actif)
        self.parcel_layer.commitChanges()
        self.parcel_layer.triggerRepaint()
        self.line_layer.startEditing()
        self.line_layer.changeAttributeValue(drain_id, self.line_layer.fields().indexFromName(field_line_drain_enabled),
                                             value_actif)
        self.line_layer.changeAttributeValue(drain_id,
                                             self.line_layer.fields().indexFromName(field_type_line_middle),
                                             value_type)

        self.line_layer.commitChanges()
        self.line_layer.triggerRepaint()
        self.multiple_actions = []

    def modif_ztha(self, id_parcel_drain):
        value_type_old = self.parcel_layer.getFeature(id_parcel_drain).attributes()[
            self.parcel_layer.fields().indexFromName(field_parcel_drain_type)]
        if value_type_old == 3:
            value_type = 2
        else:
            value_type = 3
        self.parcel_layer.startEditing()
        self.parcel_layer.changeAttributeValue(id_parcel_drain,
                                               self.parcel_layer.fields().indexFromName(field_parcel_drain_type),
                                               value_type)
        self.parcel_layer.commitChanges()
        self.parcel_layer.triggerRepaint()

    def write_change(self):
        return self.multiple_actions


class UiCreationMultipleModification:
    def __init__(self, parent=None, tab_widget=None, checkbox_owner=None, spinbox_owner=None, production_type=None):
        """Arguments are :
        - tab manager instance
        - a checkbox which inform if the user wants to modify all parcels of an owner
        - a spinbox to specify the owner

        Variables are:
        - Arguments
        - the value of the element before modification
        - a list to tell if multiples features are involved

        This object concern the creation of the MultiLineTab, MultiParcelTab, PracticesTab user interface.

        The "init_multiples" function automatically create the interfaces depending on the number of land cover,
        line type or practices.
        The "is_checked" function keep tracks of the checkbox checked by the user to enable or disable buttons.
        The "modify_type_all" function is going to modify all features with the value from the selected checkbox to the
        value of the button clicked.
        The "write_changes" function transfer a variable to the function which keep tracks of all modifications.
        Those function are other method from the class UiCreationOwnerModification. Each of them are described in their
        individual docstring.
        """
        self.tab_index_agricultural_practices = parent.tab_index_agricultural_practices
        self.tab_widget = tab_widget
        self.checkbox_owner = checkbox_owner
        self.spinbox_owner = spinbox_owner
        self.production_type = production_type
        self.old_elem = None
        self._multiple_actions = []  # List used when multiple features are modified at the same time. Every feature

    @property
    def multiple_actions(self) -> list:
        return self._multiple_actions

    # Functions to create the interface and modify multiple features (parcels, lines, agricultural practices).
    # Functions to create the interface on multiple features modification.
    def init_multiples(self, tab_index, label_txt_top, label_txt_bottom, action, layer, dict_elems, fields, tab_widget):
        """Place the buttons on the specified tab index based on dictionaries, line type, land cover or
        agricultural practice. Those buttons ButtonPointer are a class imported from another python file.
        They allow the user to modify multiples features from a value specified by a checkbox to the value on the button
        clicked. Each checkbox and each button represent a different value.
        The mandatory arguments are :
        - the index of the tab they populate
        - the label to introduce the checkboxes
        - the label to introduce the buttons
        - the name of the action
        - the layer concerned by the modifications (parcel or line)
        - the dictionary to base the labels and values on
        - the field modified

        First the buttons are created and then the checkboxes.
        The order is important because the checkboxes use the buttons in a specific functions.
        For each element of the dictionary a button and a checkbox is created with the key as label and value as value.
        The first button or checkbox as a determined position, the other are placed based on the first one
        and the place left on the line. If there is no place left, the button or checkbox begins another line.
        The label are modified to fit the buttons and checkboxes, if its too long line breaks are added.
        """
        # Creation of a group of buttons, easier to enable or disable all the buttons.
        button_group_multiples = QButtonGroup(tab_widget)
        # Position of the first button. If the tab concerned is the agricultural practices, the buttons start lower.
        if tab_index == 2:
            x_place = 25
            y_place = 310
        else:
            x_place = 25
            y_place = 240
        # Label creation
        label_bottom = QLabel(self.tab_widget.widget(tab_index))
        label_bottom.setFont(regular_font)
        label_bottom.setGeometry(10, y_place - 40, 650, 30)
        label_bottom.setText(label_txt_bottom)

        # Loop on all the element of the dictionary to create a button for every element
        for elem in dict_elems:
            button_multiples = QPushButton(self.tab_widget.widget(tab_index))
            button_multiples.setFont(regular_font)
            button_name = elem
            # Change the name if it's too long for the button size
            if len(button_name) > 15:
                # Get indexes where there is a '_', so we can cut the labels between words and not in the middle of one.
                res = [i for i in range(len(button_name)) if button_name.startswith('_', i)]
                for i in range(len(res)):
                    if res[i] > 10:
                        button_name = button_name[0:res[i]] + '\n' + button_name[res[i] + 1:]
                        while (res[i] < 30 and res[i] < len(
                                res)):  # Loop to avoid too much \n and potentially add one if >30
                            i += 1
                            if res[i] > 30:
                                button_name = button_name[0:res[i]] + '\n' + button_name[res[i] + 1:]
                                break
                        break
            button_name = str(button_name.replace('_', ' ').capitalize())  # Transform last _ to spaces
            button_multiples.setText(button_name)
            button_multiples.setAccessibleName(str(action))  # The action name is stocked inside the button
            button_multiples.setGeometry(x_place, y_place, 175, 35)
            # Function connected to the signal emitted by the button when it's clicked
            button_multiples.clicked.connect(
                lambda state, nb=dict_elems[elem]: self.modify_type_all(layer, nb, fields))
            # While a checkbox is checked all buttons are disabled
            button_multiples.setEnabled(False)
            button_group_multiples.addButton(button_multiples)
            # Position of the next button
            if x_place >= 375:
                # After a certain value on the x-axis it's a new line is started.
                x_place = 25
                y_place += 40
            else:
                # While the limit on the x-axis is not outmoded a button is added on the same line.
                x_place += 200

        # Creation of a group of checkboxes
        check_group = QButtonGroup(tab_widget)
        # Position of the first checkbox. If the tab concerned is agricultural practices, the checkboxes start lower.
        if tab_index == self.tab_index_agricultural_practices:
            x_place = 25
            y_place = 195
        else:
            x_place = 25
            y_place = 55
        # Label creation
        label_top = QLabel(self.tab_widget.widget(tab_index))
        label_top.setFont(regular_font)
        label_top.setGeometry(10, y_place - 30, 350, 30)
        label_top.setText(label_txt_top)
        i = 0
        # Loop on all the element of the dictionary to create a checkbox for every element
        for elem in dict_elems:
            # If an element as a value equal (no line) or below 0 we don't create a checkbox
            if dict_elems[elem] >= 0:
                checkbox = QCheckBox(self.tab_widget.widget(tab_index))
                checkbox.setFont(regular_font)
                checkbox_name = elem
                # Change the name if it's too long.
                if len(checkbox_name) > 15:
                    # Get indexes where there is a '_', so we can cut the labels between words
                    # and not in the middle of one.
                    res = [i for i in range(len(checkbox_name)) if checkbox_name.startswith('_', i)]
                    for i in range(len(res)):
                        if res[i] > 10:
                            checkbox_name = checkbox_name[0:res[i]] + '\n' + checkbox_name[res[i] + 1:]
                            while (res[i] < 30 and res[i] < len(
                                    res)):  # Loop to avoid too much \n and potentially add one if >30
                                i += 1
                                if res[i] > 30:
                                    checkbox_name = checkbox_name[0:res[i]] + '\n' + checkbox_name[res[i] + 1:]
                                    break
                            break
                checkbox_name = str(checkbox_name.replace('_', ' ').capitalize())  # Transform last _ to spaces
                checkbox.setText(checkbox_name)
                checkbox.setGeometry(x_place, y_place, 175, 35)
                check_group.addButton(checkbox)
                i += 1
                # Function connected to the signal emitted by the checkbox when it state change.
                checkbox.stateChanged.connect(
                    lambda state, button=checkbox, checkbox_value=dict_elems[elem], button_group=button_group_multiples:
                    self.is_checked(button, checkbox_value, button_group))
                # Position of the next checkbox
                if x_place >= 375:
                    # After a certain value on the x-axis it's a new line is started.
                    x_place = 25
                    y_place += 30
                else:
                    # While the limit on the x-axis is not outmoded a button is added on the same line.
                    x_place += 200

        check_group.setExclusive(True)

    def is_checked(self, checkbox, checkbox_value, button_group):
        """Enabled buttons used for the modification of multiple features when a checkbox is checked.
        The mandatory arguments are :
        - the checkbox checked
        - the value of the checkbox checked
        - the group of buttons to enable
        """
        if checkbox.isChecked():
            # New variable used only in the function modify_type_all connected to the buttons of the new value
            self.old_elem = checkbox_value
            # Every buttons are enabled when a checkbox is checked except the one with the same value as the checkbox.
            for button in button_group.buttons():
                if checkbox.text() == button.text():
                    button.setEnabled(False)
                else:
                    button.setEnabled(True)

    # Functions to modify multiples features (parcels, lines, agricultural practices)
    def modify_type_all(self, layer, new, fields):
        """Modify multiple features when a checkbox is checked and a button clicked.
        The mandatory arguments are :
        - the layer concerned
        - the new value
        - the field to modify
        """
        self._multiple_actions = []
        # Value of the checkbox checked to select the features to modify.
        old = self.old_elem
        if old is not None:
            # If the user only want to modify the features of one owner,
            # the number of the owner is required to make the selection.
            for field in fields:
                layer.selectByExpression("{field} = '{old_value}'".format(field=field, old_value=old),
                                         QgsVectorLayer.AddToSelection)
            if self.checkbox_owner:
                if self.checkbox_owner.isChecked():
                    owner = self.spinbox_owner.value()
                    layer.removeSelection()
                    for field in fields:
                        layer.selectByExpression(
                            "{field} = '{old_value}' and {owner_field} = '{owner}'".format(
                                field=field, old_value=old, owner_field=field_parcel_owner, owner=owner),
                            QgsVectorLayer.AddToSelection)
            # Add features to be modified to a list of id.
            features_id = layer.selectedFeatureIds()
            if len(features_id) > 0:
                self._multiple_actions = [-1]
                # The action will concern several features, every lines created in the CSV must have the same
                # action id.
                self.multiple_actions.extend(features_id)
                attrs = layer.getFeature(features_id[0]).attributes()
                for field in fields:
                    old_value = attrs[layer.fields().indexFromName(field)]
                    if old_value == old and old_value != new:
                        # Function to modify every features with the new value. This is a method from ParcelLayer
                        # and LineLayer.
                        layer.handle_value_changed(field, features_id, new, old)
            # Else different error message might appear.
            else:
                QMessageBox.information(None, information_selection_error, information_modification_multiple_error_1)
            layer.removeSelection()
        else:
            QMessageBox.information(None, information_selection_error, information_modification_multiple_error_2)
        # Empty the list of id for the action id.
        self._multiple_actions = []

    def write_change(self):
        return self.multiple_actions
