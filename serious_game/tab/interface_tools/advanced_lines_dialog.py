# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeomelbaSpirit
                                 A QGIS plugin
 Based on GeoMelba software, meant to be used with the serious game CAUSERIE.
 This file contains the functions to configure the dialog used to add multiple type of line on one element.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-08-24
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Jules Grillot / INRAE
        email                : jules.grillot@inrae.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
# Qgis & Qt Modules
from qgis.PyQt import uic
from qgis.PyQt.QtWidgets import QDialog, QPushButton, QButtonGroup, QTableWidget, QTableWidgetItem
from qgis.PyQt.QtCore import pyqtSignal, Qt
from PyQt5.QtWidgets import QAbstractItemView, QShortcut, QDesktopWidget
# Personal Modules
from .buttonpointer import ButtonPointer
from ....dictionnaire import river, riparian_forest, field_type_line_top, field_type_line_middle, \
    field_type_line_bottom, field_line_parcel_above, field_line_parcel_below, regular_font, upgrade_line_button_name, \
    downgrade_line_button_name, validate_modification_button_name, select_line_button_name, \
    line_table_horizontal_header, line_table_vertical_header_top, line_table_vertical_header_middle, \
    line_table_vertical_header_bottom


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'advanced_lines_dialog.ui'))


class AdvancedLinesDialog(QDialog, FORM_CLASS):
    closingPlugin = pyqtSignal()

    def __init__(self, parent=None, canvas=None, line_layer=None, line_type=None):
        """The first part of the constructor list the variables.
         Variables are :
        - canvas of gqis
        - the line layer to modify
        - the types of line in the watershed

        The second part is the interface creation :
        - 4 buttons
        - multiple buttons depending on the number of line types
        - a table with 1 column and 3 lines to the represent the type of a line at the top, middle and bottom.
        """
        super(AdvancedLinesDialog, self).__init__(parent)
        self.button_select = ButtonPointer(self)
        self.height = QDesktopWidget().screenGeometry(0).height()
        self.width = QDesktopWidget().screenGeometry(0).width()
        # self.button_select.clicked.connect(self.window_on_bottom)
        self.button_select.setFont(regular_font)
        self.table_type = QTableWidget(self)
        QShortcut(Qt.Key_Up, self.table_type, activated=self.key_press)
        QShortcut(Qt.Key_Down, self.table_type, activated=self.key_press)
        self.table_type.setFont(regular_font)
        self.button_group = QButtonGroup(self)
        self.button_edit = QPushButton(self)
        self.button_edit.setFont(regular_font)
        self.button_dwn = QPushButton(self)
        self.button_dwn.setFont(regular_font)
        self.button_up = QPushButton(self)
        self.button_up.setFont(regular_font)
        self.canvas = canvas
        self.line_layer = line_layer
        self.line_type = line_type
        self.setup_ui()

    def setup_ui(self):
        # Set up the user interface from Designer through FORM_CLASS.
        self.setupUi(self)
        # Button to put the selected line on at the position above.
        self.button_up.setGeometry(150, 120, 130, 30)
        self.button_up.setText(upgrade_line_button_name)
        self.button_up.setEnabled(False)
        self.button_up.clicked.connect(self.change_order_up)
        # Button to put the selected line on at the position below.
        self.button_dwn.setGeometry(150, 180, 130, 30)
        self.button_dwn.setText(downgrade_line_button_name)
        self.button_dwn.setEnabled(False)
        self.button_dwn.clicked.connect(self.change_order_dwn)
        # Button to save the modification.
        self.button_edit.setGeometry(150, 580, 300, 30)
        self.button_edit.setText(validate_modification_button_name)
        self.button_edit.setEnabled(False)
        self.button_edit.clicked.connect(self.edit_lines)
        x_place = 25
        y_place = 275
        # Button of line style creation.
        for line in self.line_type:
            if self.line_type[line] != river:
                button = QPushButton(self)
                button.setFont(regular_font)
                button_name = line + " (" + str(self.line_type[line]) + ")"
                # Change the name if it's too long for the button size
                if len(button_name) > 15:
                    # Get indexes where there is a '_', so we can cut the labels between words and not in the middle
                    # of one.
                    res = [i for i in range(len(button_name)) if button_name.startswith('_', i)]
                    for i in range(len(res)):
                        if res[i] > 17:
                            button_name = button_name[0:res[i]] + '\n' + button_name[res[i] + 1:]
                            while (res[i] < 30 and res[i] < len(
                                    res)):  # Loop to avoid too much \n and potentially add one if >30
                                i += 1
                                if res[i] > 30:
                                    button_name = button_name[0:res[i]] + '\n' + button_name[res[i] + 1:]
                                    break
                            break
                button_name = str(button_name.replace('_', ' ').capitalize())  # Transform last _ to spaces
                button.setText(button_name)
                button.setAccessibleName(str(self.line_type[line]))
                if self.line_type[line] == 0:
                    button.setGeometry(240, 530, 131, 28)
                else:
                    button.setGeometry(x_place, y_place, 175, 35)
                # Function connected to the signal emitted by the button when it's clicked.
                button.clicked.connect(
                    lambda state, new_value=self.line_type[line]: self.edit_line_value(new_value))
                button.show()
                self.button_group.addButton(button)
                # Position of the next button
                if x_place >= 375:
                    # After a certain value on the x-axis it's a new line is started.
                    x_place = 25
                    y_place += 50
                else:
                    # While the limit on the x-axis is not outmoded a button is added on the same line.
                    x_place += 200

        for button in self.button_group.buttons():
            button.setEnabled(False)
        # Table Creation
        self.table_type.setGeometry(320, 100, 151, 121)
        # Not enabled until a feature is selected.
        self.table_type.setEnabled(False)
        # Set the size of the table.
        self.table_type.setColumnCount(1)
        self.table_type.setRowCount(3)
        # Set label of the table.
        self.table_type.setHorizontalHeaderLabels(line_table_horizontal_header)
        self.table_type.setVerticalHeaderLabels([line_table_vertical_header_top, line_table_vertical_header_middle,
                                                 line_table_vertical_header_bottom])
        # Disable the edit mode, which means the user cannot write in the cell.
        self.table_type.setEditTriggers(QAbstractItemView.NoEditTriggers)
        # Set the default values.
        self.table_type.setItem(0, 0, QTableWidgetItem("0"))
        self.table_type.setItem(1, 0, QTableWidgetItem("0"))
        self.table_type.setItem(2, 0, QTableWidgetItem("0"))
        # Button to select a feature.
        self.button_select.setGeometry(150, 50, 300, 30)
        self.button_select.setText(select_line_button_name)
        self.button_select.setAccessibleName(str("advanced_modification"))
        self.line_layer.selectionChanged.connect(self.selected_line)
        # Function connected to the signal emitted when the button is clicked.
        self.button_select.on_click(self.button_select, self.canvas, self.line_layer.sourceCrs(), self.line_layer,
                                    "none", "none")
        # Function connected to the signal emitted when a cell is clicked.
        self.table_type.cellClicked.connect(self.enable_type_buttons)

    def open_dialog(self):
        # Not enabled until a feature is selected.
        self.table_type.setEnabled(False)
        # Set the default values.
        self.table_type.setItem(0, 0, QTableWidgetItem("0"))
        self.table_type.setItem(1, 0, QTableWidgetItem("0"))
        self.table_type.setItem(2, 0, QTableWidgetItem("0"))
        self.button_up.setEnabled(False)
        self.button_dwn.setEnabled(False)
        self.button_edit.setEnabled(False)
        self.setWindowFlags(Qt.WindowStaysOnTopHint)
        self.show()
        self.move(int((self.width/4) * 2.5), int(self.height/4))

    def selected_line(self, selected):
        """Function to update the table value depending on the line selected.
        If a feature is selected the table is enabled and the 3 lines are completed by the line types.
        The mandatory arguments are :
        - the id of the feature selected
        """

        if len(selected) == 1:
            self.table_type.setEnabled(True)
            self.table_type.clearSelection()
            for button in self.button_group.buttons():
                button.setEnabled(False)
            self.button_edit.setEnabled(True)
            self.button_up.setEnabled(True)
            self.button_dwn.setEnabled(True)
            # Zoom on the modified feature.
            if len(self.line_layer.selectedFeatures()) > 0:
                box = self.line_layer.boundingBoxOfSelected()
                box.grow(50)
                self.canvas.setExtent(box)
                self.canvas.refresh()
            # Get the selected feature attributes.
            attrs = self.line_layer.getFeature(selected[0])
            type_up = attrs[self.line_layer.fields().indexFromName(field_type_line_top)]
            type_mid = attrs[self.line_layer.fields().indexFromName(field_type_line_middle)]
            type_dwn = attrs[self.line_layer.fields().indexFromName(field_type_line_bottom)]
            up = attrs[self.line_layer.fields().indexFromName(field_line_parcel_above)]
            dwn = attrs[self.line_layer.fields().indexFromName(field_line_parcel_below)]
            self.table_type.setVerticalHeaderLabels([line_table_vertical_header_top + " (" + str(up) + ")",
                                                     line_table_vertical_header_middle,
                                                     line_table_vertical_header_bottom + " (" + str(dwn) + ")"])
            # Update the table with the feature attributes.
            if not type_up:
                type_up=0
            self.table_type.setItem(0, 0, QTableWidgetItem(str(int(type_up))))
            if not type_mid:
                type_mid=0

            self.table_type.setItem(1, 0, QTableWidgetItem(str(int(type_mid))))
            if not type_dwn:
                type_dwn=0
            self.table_type.setItem(2, 0, QTableWidgetItem(str(int(type_dwn))))
        else:
            # Not enabled until a feature is selected.
            self.table_type.setEnabled(False)
            # Set the default values.
            self.table_type.setItem(0, 0, QTableWidgetItem("0"))
            self.table_type.setItem(1, 0, QTableWidgetItem("0"))
            self.table_type.setItem(2, 0, QTableWidgetItem("0"))
            self.button_up.setEnabled(False)
            self.button_dwn.setEnabled(False)
            self.button_edit.setEnabled(False)
            self.setModal(False)

    def edit_line_value(self, new_value):
        """Function to modify a value on the table by clicking on a type button.
        The table can only have one cell selected, this cell's indexes are retrieved to change it's value.
        The mandatory arguments are :
        - the new value of the cell
        """
        # Retrieve the cell's indexes.
        row_index = self.table_type.selectedIndexes()[0].row()
        column_index = self.table_type.selectedIndexes()[0].column()
        # Modify the value of the cell.
        self.table_type.setItem(row_index, column_index, QTableWidgetItem(str(new_value)))
        self.table_type.clearSelection()
        self.button_up.setEnabled(False)
        self.button_dwn.setEnabled(False)
        for button in self.button_group.buttons():
            button.setEnabled(False)
        self.setModal(False)

    def change_order_up(self):
        """Function connected to the signal of the button up. When clicked, the value of the selected cell switch place
        with the above cell. Nothing happened if the selected cell is the one at the top.
        """
        # Get the selected cell's indexes.
        row_index = self.table_type.selectedIndexes()[0].row()
        column_index = self.table_type.selectedIndexes()[0].column()
        if row_index != 0:
            # If the selected cell is not the one at the top of the table, switch it's value with the cell above.
            value_1 = self.table_type.item(row_index, column_index).text()
            value_2 = self.table_type.item(row_index - 1, column_index).text()
            self.table_type.setItem(row_index - 1, column_index, QTableWidgetItem(value_1))
            self.table_type.setItem(row_index, column_index, QTableWidgetItem(value_2))
            self.table_type.setCurrentItem(self.table_type.item(row_index - 1, column_index))

    def change_order_dwn(self):
        """Function connected to the signal of the button dwn. When clicked, the value of the selected cell switch place
        with the below cell. Nothing happened if the selected cell is the one at the bottom.
        """
        # Get the selected cell's indexes.
        row_index = self.table_type.selectedIndexes()[0].row()
        column_index = self.table_type.selectedIndexes()[0].column()
        if row_index != 2:
            # If the selected cell is not the one at the bottom of the table, switch it's value with the cell below.
            value_1 = self.table_type.item(row_index, column_index).text()
            value_2 = self.table_type.item(row_index + 1, column_index).text()
            self.table_type.setItem(row_index + 1, column_index, QTableWidgetItem(value_1))
            self.table_type.setItem(row_index, column_index, QTableWidgetItem(value_2))
            self.table_type.setCurrentItem(self.table_type.item(row_index + 1, column_index))

    def enable_type_buttons(self):
        """Function to disable or enable the type buttons depending on the line selected.
        If the value of the middle is a river, it's not possible to change the order of the type, the user can only add
        a line type on each side of the river.
        If the value of the middle is not a river, the user cannot add a riparian forest.
        """
        middle_value = self.table_type.item(1, 0).text()
        # if the middle value is a river order buttons are disabled. All type buttons are enabled when the top or bottom
        # cell is clicked. No cell are enabled if the middle cell is clicked.
        if middle_value == str(river):
            self.button_up.setEnabled(False)
            self.button_dwn.setEnabled(False)
            if self.table_type.item(1, 0).isSelected():
                for button in self.button_group.buttons():
                    button.setEnabled(False)
            else:
                for button in self.button_group.buttons():
                    button.setEnabled(True)
        # Else all buttons are enabled except the one for the riparian forest.
        else:
            for button in self.button_group.buttons():
                if button.accessibleName() == str(riparian_forest):
                    button.setEnabled(False)
                else:
                    button.setEnabled(True)
            self.button_up.setEnabled(True)
            self.button_dwn.setEnabled(True)
        self.button_edit.setEnabled(True)

    def edit_lines(self):
        """Function connected to the modification button. Change the value of the types columns depending on the table
        values. If one of the type columns is not equal to 0, the middle type must be different from 0. When the
        modification are made a zoom on the feature is made to show the changes. The selection and table is reset.
        """
        up_value = self.table_type.item(0, 0).text()
        middle_value = self.table_type.item(1, 0).text()
        down_value = self.table_type.item(2, 0).text()
        self.line_layer.startEditing()
        # If the middle value is equal to 0, check the other values.
        if middle_value == "0":
            # If top and bottom values are different from 0. The middle value receive the bottom value and the bottom
            # value gets 0.
            if down_value != "0" and up_value != "0":
                self.line_layer.changeAttributeValue(self.line_layer.selectedFeatureIds()[0],
                                                     self.line_layer.fields().indexFromName(field_type_line_middle),
                                                     down_value)
                self.line_layer.changeAttributeValue(self.line_layer.selectedFeatureIds()[0],
                                                     self.line_layer.fields().indexFromName(
                                                         field_type_line_top), up_value)
                self.line_layer.changeAttributeValue(self.line_layer.selectedFeatureIds()[0],
                                                     self.line_layer.fields().indexFromName(
                                                         field_type_line_bottom),
                                                     0)
            # If the top value is different from 0 but not the bottom one. The middle value receive the top value and
            # the other values get 0.
            elif up_value != "0" and down_value == "0":
                self.line_layer.changeAttributeValue(self.line_layer.selectedFeatureIds()[0],
                                                     self.line_layer.fields().indexFromName(field_type_line_middle),
                                                     up_value)
                self.line_layer.changeAttributeValue(self.line_layer.selectedFeatureIds()[0],
                                                     self.line_layer.fields().indexFromName(field_type_line_top),
                                                     0)
                self.line_layer.changeAttributeValue(self.line_layer.selectedFeatureIds()[0],
                                                     self.line_layer.fields().indexFromName(
                                                         field_type_line_bottom),
                                                     0)
            # If the bottom value is different from 0 but not the top one. The middle value receive the bottom value and
            # the other values get 0.
            elif up_value == "0" and down_value != "0":
                self.line_layer.changeAttributeValue(self.line_layer.selectedFeatureIds()[0],
                                                     self.line_layer.fields().indexFromName(field_type_line_middle),
                                                     down_value)
                self.line_layer.changeAttributeValue(self.line_layer.selectedFeatureIds()[0],
                                                     self.line_layer.fields().indexFromName(
                                                         field_type_line_top),
                                                     0)
                self.line_layer.changeAttributeValue(self.line_layer.selectedFeatureIds()[0],
                                                     self.line_layer.fields().indexFromName(
                                                         field_type_line_bottom),
                                                     0)
            # If every values are equals to 0, all the values gets 0.
            else:
                self.line_layer.changeAttributeValue(self.line_layer.selectedFeatureIds()[0],
                                                     self.line_layer.fields().indexFromName(field_type_line_middle),
                                                     0)
                self.line_layer.changeAttributeValue(self.line_layer.selectedFeatureIds()[0],
                                                     self.line_layer.fields().indexFromName(
                                                         field_type_line_top), 0)
                self.line_layer.changeAttributeValue(self.line_layer.selectedFeatureIds()[0],
                                                     self.line_layer.fields().indexFromName(
                                                         field_type_line_bottom),
                                                     0)
        # Else the feature gets the values from the table.
        else:
            self.line_layer.changeAttributeValue(self.line_layer.selectedFeatureIds()[0],
                                                 self.line_layer.fields().indexFromName(field_type_line_middle),
                                                 int(middle_value))
            self.line_layer.changeAttributeValue(self.line_layer.selectedFeatureIds()[0],
                                                 self.line_layer.fields().indexFromName(
                                                     field_type_line_top), int(up_value))
            self.line_layer.changeAttributeValue(self.line_layer.selectedFeatureIds()[0],
                                                 self.line_layer.fields().indexFromName(
                                                     field_type_line_bottom), int(down_value))
        self.line_layer.commitChanges()
        self.line_layer.triggerRepaint()
        # Reset the selection, table and buttons enabled or disabled.
        self.line_layer.removeSelection()
        self.table_type.setItem(0, 0, QTableWidgetItem("0"))
        self.table_type.setItem(1, 0, QTableWidgetItem("0"))
        self.table_type.setItem(2, 0, QTableWidgetItem("0"))
        for button in self.button_group.buttons():
            button.setEnabled(False)
        self.table_type.clearSelection()
        self.table_type.setEnabled(False)
        self.button_up.setEnabled(False)
        self.button_dwn.setEnabled(False)
        self.button_edit.setEnabled(False)

    def key_press(self):
        pass

    def window_on_bottom(self):
        self.setWindowFlags(Qt.WindowStaysOnBottomHint)

    # Function launch when the plugin is closed
    def closeEvent(self, event):
        """Add action when the plugin is closed.
        The mandatory arguments are :
        - an event on the plugin
        """
        # Not enabled until a feature is selected.
        self.table_type.setEnabled(False)
        # Set the default values.
        self.table_type.setVerticalHeaderLabels([line_table_vertical_header_top, line_table_vertical_header_middle,
                                                 line_table_vertical_header_bottom])
        self.table_type.setItem(0, 0, QTableWidgetItem("0"))
        self.table_type.setItem(1, 0, QTableWidgetItem("0"))
        self.table_type.setItem(2, 0, QTableWidgetItem("0"))
        self.button_up.setEnabled(False)
        self.button_dwn.setEnabled(False)
        self.button_edit.setEnabled(False)
        # Select all features of the parcel layer.
        self.line_layer.selectAll()
        # Get the bounding box
        box = self.line_layer.boundingBoxOfSelected()
        # Set the bounding box as extent of the canvas.
        self.canvas.setExtent(box)
        self.canvas.refresh()
        # Remove the selection.
        self.line_layer.removeSelection()
        event.accept()
