# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeomelbaSpirit
                                 A QGIS plugin
 Based on GeoMelba software, meant to be used with the serious game CAUSERIE.
 This file contains the functions to use when the user configure the dock widget.
 Buttons and widget of the dock widget are controlled with functions from this file.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-08-24
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Jules Grillot / INRAE
        email                : jules.grillot@inrae.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import csv
import processing
from PyQt5.QtWidgets import QMessageBox, QLabel, QSpinBox, QPushButton
from qgis.core import QgsVectorLayer
from ....dictionnaire import field_parcel_id, history_table_name, history_field_action, history_field_feature, \
    history_field_layer, history_field_field, history_field_field_idx, history_field_previous, history_field_next, \
    field_parcel_practice, style_parcels_practices, parcel_layer_name, field_parcel_owner, owner_cover_layer_name, \
    field_line_drain_enabled, field_type_line_middle, field_parcel_drain_enabled, field_type_parcel, regular_font, \
    agricultural_practices_layer_name


class StandardTools:

    def __init__(self, parcel_layer=None, iface=None, path=None, project=None, scrollAreaWidgetContents=None,
                 tab_widget=None, tab_widget_management=None, config_files=None, drain_modif=None,
                 multiple_lines_modif=None, multiple_parcels_modif=None, practices_modification=None,
                 cover_creation=None, drain=None):
        self.parcel_layer = parcel_layer
        self.iface = iface
        self.path = path
        self.project = project
        self.tab_widget = tab_widget
        self.tab_widget_management = tab_widget_management
        self.config_files = config_files
        self.drain_modif = drain_modif
        self.multiple_lines_modif = multiple_lines_modif
        self.multiple_parcels_modif = multiple_parcels_modif
        self.practices_modification = practices_modification
        self.cover_creation = cover_creation
        self.drain = drain

        self.signal_stop = 0  # Variable to check if the modifications needs to be written in the CSV or NOT. If its
        # equals to 0 no changes are written.
        # river_section.
        self.action = 0  # Count the changes made to the layers so we can trace the action order in the CSV
        self.multiple_actions = []  # List used when multiple features are modified at the same time. Every feature
        # is going to be written as a line in the CSV, all the lines need to have the same number of action so every
        # features rollback to the previous state.

        # Creation of the CSV file which contains all the modification on the parcel and line layers
        with open(self.path + history_table_name, 'w') as csvfile:
            file_writer = csv.writer(csvfile, delimiter=';', quotechar='|', quoting=csv.QUOTE_MINIMAL)
            file_writer.writerow([history_field_action, history_field_layer, history_field_feature, history_field_field,
                                  history_field_field_idx, history_field_previous, history_field_next])
        # Creation of the widgets at the Top of the plugin, zoom on 1 parcel, zoom on all the watershed or rollback last
        # modification.
        # Zoom on 1 parcel.
        # Label outside of the tab to describe the tool to zoom on a parcel.
        idx = self.parcel_layer.fields().indexFromName(field_parcel_id)  # Id field index
        min_id = self.parcel_layer.minimumValue(idx)  # Get minimum value of id
        max_id = self.parcel_layer.maximumValue(idx)  # Get maximum value of id
        label_zoom_parcel = QLabel(scrollAreaWidgetContents)
        label_zoom_parcel.setFont(regular_font)
        label_zoom_parcel.setGeometry(30, 10, 500, 30)
        label_zoom_parcel.setText("Sélectionner l’identifiant de la parcelle sur laquelle vous voulez zoomer\n"
                                  "entre " + str(int(min_id)) + " et " + str(int(max_id)) + " :")
        # Spinbox to choose the parcel to zoom on.
        self.spinbox_zoom_parcel = QSpinBox(scrollAreaWidgetContents)
        self.spinbox_zoom_parcel.setFont(regular_font)
        self.spinbox_zoom_parcel.setGeometry(510, 13, 60, 25)
        self.spinbox_zoom_parcel.setMinimum(int(min_id))
        self.spinbox_zoom_parcel.setMaximum(int(max_id))
        # Button to launch the zoom function.
        button_zoom_parcel = QPushButton(scrollAreaWidgetContents)
        button_zoom_parcel.setFont(regular_font)
        button_zoom_parcel.setText("Zoomer")
        button_zoom_parcel.setAccessibleName("zoom_parcel")
        button_zoom_parcel.setGeometry(580, 13, 60, 25)
        button_zoom_parcel.clicked.connect(self.zoom_parcel)
        # Zoom on watershed
        button_zoom_watershed = QPushButton(scrollAreaWidgetContents)
        button_zoom_watershed.setFont(regular_font)
        button_zoom_watershed.setText("Zoomer sur le Bassin versant")
        button_zoom_watershed.setAccessibleName("zoom_watershed")
        button_zoom_watershed.setGeometry(390, 50, 250, 50)
        button_zoom_watershed.clicked.connect(self.zoom_watershed)
        # Rollback button
        self.button_rollback = QPushButton(scrollAreaWidgetContents)
        self.button_rollback.setFont(regular_font)
        self.button_rollback.setText("Retour Arrière")
        self.button_rollback.setAccessibleName("rollback")
        self.button_rollback.setGeometry(30, 50, 180, 50)
        self.button_rollback.setEnabled(False)
        self.button_rollback.clicked.connect(self.previous_state)

    # Functions for standard tools
    # Function to zoom on the watershed
    def zoom_watershed(self):
        """Zoom on the watershed.
        Selection of all the parcels. A method is used to retrieve the bounding box
        (4 coordinates of the smallest rectangle containing the features) of the selected element.
        Use this bounding box to zoom your canvas on.
        """
        # Select all features of the parcel layer.
        self.parcel_layer.selectAll()
        # Get the bounding box
        box = self.parcel_layer.boundingBoxOfSelected()
        # Set the bounding box as extent of the canvas.
        self.iface.mapCanvas().setExtent(box)
        self.iface.mapCanvas().refresh()
        # Remove the selection.
        self.parcel_layer.removeSelection()

    # Function to zoom on a parcel
    def zoom_parcel(self):
        """Zoom on a parcel specified by the user in a SpinBox.
        Selection of the features selected by using the number chosen by the user with the SpinBox.
        Get the bounding box of the selected feature. Use this bounding box as an extent for the canvas.
        """
        # Selection of the parcel.
        self.parcel_layer.selectByExpression(
            " {champ_id_parcel} = '{num_parcel}'".format(champ_id_parcel=field_parcel_id,
                                                         num_parcel=int(self.spinbox_zoom_parcel.text())))
        if len(self.parcel_layer.selectedFeatures()) == 1:
            # Get the bounding box of the parcel.
            box = self.parcel_layer.boundingBoxOfSelected()
            # Grow the bounding box by 50% to have a better view on the parcels around the selected parcel.
            box.grow(50)
            # Set the bounding box as extent of the canvas.
            self.iface.mapCanvas().setExtent(box)
            self.iface.mapCanvas().refresh()
            # Remove the selection.
            self.parcel_layer.removeSelection()
        elif len(self.parcel_layer.selectedFeatures()) == 0:
            QMessageBox.information(None, "Erreur de sélection, aucune parcelle ne correspond à ce numéro")
        else:
            QMessageBox.information(None, "Erreur de sélection plusieurs parcelles correspond à ce numéro")

    # Function to make a rollback
    def previous_state(self):
        """Rollback the last action made to modify the parcel layer or the line layer. If a analysis on a watershed
        is made by the user, the modification are confirmed, rollback is not possible on the action made before the
        analysis. With an open CSV file, the function retrieve the id of the modified feature, the layer of the
        feature, the modified field and its index, the old value and the new value. The CSV file is rewrited without
        the lines of the action. If there is no more lines, the rollback button become disable. Attribute are changed
        from new to old. If the modified field concern the ownership of a parcel and a cover is present, the cover is
        recreated after the rollback.
        """
        # With the CSV file open, it is read to find the line with the last action id.
        with open(self.path + history_table_name, 'r') as csvfile:
            file_reader = csv.DictReader(csvfile, delimiter=';', quotechar='|', quoting=csv.QUOTE_MINIMAL)
            # Empty list to hold the lines of the field to rewrite.
            lines = []
            for row in file_reader:
                if int(row[history_field_action]) == self.action:
                    # Stop the history of modification to no rewrite the rollback in the CSV.
                    self.signal_stop = 1
                    # Get information from file.
                    feature_id = int(row[history_field_feature])  # Id of the feature.
                    layer = self.project.mapLayersByName(row[history_field_layer])[0]  # Layer of the feature.
                    field = row[history_field_field]  # Field modified.
                    field_idx = int(row[history_field_field_idx])  # Index of the modified field.
                    old = row[history_field_previous]  # Previous value.
                    new = row[history_field_next]  # New value.
                    # Modification of the layer from new value to the previous value.
                    if layer.isEditable():
                        layer.changeAttributeValue(feature_id, field_idx, old, new)
                    else:
                        layer.startEditing()
                        layer.changeAttributeValue(feature_id, field_idx, old, new)
                # If the action id of the line is not equal to the action count. The line is added to a list.
                else:
                    lines.append(row)
            layer.commitChanges()
            layer.triggerRepaint()
            if (field == field_parcel_practice and
                    self.tab_widget.currentIndex() == self.tab_widget_management.tab_index_agricultural_practices):
                # List the layers present in the project
                names = [layer.name() for layer in self.project.mapLayers().values()]
                # If a layer with the name of the cover exist, it is deleted.
                for string in names:
                    if string == agricultural_practices_layer_name:
                        practices_layer = self.project.mapLayersByName(string)
                        self.project.removeMapLayer(practices_layer[0].id())
                self.parcel_layer.selectAll()
                practices_layer = processing.run("native:saveselectedfeatures",
                                                 {'INPUT': self.parcel_layer,
                                                  'OUTPUT': 'memory:' + agricultural_practices_layer_name})['OUTPUT']
                self.parcel_layer.removeSelection()
                self.project.addMapLayers([practices_layer])
                # Load a style for the cover.
                practices_layer.loadNamedStyle(style_parcels_practices)
                practices_layer.triggerRepaint()
                # The layer when added to the project is not always added to the same place depending on the where
                # the user clicked before creating the cover. The cover layer is duplicated at the top of the layer
                # tree and then the first version is deleted.
                root = self.project.layerTreeRoot()
                layer_name = agricultural_practices_layer_name
                practices_layer = self.project.mapLayersByName(layer_name)[0]
                layer_id = root.findLayer(self.project.mapLayersByName(layer_name)[0].id())
                parent_group = layer_id.parent()
                if parent_group.name() != '':
                    mygroup = self.project.layerTreeRoot().findGroup(parent_group.name())
                    self.project.layerTreeRoot().insertLayer(0, practices_layer)
                    mygroup.removeLayer(practices_layer)
                    self.project.layerTreeRoot().findGroup(parent_group.name()).setExpanded(0)
                else:
                    order = root.customLayerOrder()
                    order.insert(0, order.pop(order.index(practices_layer)))
                    root.setCustomLayerOrder(order)
            # Rewrite the file without the lines with the biggest action id.
            with open(self.path + history_table_name, 'w') as writeFile:
                fieldnames = [history_field_action, history_field_layer, history_field_feature, history_field_field,
                              history_field_field_idx, history_field_previous, history_field_next]
                writer = csv.DictWriter(writeFile, fieldnames=fieldnames, delimiter=';', quotechar='|',
                                        quoting=csv.QUOTE_MINIMAL)
                writer.writeheader()
                writer.writerows(lines)
                # If there is no more line, the rollback button is disable until a new action is realized.
                if len(lines) == 0:
                    self.button_rollback.setEnabled(False)
        # If the parcel layer is modified and the modified field concern the ownership of the parcel, the cover is
        # recreated.
        if layer.name() == parcel_layer_name and field == field_parcel_owner:
            names = [layer.name() for layer in self.project.mapLayers().values()]
            for string in names:
                if len(string.split(owner_cover_layer_name, 1)) > 1:
                    owner = string.split(owner_cover_layer_name, 1)[1]
                    self.tab_widget_management.create_cover(owner)
        # Start the history of modification to write changes in the CSV.
        self.signal_stop = 0
        # Decrease the action count by one.
        self.decrement_action()

    # Function to write the modification on the parcel layer and line layer into a CSV file
    def write_change(self, layer, feature_id, field_index, new_value, signal_stop_flow):
        """Write the modification on the parcel layer and line layer into a CSV file.
        The mandatory arguments are :
        - the id of the feature modified
        - the index of the field modified
        - the new value of the field

        If the signal boolean is on 0, the changes are written into the CSV.
        The action count is increased by one, if there is multiple features changed, the count is controlled to keep
        the same number for all features.
        With this signal we can retrieve some informations like the layer, the id of the feature, the index
        of the field and the new value. By using those we can find the field name and the old value.
        We can write all of it in the CSV.
        """
        # Check if the history of modification is started.
        multiple_actions = []
        parcel_type_and_practice = None
        if signal_stop_flow == 1:
            self.signal_stop = 1
        if self.signal_stop == 0:
            layer_name = layer.name()  # Layer name.
            field = layer.fields()[field_index].name()  # Field name.
            old_layer = QgsVectorLayer(layer.dataProvider().dataSourceUri(), "", "ogr")
            old_value=0
            if (old_layer.getFeature(feature_id).attributes()[field_index]):
                old_value = int(old_layer.getFeature(feature_id).attributes()[field_index])  # Old Value.
            if layer.geometryType() == 1:
                if field_index == old_layer.fields().indexFromName(field_line_drain_enabled) or self.drain:
                    multiple_actions = self.drain_modif.ui_creation.write_change()
                    self.drain = True
                    if field_index == old_layer.fields().indexFromName(field_type_line_middle):
                        self.drain = None
                else:
                    multiple_actions = self.multiple_lines_modif.ui_creation.write_change()
            elif layer.geometryType() == 2:
                if field_index == old_layer.fields().indexFromName(field_parcel_drain_enabled):
                    multiple_actions = self.drain_modif.ui_creation.write_change()
                elif field_index == old_layer.fields().indexFromName(field_parcel_owner):
                    multiple_actions = self.cover_creation.ui_creation.write_change()
                elif field_index == old_layer.fields().indexFromName(field_parcel_practice) and \
                        (old_value != 99 and new_value != 99):
                    multiple_actions = self.practices_modification.ui_creation.write_change()
                else:
                    multiple_actions = self.multiple_parcels_modif.ui_creation.write_change()
            if new_value != old_value:
                # A new action is going to be written, we increase the action count by 1.
                self.increment_action()
                # If one action is modifying multiple features, every new feature we decrease the action count by 1 to
                # keep the same number.
                if len(multiple_actions) > 0:
                    if multiple_actions[0] != -1:
                        self.decrement_action()
                    else:
                        multiple_actions.remove(-1)
                # Modifications aren't validate so we can still get the old value from the layer.
                action = self.action  # Action count.
                if (field == field_parcel_practice and
                    self.tab_widget.currentIndex() == self.tab_widget_management.tab_index_agricultural_practices) and \
                        (len(multiple_actions) == 0 or
                         (len(multiple_actions) > 0 and feature_id == multiple_actions[-1])):
                    # List the layers present in the project
                    names = [layers.name() for layers in self.project.mapLayers().values()]
                    # If a layer with the name of the cover exist, it is deleted.
                    for string in names:
                        if string == agricultural_practices_layer_name:
                            practices_layer = self.project.mapLayersByName(string)
                            self.project.removeMapLayer(practices_layer[0].id())
                    self.parcel_layer.selectAll()
                    practices_layer = processing.run("native:saveselectedfeatures",
                                                     {'INPUT': self.parcel_layer,
                                                      'OUTPUT': 'memory:' + agricultural_practices_layer_name})['OUTPUT']
                    self.parcel_layer.removeSelection()
                    self.project.addMapLayers([practices_layer])
                    # Load a style for the cover.
                    practices_layer.loadNamedStyle(style_parcels_practices)
                    practices_layer.triggerRepaint()
                    # The layer when added to the project is not always added to the same place depending on the where
                    # the user clicked before creating the cover. The cover layer is duplicated at the top of the layer
                    # tree and then the first version is deleted.
                    root = self.project.layerTreeRoot()
                    new_layer_name = agricultural_practices_layer_name
                    practices_layer = self.project.mapLayersByName(new_layer_name)[0]
                    layer_id = root.findLayer(self.project.mapLayersByName(new_layer_name)[0].id())
                    parent_group = layer_id.parent()
                    if parent_group.name() != '':
                        mygroup = self.project.layerTreeRoot().findGroup(parent_group.name())
                        self.project.layerTreeRoot().insertLayer(0, practices_layer)
                        mygroup.removeLayer(practices_layer)
                        self.project.layerTreeRoot().findGroup(parent_group.name()).setExpanded(0)
                    else:
                        order = root.customLayerOrder()
                        order.insert(0, order.pop(order.index(practices_layer)))
                        root.setCustomLayerOrder(order)

                # Write those information in the CSV file
                with open(self.path + history_table_name, 'a+', newline='') as csvfile:
                    file_writer = csv.writer(csvfile, delimiter=';', quotechar='|', quoting=csv.QUOTE_MINIMAL)
                    file_writer.writerow([action, layer_name, feature_id, field, field_index, old_value, new_value])
                # If the type of a parcel is modified from a production type to a non-production type, the agricultural
                # practice is going to change as well, the next modification must have the same action number.
                if (new_value in self.config_files.production_type and
                    old_value not in self.config_files.production_type and
                    field == field_type_parcel and
                    layer_name == parcel_layer_name) or \
                        (new_value not in self.config_files.production_type and
                         old_value in self.config_files.production_type and
                         field == field_type_parcel and
                         layer_name == parcel_layer_name):
                    parcel_type_and_practice = True
                if len(multiple_actions) == 0 and parcel_type_and_practice:
                    self.decrement_action()
                # The rollback button is enabled because there is at least 1 line in the file.
                self.button_rollback.setEnabled(True)
        self.signal_stop = 0

    def return_signal(self):
        return self.signal_stop

    def decrement_action(self):
        self.action -= 1

    def increment_action(self):
        self.action += 1
