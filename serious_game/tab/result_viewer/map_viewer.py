# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeomelbaSpirit
                                 A QGIS plugin
 Based on GeoMelba software, meant to be used with the serious game CAUSERIE.
 This file contains the configuration of the map viewer dialog used to compare different analysis.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-08-24
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Jules Grillot / INRAE
        email                : jules.grillot@inrae.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# QT Modules
from PyQt5.QtWidgets import QMainWindow, QDockWidget, QSplitter, QHBoxLayout, QWidget, QLabel, QSpinBox
from PyQt5.Qt import QMessageBox
# Qgis Modules
from qgis.gui import QgsMapCanvas, QgsLayerTreeMapCanvasBridge, QgsLayerTreeView, QgsMessageBar
from qgis.core import QgsProject, QgsLayerTreeModel, QgsField, QgsVectorLayer
from qgis.PyQt.QtWidgets import QPushButton
from qgis.PyQt.QtCore import QVariant
# Personal Modules
from .qrangeslider import QRangeSlider
from ....dictionnaire import field_comparison, field_type_line_middle, river, null, field_incoming_flow, \
    field_flow_production_phyto, field_flow_abatement, style_parcels_comparison, style_lines_comparison, regular_font, \
    field_outgoing_flow, information_selection_error, comparison_window_title, sensitivity_label, \
    turn_comparison_label, comparison_button_name, information_selection_error_comparison_pt1, \
    information_selection_error_comparison_pt2, information_selection_error_comparison_pt3, \
    information_selection_error_comparison_pt4, information_selection_error_comparison_pt5, \
    information_selection_error_comparison_pt6, legend_folder_pt1, legend_folder_pt2, legend_folder_pt3, \
    comparison_river_layer_name_pt1, comparison_river_layer_name_pt2, comparison_parcel_layer_name_pt1, \
    comparison_parcel_layer_name_pt2, comparison_line_layer_name_pt1, comparison_line_layer_name_pt2


class MapViewer(QMainWindow):
    """Class used to open a new canvas to show comparison between different watershed analysis. It limits the number of
    layers on the main canvas.
    """

    def __init__(self):
        """The variables are :
        - the canvas
        - the project
        - the layer tree root to show the layers
        - an integer with the value of the turn

        The window is then created to show the canvas, the layer tree, a spinbox, a range slider and a button.
        """
        QMainWindow.__init__(self, None)

        self._canvas = QgsMapCanvas()
        self.project = QgsProject()
        self._root = self.project.layerTreeRoot()
        self.count_tours = 0

        # Creation of the layer tree.
        self.bridge = QgsLayerTreeMapCanvasBridge(self._root, self._canvas)
        self.model = QgsLayerTreeModel(self._root)
        self.model.setFlag(0x25043)
        self.model.setFlag(QgsLayerTreeModel.ShowLegend)
        self.layer_tree_view = QgsLayerTreeView()
        self.layer_tree_view.setModel(self.model)
        self.layer_tree_dock = QDockWidget("Layers")
        self.layer_tree_dock.setObjectName("layers")
        self.layer_tree_dock.setFeatures(QDockWidget.NoDockWidgetFeatures)
        self.layer_tree_dock.setWidget(self.layer_tree_view)
        # Creation of the splitter between the layer tree and the canvas.
        splitter = QSplitter()
        splitter.addWidget(self.layer_tree_dock)
        splitter.addWidget(self._canvas)
        splitter.setCollapsible(0, False)
        splitter.setStretchFactor(1, 1)
        # Creation of the layout
        layout = QHBoxLayout()
        layout.addWidget(splitter)
        contents = QWidget()
        contents.setLayout(layout)
        self.setCentralWidget(contents)
        # Creation of the status bar which holds the range slider, the button and the spinbox.
        bar = QgsMessageBar()
        self.statusBar().addWidget(bar)
        self.messageBar = lambda: bar
        # Creation of the range slider
        self.range_slider = QRangeSlider(self)
        self.range_slider.setWindowTitle(comparison_window_title)
        # Creation of labels
        spinbox_text = QLabel(self)
        spinbox_text.setFont(regular_font)
        spinbox_text.setText(sensitivity_label)
        slider_text = QLabel(self)
        slider_text.setFont(regular_font)
        slider_text.setText(turn_comparison_label)
        # Creation of the button.
        button_comparison = QPushButton(comparison_button_name)
        button_comparison.setFont(regular_font)
        button_comparison.setMaximumHeight(30)
        button_comparison.setMaximumWidth(170)
        button_comparison.clicked.connect(self.read_comparison_data)
        # Creation of the spinbox.
        self.spinbox = QSpinBox(self)
        self.spinbox.setRange(0, 100)
        self.spinbox.setMaximumWidth(50)
        self.spinbox.setMaximumHeight(30)
        self.spinbox.setSuffix('%')
        self.spinbox.setValue(5)
        # Add widget to the status bar.
        self.statusBar().addPermanentWidget(spinbox_text)
        self.statusBar().addPermanentWidget(self.spinbox)
        self.statusBar().addPermanentWidget(slider_text)
        self.statusBar().addPermanentWidget(self.range_slider)
        self.statusBar().addPermanentWidget(button_comparison)

        self.dock_widget = None

    def init_map_viewer(self, spirit_dock_widget):
        """Set the map viewer for the first time.
        The variables are :
        - the main dock widget of the plugin
        """

        self.dock_widget = spirit_dock_widget

    def update_range_slider(self, count_tours):
        """Update the range slider values with the number of turn.
        The variables are :
        - the number of the last turn.
        """
        self.count_tours = count_tours
        # The range always start at 0 (initial state) until the number of the last turn.
        self.range_slider.setRange(0, count_tours)
        self.range_slider.setMin(0)
        self.range_slider.setMax(count_tours)
        self.range_slider.setEnd(count_tours)
        self.range_slider.show()

    def open_map_viewer(self):
        """Open the map viewer in a new dialog.
        """
        self.show()

    def read_comparison_data(self):
        """Get the values for every layer from the different turns selected by the user. Compare the values depending on
        the sensitivity threshold specified by the user. It allow the user to see the changes made by his territory
        management choices between two turns.
        """
        # Error percent.
        percent = self.spinbox.value() / 100
        # Turn to compare.
        turn_1 = self.range_slider.getRange()[0]
        turn_2 = self.range_slider.getRange()[1]
        # Error message if the last value is bigger than the value of the last turn. Normally not possible.
        if turn_2 > self.count_tours:
            QMessageBox.information(None, information_selection_error, information_selection_error_comparison_pt1,
                                    information_selection_error_comparison_pt2 + str(self.count_tours))
        else:
            # Create a group in the layer tree with the comparison.
            self.dock_widget.signal_stop = 1
            group_name = legend_folder_pt1 + str(turn_1) + legend_folder_pt2 + str(turn_2) + legend_folder_pt3 + str(
                self.spinbox.value()) + '%'
            # Verify if the findGroup(group_name) return an object or None
            if self.project.layerTreeRoot().findGroup(group_name) is not None:
                # If the comparison already exist, an error message is send.
                QMessageBox.information(None, information_selection_error, information_selection_error_comparison_pt3 +
                                        str(turn_1) + information_selection_error_comparison_pt4 + str(turn_2) +
                                        information_selection_error_comparison_pt5 + str(self.spinbox.value()) +
                                        information_selection_error_comparison_pt6)
            else:
                # River comparison on the inflow for every river section.
                self.dock_widget.line_layer.startEditing()
                # Add a field to save the comparison data.
                self.dock_widget.line_layer.addAttribute(QgsField(field_comparison, QVariant.Double, "double", 10, 2))
                # Select only the river_section in the line layer.
                self.dock_widget.line_layer.selectByExpression(
                    "{field_type} = '{river}'".format(
                        field_type=field_type_line_middle, river=river))
                # Get the inflow value for every river section for the two turns.
                for river_section in self.dock_widget.line_layer.selectedFeatures():
                    attrs = river_section.attributes()
                    idx_outflow_1 = self.dock_widget.line_layer.fields().indexFromName(
                        field_outgoing_flow + "_" + str(turn_1))
                    outflow_1 = attrs[idx_outflow_1]
                    idx_outflow_2 = self.dock_widget.line_layer.fields().indexFromName(
                        field_outgoing_flow + "_" + str(turn_2))
                    outflow_2 = attrs[idx_outflow_2]
                    # Sensitivity threshold based on the initial value and the percent from the spinbox.
                    sensitivity_threshold = outflow_1 * percent
                    # If the value from the latest turn is in the sensitivity threshold, the comparative value equal 0.
                    if outflow_1 + sensitivity_threshold >= outflow_2 >= outflow_1 - sensitivity_threshold:
                        comparison_value = 0
                    else:
                        comparison_value = outflow_1 - outflow_2
                    self.dock_widget.line_layer.changeAttributeValue(river_section.id(),
                                                                     self.dock_widget.line_layer.fields().indexFromName(
                                                                         field_comparison), comparison_value)
                self.dock_widget.line_layer.commitChanges()
                self.dock_widget.line_layer.triggerRepaint()

                river_section_layer_name = comparison_river_layer_name_pt1 + str(turn_1) + comparison_river_layer_name_pt2 + str(turn_2)
                # New layer creation, get features and field from line layer and save it as a memory layer.
                feat = self.dock_widget.line_layer.selectedFeatures()
                fields = self.dock_widget.line_layer.fields()
                river_section_layer = QgsVectorLayer("LineString", river_section_layer_name, "memory")
                dp = river_section_layer.dataProvider()
                dp.addAttributes(fields)
                dp.addFeatures(feat)
                river_section_layer.commitChanges()
                river_section_layer.updateExtents()
                self.dock_widget.line_layer.removeSelection()

                # Parcel comparison on the agricultural input production for every parcel.
                self.dock_widget.parcel_layer.startEditing()
                # Add a field to save the comparison data.
                self.dock_widget.parcel_layer.addAttribute(QgsField(field_comparison, QVariant.Double, "double", 10, 2))
                # Get the agricultural input production value for every parcel for the two turns.
                for parcel in self.dock_widget.parcel_layer.getFeatures():
                    attrs = parcel.attributes()
                    idx_prod_1 = self.dock_widget.parcel_layer.fields().indexFromName(
                        field_flow_production_phyto + "_" + str(turn_1))
                    prod_1 = attrs[idx_prod_1]
                    idx_prod_2 = self.dock_widget.parcel_layer.fields().indexFromName(
                        field_flow_production_phyto + "_" + str(turn_2))
                    prod_2 = attrs[idx_prod_2]
                    # Sensitivity threshold based on the initial value and the percent from the spinbox.
                    sensitivity_threshold = prod_1 * percent
                    # If the value from the latest turn is in the sensitivity threshold, the comparative value equal 0.
                    if prod_2 + sensitivity_threshold >= prod_1 >= prod_2 - sensitivity_threshold:
                        comparison_value = 0
                    else:
                        comparison_value = prod_1 - prod_2
                    self.dock_widget.parcel_layer.changeAttributeValue(
                        parcel.id(), self.dock_widget.parcel_layer.fields().indexFromName(
                            field_comparison), comparison_value)
                self.dock_widget.parcel_layer.commitChanges()
                self.dock_widget.parcel_layer.triggerRepaint()
                # New layer creation, get features and field from parcel layer and save it as a memory layer.
                parcel_layer_name = comparison_parcel_layer_name_pt1 + str(turn_1) + comparison_parcel_layer_name_pt2 + str(turn_2)
                self.dock_widget.parcel_layer.selectAll()
                feat = self.dock_widget.parcel_layer.selectedFeatures()
                fields = self.dock_widget.parcel_layer.fields()
                parcel_layer = QgsVectorLayer("Polygon", parcel_layer_name, "memory")
                dp = parcel_layer.dataProvider()
                dp.addAttributes(fields)
                dp.addFeatures(feat)
                parcel_layer.commitChanges()
                parcel_layer.updateExtents()
                self.dock_widget.parcel_layer.removeSelection()

                # Line comparison on the efficiency to deduct inflow.
                self.dock_widget.line_layer.startEditing()
                # Add a field to save the comparison data.
                self.dock_widget.line_layer.addAttribute(QgsField(field_comparison, QVariant.Double, "double", 10, 2))
                # Select lines which are not river section or are not null.
                self.dock_widget.line_layer.selectByExpression(
                    "{field_type} != '{river}' and {field_type} != '{null}'".format(
                        field_type=field_type_line_middle, river=river, null=null))
                # Get the inflow and abatement for every line for the two turns.
                for line in self.dock_widget.line_layer.selectedFeatures():
                    attrs = line.attributes()
                    idx_inflow_1 = self.dock_widget.line_layer.fields().indexFromName(
                        field_incoming_flow + "_" + str(turn_1))
                    inflow_1 = attrs[idx_inflow_1]

                    idx_abatement_1 = self.dock_widget.line_layer.fields().indexFromName(
                        field_flow_abatement + "_" + str(turn_1))
                    abatement_1 = attrs[idx_abatement_1]

                    # idx_type_1 = self.dock_widget.line_layer.fields().indexFromName(
                    #     field_type_line_middle + "_" + str(turn_1))
                    # type_1 = attrs[idx_type_1]

                    idx_inflow_2 = self.dock_widget.line_layer.fields().indexFromName(
                        field_incoming_flow + "_" + str(turn_2))
                    inflow_2 = attrs[idx_inflow_2]

                    idx_abatement_2 = self.dock_widget.line_layer.fields().indexFromName(
                        field_flow_abatement + "_" + str(turn_2))
                    abatement_2 = attrs[idx_abatement_2]

                    # idx_type_2 = self.dock_widget.line_layer.fields().indexFromName(
                    #     field_type_line_middle + "_" + str(turn_2))
                    # type_2 = attrs[idx_type_2]

                    if inflow_1 != 0 and inflow_2 != 0:
                        value_1 = abatement_1 / inflow_1
                        value_2 = abatement_2 / inflow_2
                        # Sensitivity threshold based on the initial value and the percent from the spinbox.
                        sensitivity_threshold = value_1 * percent
                        # If the value from the latest turn is in the sensitivity threshold, the comparative value
                        # equal 0.
                        if value_1 + sensitivity_threshold >= value_2 >= value_1 - sensitivity_threshold:
                            comparison_value = 0
                            # if type_1 != type_2:
                            #     comparison_value =
                        else:
                            comparison_value = value_2 - value_1
                        self.dock_widget.line_layer.changeAttributeValue(
                            line.id(), self.dock_widget.line_layer.fields().indexFromName(field_comparison),
                            comparison_value)
                self.dock_widget.line_layer.commitChanges()
                self.dock_widget.line_layer.triggerRepaint()
                # New layer creation, get features and field from parcel layer and save it as a memory layer.
                line_layer_name = comparison_line_layer_name_pt1 + str(turn_1) + comparison_line_layer_name_pt2 + str(
                    turn_2)
                feat = self.dock_widget.line_layer.selectedFeatures()
                fields = self.dock_widget.line_layer.fields()
                line_layer = QgsVectorLayer("LineString", line_layer_name, "memory")
                dp = line_layer.dataProvider()
                dp.addAttributes(fields)
                dp.addFeatures(feat)
                line_layer.commitChanges()
                line_layer.updateExtents()
                self.dock_widget.line_layer.removeSelection()
                # Method to load layers in the canvas with specific style.
                self.load_layers(parcel_layer, line_layer, river_section_layer, group_name)
                self.dock_widget.signal_stop = 0

    def load_layers(self, parcel_layer, line_layer, river_section_layer, group_name):
        """Add layers to the canvas and layer tree. A style is also apply to the layers.
        """
        # Add layers to the canvas but not to the layer tree to place them in the group layer.
        layers = [river_section_layer, line_layer, parcel_layer]
        self.project.addMapLayers(layers, False)
        # Zoom on the watershed.
        self._canvas.setExtent(parcel_layer.extent())
        self._canvas.zoomToFeatureExtent(river_section_layer.extent())
        # Add style to layers.
        line_layer.loadNamedStyle(style_lines_comparison)
        line_layer.triggerRepaint()
        river_section_layer.loadNamedStyle(style_lines_comparison)
        river_section_layer.triggerRepaint()
        parcel_layer.loadNamedStyle(style_parcels_comparison)
        parcel_layer.triggerRepaint()
        # Add the group layer to the layer tree.
        self.project.layerTreeRoot().insertGroup(0, group_name)
        group = self.project.layerTreeRoot().findGroup(group_name)
        # Add the layers to the layer tree.
        group.addLayer(river_section_layer)
        group.addLayer(line_layer)
        group.addLayer(parcel_layer)
