# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeomelbaSpirit
                                 A QGIS plugin
 Based on GeoMelba software, meant to be used with the serious game CAUSERIE.
 This file contains the functions to use when the user configure the dock widget.
 Buttons and widget of the dock widget are controlled with functions from this file.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-08-24
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Jules Grillot / INRAE
        email                : jules.grillot@inrae.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import csv
import os
# Import personnal modules
from ..dictionnaire import data_folder, watershed_prefix, config_practices_file, config_slope_file, \
    config_land_cover_file, config_line_type_file, config_drain_file


class ConfigFilesImport:

    def __init__(self, path=None, watershed_name=None):
        # Get multiple parameters from the CSV in the watershed directory.
        self.practices = {}
        self.slope = {}
        self.land_cover = {}
        self.abatement_type = []
        self.abatement = {}
        self.abatement_water = {}
        self.abatement_mes = {}
        self.abatement_phyto = {}
        self.production_type = []
        self.production = {}
        self.production_water = {}
        self.production_mes = {}
        self.production_phyto = {}
        self.line_type = {}
        self.abatement_type_long = []
        self.abatement_type_lat = []
        self.abatement_long = {}
        self.abatement_long_water = {}
        self.abatement_long_mes = {}
        self.abatement_long_phyto = {}
        self.abatement_lat = {}
        self.abatement_lat_water = {}
        self.abatement_lat_mes = {}
        self.abatement_lat_phyto = {}
        self.drain_type = {}
        self.path = path + data_folder + watershed_prefix + watershed_name + "/"
        self.import_config_files()

    def import_config_files(self):
        table_name = config_practices_file

        with open(self.path + table_name, 'r', newline='') as csvfile:
            file_reader = csv.DictReader(csvfile, delimiter=',', quotechar='|', quoting=csv.QUOTE_MINIMAL)
            for row in file_reader:
                self.practices[row["key"]] = int(row["value"])

        table_name = config_slope_file
        with open(self.path + table_name, 'r', newline='') as csvfile:
            file_reader = csv.DictReader(csvfile, delimiter=',', quotechar='|', quoting=csv.QUOTE_MINIMAL)
            for row in file_reader:
                self.slope[row["key"]] = [int(row["slope_min"]), int(row["slope_max"])]

        table_name = config_land_cover_file
        with open(self.path + table_name, 'r', newline='') as csvfile:
            file_reader = csv.DictReader(csvfile, delimiter=',', quotechar='|', quoting=csv.QUOTE_MINIMAL)
            for row in file_reader:
                self.land_cover[row["key"]] = int(row["value"])
                if row["abatement"] == str(True):
                    self.abatement_type.append(int(row["value"]))
                    self.abatement[int(row["value"])] = [int(row["abatement_phyto_value_low_slope"]),
                                                         int(row["abatement_phyto_value_medium_slope"]),
                                                         int(row["abatement_phyto_value_high_slope"])]
                    self.abatement_water[int(row["value"])] = [int(row["abatement_eau_value_low_slope"]),
                                                               int(row["abatement_eau_value_medium_slope"]),
                                                               int(row["abatement_eau_value_high_slope"])]
                    self.abatement_mes[int(row["value"])] = [int(row["abatement_mes_value_low_slope"]),
                                                             int(row["abatement_mes_value_medium_slope"]),
                                                             int(row["abatement_mes_value_high_slope"])]
                    self.abatement_phyto[int(row["value"])] = [int(row["abatement_phyto_value_low_slope"]),
                                                               int(row["abatement_phyto_value_medium_slope"]),
                                                               int(row["abatement_phyto_value_high_slope"])]
                if row["production"] == str(True):
                    self.production_type.append(int(row["value"]))
                    n = 0
                    practices_values = {}
                    while n < len(self.practices):
                        n = n + 1
                        practices_values[n] = [float(row["phyto_production_value_practice" + str(n) + "_low_slope"]),
                                               float(row["phyto_production_value_practice" + str(n) + "_medium_slope"]),
                                               float(row["phyto_production_value_practice" + str(n) + "_high_slope"])]
                    self.production[int(row["value"])] = practices_values
                    n = 0
                    practices_values = {}
                    while n < len(self.practices):
                        n = n + 1
                        practices_values[n] = [float(row["eau_production_value_practice" + str(n) + "_low_slope"]),
                                               float(row["eau_production_value_practice" + str(n) + "_medium_slope"]),
                                               float(row["eau_production_value_practice" + str(n) + "_high_slope"])]
                    self.production_water[int(row["value"])] = practices_values
                    n = 0
                    practices_values = {}
                    while n < len(self.practices):
                        n = n + 1
                        practices_values[n] = [float(row["mes_production_value_practice" + str(n) + "_low_slope"]),
                                               float(row["mes_production_value_practice" + str(n) + "_medium_slope"]),
                                               float(row["mes_production_value_practice" + str(n) + "_high_slope"])]
                    self.production_mes[int(row["value"])] = practices_values
                    n = 0
                    practices_values = {}
                    while n < len(self.practices):
                        n = n + 1
                        practices_values[n] = [float(row["phyto_production_value_practice" + str(n) + "_low_slope"]),
                                               float(row["phyto_production_value_practice" + str(n) + "_medium_slope"]),
                                               float(row["phyto_production_value_practice" + str(n) + "_high_slope"])]
                    self.production_phyto[int(row["value"])] = practices_values

        table_name = config_line_type_file
        with open(self.path + table_name, 'r', newline='') as csvfile:
            file_reader = csv.DictReader(csvfile, delimiter=',', quotechar='|', quoting=csv.QUOTE_MINIMAL)
            for row in file_reader:
                self.line_type[row["key"]] = int(row["value"])
                if row["abatement_long"] == str(True):
                    self.abatement_type_long.append(int(row["value"]))
                    self.abatement_long[int(row["value"])] = float(row["abatement_long_phyto_value"])
                    self.abatement_long_water[int(row["value"])] = float(row["abatement_long_eau_value"])
                    self.abatement_long_mes[int(row["value"])] = float(row["abatement_long_mes_value"])
                    self.abatement_long_phyto[int(row["value"])] = float(row["abatement_long_phyto_value"])
                if row["abatement_lat"] == str(True):
                    self.abatement_type_lat.append(int(row["value"]))
                    self.abatement_lat[int(row["value"])] = float(row["abatement_lat_phyto_value"])
                    self.abatement_lat_water[int(row["value"])] = float(row["abatement_lat_eau_value"])
                    self.abatement_lat_mes[int(row["value"])] = float(row["abatement_lat_mes_value"])
                    self.abatement_lat_phyto[int(row["value"])] = float(row["abatement_lat_phyto_value"])

        table_name = config_drain_file
        if os.path.exists(self.path + table_name):
            with open(self.path + table_name, 'r', newline='') as csvfile:
                file_reader = csv.DictReader(csvfile, delimiter=',', quotechar='|', quoting=csv.QUOTE_MINIMAL)
                for row in file_reader:
                    self.drain_type[row["key"]] = row["type"]
